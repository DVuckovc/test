
RTOSDemo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005054  00400000  00400000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000440  20000000  00405054  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000ba48  20000440  00405494  00020440  2**2
                  ALLOC
  3 .stack        00003000  2000be88  00410edc  00020440  2**0
                  ALLOC
  4 .ARM.attributes 0000002a  00000000  00000000  00020440  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  0002046a  2**0
                  CONTENTS, READONLY
  6 .debug_info   00017cd2  00000000  00000000  000204c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002ab7  00000000  00000000  00038195  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00009329  00000000  00000000  0003ac4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000988  00000000  00000000  00043f75  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000c98  00000000  00000000  000448fd  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001217f  00000000  00000000  00045595  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000b4f5  00000000  00000000  00057714  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0005a608  00000000  00000000  00062c09  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001b60  00000000  00000000  000bd214  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	88 ee 00 20 01 03 40 00 fd 02 40 00 fd 02 40 00     ... ..@...@...@.
  400010:	fd 02 40 00 fd 02 40 00 fd 02 40 00 00 00 00 00     ..@...@...@.....
	...
  40002c:	81 08 40 00 fd 02 40 00 00 00 00 00 21 09 40 00     ..@...@.....!.@.
  40003c:	65 09 40 00 fd 02 40 00 fd 02 40 00 fd 02 40 00     e.@...@...@...@.
  40004c:	fd 02 40 00 fd 02 40 00 fd 02 40 00 fd 02 40 00     ..@...@...@...@.
  40005c:	00 00 00 00 fd 02 40 00 fd 02 40 00 00 00 00 00     ......@...@.....
  40006c:	fd 02 40 00 fd 02 40 00 00 00 00 00 fd 02 40 00     ..@...@.......@.
  40007c:	fd 02 40 00 00 00 00 00 00 00 00 00 fd 02 40 00     ..@...........@.
  40008c:	fd 02 40 00 fd 02 40 00 fd 02 40 00 fd 02 40 00     ..@...@...@...@.
  40009c:	fd 02 40 00 fd 02 40 00 fd 02 40 00 00 00 00 00     ..@...@...@.....
	...
  4000b4:	fd 02 40 00 fd 02 40 00 fd 02 40 00 fd 02 40 00     ..@...@...@...@.
  4000c4:	fd 02 40 00 fd 02 40 00                             ..@...@.

004000cc <__do_global_dtors_aux>:
  4000cc:	b510      	push	{r4, lr}
  4000ce:	4c05      	ldr	r4, [pc, #20]	; (4000e4 <__do_global_dtors_aux+0x18>)
  4000d0:	7823      	ldrb	r3, [r4, #0]
  4000d2:	b933      	cbnz	r3, 4000e2 <__do_global_dtors_aux+0x16>
  4000d4:	4b04      	ldr	r3, [pc, #16]	; (4000e8 <__do_global_dtors_aux+0x1c>)
  4000d6:	b113      	cbz	r3, 4000de <__do_global_dtors_aux+0x12>
  4000d8:	4804      	ldr	r0, [pc, #16]	; (4000ec <__do_global_dtors_aux+0x20>)
  4000da:	f3af 8000 	nop.w
  4000de:	2301      	movs	r3, #1
  4000e0:	7023      	strb	r3, [r4, #0]
  4000e2:	bd10      	pop	{r4, pc}
  4000e4:	20000440 	.word	0x20000440
  4000e8:	00000000 	.word	0x00000000
  4000ec:	00405054 	.word	0x00405054

004000f0 <frame_dummy>:
  4000f0:	4b0c      	ldr	r3, [pc, #48]	; (400124 <frame_dummy+0x34>)
  4000f2:	b143      	cbz	r3, 400106 <frame_dummy+0x16>
  4000f4:	480c      	ldr	r0, [pc, #48]	; (400128 <frame_dummy+0x38>)
  4000f6:	490d      	ldr	r1, [pc, #52]	; (40012c <frame_dummy+0x3c>)
  4000f8:	b510      	push	{r4, lr}
  4000fa:	f3af 8000 	nop.w
  4000fe:	480c      	ldr	r0, [pc, #48]	; (400130 <frame_dummy+0x40>)
  400100:	6803      	ldr	r3, [r0, #0]
  400102:	b923      	cbnz	r3, 40010e <frame_dummy+0x1e>
  400104:	bd10      	pop	{r4, pc}
  400106:	480a      	ldr	r0, [pc, #40]	; (400130 <frame_dummy+0x40>)
  400108:	6803      	ldr	r3, [r0, #0]
  40010a:	b933      	cbnz	r3, 40011a <frame_dummy+0x2a>
  40010c:	4770      	bx	lr
  40010e:	4b09      	ldr	r3, [pc, #36]	; (400134 <frame_dummy+0x44>)
  400110:	2b00      	cmp	r3, #0
  400112:	d0f7      	beq.n	400104 <frame_dummy+0x14>
  400114:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400118:	4718      	bx	r3
  40011a:	4b06      	ldr	r3, [pc, #24]	; (400134 <frame_dummy+0x44>)
  40011c:	2b00      	cmp	r3, #0
  40011e:	d0f5      	beq.n	40010c <frame_dummy+0x1c>
  400120:	4718      	bx	r3
  400122:	bf00      	nop
  400124:	00000000 	.word	0x00000000
  400128:	00405054 	.word	0x00405054
  40012c:	20000444 	.word	0x20000444
  400130:	00405054 	.word	0x00405054
  400134:	00000000 	.word	0x00000000

00400138 <board_init>:
#include <asf.h>
#include <board.h>
#include <conf_board.h>

void board_init(void)
{
  400138:	b510      	push	{r4, lr}
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  40013a:	200b      	movs	r0, #11
  40013c:	4c05      	ldr	r4, [pc, #20]	; (400154 <board_init+0x1c>)
  40013e:	47a0      	blx	r4
  400140:	200c      	movs	r0, #12
  400142:	47a0      	blx	r4
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  400144:	4b04      	ldr	r3, [pc, #16]	; (400158 <board_init+0x20>)
  400146:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  40014a:	611a      	str	r2, [r3, #16]
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40014c:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  400150:	bd10      	pop	{r4, pc}
  400152:	bf00      	nop
  400154:	004002a9 	.word	0x004002a9
  400158:	400e1200 	.word	0x400e1200

0040015c <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  40015c:	b510      	push	{r4, lr}
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  40015e:	480e      	ldr	r0, [pc, #56]	; (400198 <sysclk_init+0x3c>)
  400160:	4b0e      	ldr	r3, [pc, #56]	; (40019c <sysclk_init+0x40>)
  400162:	4798      	blx	r3
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  400164:	213e      	movs	r1, #62	; 0x3e
  400166:	2000      	movs	r0, #0
  400168:	4b0d      	ldr	r3, [pc, #52]	; (4001a0 <sysclk_init+0x44>)
  40016a:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  40016c:	4c0d      	ldr	r4, [pc, #52]	; (4001a4 <sysclk_init+0x48>)
  40016e:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  400170:	2800      	cmp	r0, #0
  400172:	d0fc      	beq.n	40016e <sysclk_init+0x12>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  400174:	4b0c      	ldr	r3, [pc, #48]	; (4001a8 <sysclk_init+0x4c>)
  400176:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  400178:	4a0c      	ldr	r2, [pc, #48]	; (4001ac <sysclk_init+0x50>)
  40017a:	4b0d      	ldr	r3, [pc, #52]	; (4001b0 <sysclk_init+0x54>)
  40017c:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
  40017e:	4c0d      	ldr	r4, [pc, #52]	; (4001b4 <sysclk_init+0x58>)
  400180:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  400182:	2800      	cmp	r0, #0
  400184:	d0fc      	beq.n	400180 <sysclk_init+0x24>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  400186:	2010      	movs	r0, #16
  400188:	4b0b      	ldr	r3, [pc, #44]	; (4001b8 <sysclk_init+0x5c>)
  40018a:	4798      	blx	r3
		pmc_switch_mck_to_pllbck(CONFIG_SYSCLK_PRES);
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  40018c:	4b0b      	ldr	r3, [pc, #44]	; (4001bc <sysclk_init+0x60>)
  40018e:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  400190:	4801      	ldr	r0, [pc, #4]	; (400198 <sysclk_init+0x3c>)
  400192:	4b02      	ldr	r3, [pc, #8]	; (40019c <sysclk_init+0x40>)
  400194:	4798      	blx	r3
  400196:	bd10      	pop	{r4, pc}
  400198:	07270e00 	.word	0x07270e00
  40019c:	004004bd 	.word	0x004004bd
  4001a0:	00400225 	.word	0x00400225
  4001a4:	00400279 	.word	0x00400279
  4001a8:	00400289 	.word	0x00400289
  4001ac:	20133f01 	.word	0x20133f01
  4001b0:	400e0400 	.word	0x400e0400
  4001b4:	00400299 	.word	0x00400299
  4001b8:	004001c1 	.word	0x004001c1
  4001bc:	004003ad 	.word	0x004003ad

004001c0 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  4001c0:	4a17      	ldr	r2, [pc, #92]	; (400220 <pmc_switch_mck_to_pllack+0x60>)
  4001c2:	6b13      	ldr	r3, [r2, #48]	; 0x30
  4001c4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  4001c8:	4318      	orrs	r0, r3
  4001ca:	6310      	str	r0, [r2, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4001cc:	6e93      	ldr	r3, [r2, #104]	; 0x68
  4001ce:	f013 0f08 	tst.w	r3, #8
  4001d2:	d10a      	bne.n	4001ea <pmc_switch_mck_to_pllack+0x2a>
  4001d4:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4001d8:	4911      	ldr	r1, [pc, #68]	; (400220 <pmc_switch_mck_to_pllack+0x60>)
  4001da:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  4001dc:	f012 0f08 	tst.w	r2, #8
  4001e0:	d103      	bne.n	4001ea <pmc_switch_mck_to_pllack+0x2a>
			--ul_timeout) {
		if (ul_timeout == 0) {
  4001e2:	3b01      	subs	r3, #1
  4001e4:	d1f9      	bne.n	4001da <pmc_switch_mck_to_pllack+0x1a>
			return 1;
  4001e6:	2001      	movs	r0, #1
  4001e8:	4770      	bx	lr
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  4001ea:	4a0d      	ldr	r2, [pc, #52]	; (400220 <pmc_switch_mck_to_pllack+0x60>)
  4001ec:	6b13      	ldr	r3, [r2, #48]	; 0x30
  4001ee:	f023 0303 	bic.w	r3, r3, #3
  4001f2:	f043 0302 	orr.w	r3, r3, #2
  4001f6:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4001f8:	6e93      	ldr	r3, [r2, #104]	; 0x68
  4001fa:	f013 0f08 	tst.w	r3, #8
  4001fe:	d10a      	bne.n	400216 <pmc_switch_mck_to_pllack+0x56>
  400200:	f44f 6300 	mov.w	r3, #2048	; 0x800
  400204:	4906      	ldr	r1, [pc, #24]	; (400220 <pmc_switch_mck_to_pllack+0x60>)
  400206:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  400208:	f012 0f08 	tst.w	r2, #8
  40020c:	d105      	bne.n	40021a <pmc_switch_mck_to_pllack+0x5a>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40020e:	3b01      	subs	r3, #1
  400210:	d1f9      	bne.n	400206 <pmc_switch_mck_to_pllack+0x46>
			return 1;
  400212:	2001      	movs	r0, #1
		}
	}

	return 0;
}
  400214:	4770      	bx	lr
	return 0;
  400216:	2000      	movs	r0, #0
  400218:	4770      	bx	lr
  40021a:	2000      	movs	r0, #0
  40021c:	4770      	bx	lr
  40021e:	bf00      	nop
  400220:	400e0400 	.word	0x400e0400

00400224 <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  400224:	b9c8      	cbnz	r0, 40025a <pmc_switch_mainck_to_xtal+0x36>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  400226:	4a11      	ldr	r2, [pc, #68]	; (40026c <pmc_switch_mainck_to_xtal+0x48>)
  400228:	6a13      	ldr	r3, [r2, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  40022a:	0209      	lsls	r1, r1, #8
  40022c:	b289      	uxth	r1, r1
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  40022e:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  400232:	f023 0303 	bic.w	r3, r3, #3
  400236:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  40023a:	f043 0301 	orr.w	r3, r3, #1
  40023e:	430b      	orrs	r3, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  400240:	6213      	str	r3, [r2, #32]
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  400242:	6e93      	ldr	r3, [r2, #104]	; 0x68
  400244:	f013 0f01 	tst.w	r3, #1
  400248:	d0fb      	beq.n	400242 <pmc_switch_mainck_to_xtal+0x1e>

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  40024a:	4a08      	ldr	r2, [pc, #32]	; (40026c <pmc_switch_mainck_to_xtal+0x48>)
  40024c:	6a13      	ldr	r3, [r2, #32]
  40024e:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  400252:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  400256:	6213      	str	r3, [r2, #32]
  400258:	4770      	bx	lr
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40025a:	4904      	ldr	r1, [pc, #16]	; (40026c <pmc_switch_mainck_to_xtal+0x48>)
  40025c:	6a0b      	ldr	r3, [r1, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  40025e:	4a04      	ldr	r2, [pc, #16]	; (400270 <pmc_switch_mainck_to_xtal+0x4c>)
  400260:	401a      	ands	r2, r3
  400262:	4b04      	ldr	r3, [pc, #16]	; (400274 <pmc_switch_mainck_to_xtal+0x50>)
  400264:	4313      	orrs	r3, r2
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  400266:	620b      	str	r3, [r1, #32]
  400268:	4770      	bx	lr
  40026a:	bf00      	nop
  40026c:	400e0400 	.word	0x400e0400
  400270:	fec8fffc 	.word	0xfec8fffc
  400274:	01370002 	.word	0x01370002

00400278 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  400278:	4b02      	ldr	r3, [pc, #8]	; (400284 <pmc_osc_is_ready_mainck+0xc>)
  40027a:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  40027c:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  400280:	4770      	bx	lr
  400282:	bf00      	nop
  400284:	400e0400 	.word	0x400e0400

00400288 <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  400288:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  40028c:	4b01      	ldr	r3, [pc, #4]	; (400294 <pmc_disable_pllack+0xc>)
  40028e:	629a      	str	r2, [r3, #40]	; 0x28
  400290:	4770      	bx	lr
  400292:	bf00      	nop
  400294:	400e0400 	.word	0x400e0400

00400298 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  400298:	4b02      	ldr	r3, [pc, #8]	; (4002a4 <pmc_is_locked_pllack+0xc>)
  40029a:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  40029c:	f000 0002 	and.w	r0, r0, #2
  4002a0:	4770      	bx	lr
  4002a2:	bf00      	nop
  4002a4:	400e0400 	.word	0x400e0400

004002a8 <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
  4002a8:	2822      	cmp	r0, #34	; 0x22
  4002aa:	d81e      	bhi.n	4002ea <pmc_enable_periph_clk+0x42>
		return 1;
	}

	if (ul_id < 32) {
  4002ac:	281f      	cmp	r0, #31
  4002ae:	d80c      	bhi.n	4002ca <pmc_enable_periph_clk+0x22>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  4002b0:	4b11      	ldr	r3, [pc, #68]	; (4002f8 <pmc_enable_periph_clk+0x50>)
  4002b2:	699a      	ldr	r2, [r3, #24]
  4002b4:	2301      	movs	r3, #1
  4002b6:	4083      	lsls	r3, r0
  4002b8:	4393      	bics	r3, r2
  4002ba:	d018      	beq.n	4002ee <pmc_enable_periph_clk+0x46>
			PMC->PMC_PCER0 = 1 << ul_id;
  4002bc:	2301      	movs	r3, #1
  4002be:	fa03 f000 	lsl.w	r0, r3, r0
  4002c2:	4b0d      	ldr	r3, [pc, #52]	; (4002f8 <pmc_enable_periph_clk+0x50>)
  4002c4:	6118      	str	r0, [r3, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  4002c6:	2000      	movs	r0, #0
  4002c8:	4770      	bx	lr
		ul_id -= 32;
  4002ca:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  4002cc:	4b0a      	ldr	r3, [pc, #40]	; (4002f8 <pmc_enable_periph_clk+0x50>)
  4002ce:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  4002d2:	2301      	movs	r3, #1
  4002d4:	4083      	lsls	r3, r0
  4002d6:	4393      	bics	r3, r2
  4002d8:	d00b      	beq.n	4002f2 <pmc_enable_periph_clk+0x4a>
			PMC->PMC_PCER1 = 1 << ul_id;
  4002da:	2301      	movs	r3, #1
  4002dc:	fa03 f000 	lsl.w	r0, r3, r0
  4002e0:	4b05      	ldr	r3, [pc, #20]	; (4002f8 <pmc_enable_periph_clk+0x50>)
  4002e2:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
	return 0;
  4002e6:	2000      	movs	r0, #0
  4002e8:	4770      	bx	lr
		return 1;
  4002ea:	2001      	movs	r0, #1
  4002ec:	4770      	bx	lr
	return 0;
  4002ee:	2000      	movs	r0, #0
  4002f0:	4770      	bx	lr
  4002f2:	2000      	movs	r0, #0
}
  4002f4:	4770      	bx	lr
  4002f6:	bf00      	nop
  4002f8:	400e0400 	.word	0x400e0400

004002fc <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4002fc:	e7fe      	b.n	4002fc <Dummy_Handler>
	...

00400300 <Reset_Handler>:
{
  400300:	b508      	push	{r3, lr}
	if (pSrc > pDest) {
  400302:	4b21      	ldr	r3, [pc, #132]	; (400388 <Reset_Handler+0x88>)
  400304:	4a21      	ldr	r2, [pc, #132]	; (40038c <Reset_Handler+0x8c>)
  400306:	429a      	cmp	r2, r3
  400308:	d928      	bls.n	40035c <Reset_Handler+0x5c>
		for (; pDest < &_erelocate;) {
  40030a:	4b21      	ldr	r3, [pc, #132]	; (400390 <Reset_Handler+0x90>)
  40030c:	4a1e      	ldr	r2, [pc, #120]	; (400388 <Reset_Handler+0x88>)
  40030e:	429a      	cmp	r2, r3
  400310:	d20c      	bcs.n	40032c <Reset_Handler+0x2c>
  400312:	3b01      	subs	r3, #1
  400314:	1a9b      	subs	r3, r3, r2
  400316:	f023 0303 	bic.w	r3, r3, #3
  40031a:	3304      	adds	r3, #4
  40031c:	4413      	add	r3, r2
  40031e:	491b      	ldr	r1, [pc, #108]	; (40038c <Reset_Handler+0x8c>)
			*pDest++ = *pSrc++;
  400320:	f851 0b04 	ldr.w	r0, [r1], #4
  400324:	f842 0b04 	str.w	r0, [r2], #4
		for (; pDest < &_erelocate;) {
  400328:	429a      	cmp	r2, r3
  40032a:	d1f9      	bne.n	400320 <Reset_Handler+0x20>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
  40032c:	bf00      	nop
	for (pDest = &_szero; pDest < &_ezero;) {
  40032e:	4b19      	ldr	r3, [pc, #100]	; (400394 <Reset_Handler+0x94>)
  400330:	4a19      	ldr	r2, [pc, #100]	; (400398 <Reset_Handler+0x98>)
  400332:	429a      	cmp	r2, r3
  400334:	d20a      	bcs.n	40034c <Reset_Handler+0x4c>
  400336:	3b01      	subs	r3, #1
  400338:	1a9b      	subs	r3, r3, r2
  40033a:	f023 0303 	bic.w	r3, r3, #3
  40033e:	3304      	adds	r3, #4
  400340:	4413      	add	r3, r2
		*pDest++ = 0;
  400342:	2100      	movs	r1, #0
  400344:	f842 1b04 	str.w	r1, [r2], #4
	for (pDest = &_szero; pDest < &_ezero;) {
  400348:	429a      	cmp	r2, r3
  40034a:	d1fb      	bne.n	400344 <Reset_Handler+0x44>
	SCB->VTOR = ((uint32_t) pSrc);
  40034c:	4b13      	ldr	r3, [pc, #76]	; (40039c <Reset_Handler+0x9c>)
  40034e:	4a14      	ldr	r2, [pc, #80]	; (4003a0 <Reset_Handler+0xa0>)
  400350:	609a      	str	r2, [r3, #8]
	__libc_init_array();
  400352:	4b14      	ldr	r3, [pc, #80]	; (4003a4 <Reset_Handler+0xa4>)
  400354:	4798      	blx	r3
	main();
  400356:	4b14      	ldr	r3, [pc, #80]	; (4003a8 <Reset_Handler+0xa8>)
  400358:	4798      	blx	r3
  40035a:	e7fe      	b.n	40035a <Reset_Handler+0x5a>
	} else if (pSrc < pDest) {
  40035c:	4b0a      	ldr	r3, [pc, #40]	; (400388 <Reset_Handler+0x88>)
  40035e:	4a0b      	ldr	r2, [pc, #44]	; (40038c <Reset_Handler+0x8c>)
  400360:	429a      	cmp	r2, r3
  400362:	d2e3      	bcs.n	40032c <Reset_Handler+0x2c>
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  400364:	4b0a      	ldr	r3, [pc, #40]	; (400390 <Reset_Handler+0x90>)
  400366:	4808      	ldr	r0, [pc, #32]	; (400388 <Reset_Handler+0x88>)
  400368:	1a18      	subs	r0, r3, r0
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  40036a:	4611      	mov	r1, r2
  40036c:	3a04      	subs	r2, #4
  40036e:	4402      	add	r2, r0
		for (;nb_bytes;nb_bytes -= 4) {
  400370:	2800      	cmp	r0, #0
  400372:	d0db      	beq.n	40032c <Reset_Handler+0x2c>
  400374:	f1c1 0104 	rsb	r1, r1, #4
			*pDest-- = *pSrc--;
  400378:	f852 0904 	ldr.w	r0, [r2], #-4
  40037c:	f843 0d04 	str.w	r0, [r3, #-4]!
		for (;nb_bytes;nb_bytes -= 4) {
  400380:	42ca      	cmn	r2, r1
  400382:	d1f9      	bne.n	400378 <Reset_Handler+0x78>
  400384:	e7d2      	b.n	40032c <Reset_Handler+0x2c>
  400386:	bf00      	nop
  400388:	20000000 	.word	0x20000000
  40038c:	00405054 	.word	0x00405054
  400390:	20000440 	.word	0x20000440
  400394:	2000be88 	.word	0x2000be88
  400398:	20000440 	.word	0x20000440
  40039c:	e000ed00 	.word	0xe000ed00
  4003a0:	00400000 	.word	0x00400000
  4003a4:	00403d2d 	.word	0x00403d2d
  4003a8:	00403c8d 	.word	0x00403c8d

004003ac <SystemCoreClockUpdate>:
 * \brief Get Core Clock Frequency.
 */
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
  4003ac:	4b3c      	ldr	r3, [pc, #240]	; (4004a0 <SystemCoreClockUpdate+0xf4>)
  4003ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4003b0:	f003 0303 	and.w	r3, r3, #3
  4003b4:	2b03      	cmp	r3, #3
  4003b6:	d80e      	bhi.n	4003d6 <SystemCoreClockUpdate+0x2a>
  4003b8:	e8df f003 	tbb	[pc, r3]
  4003bc:	38381c02 	.word	0x38381c02
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  4003c0:	4b38      	ldr	r3, [pc, #224]	; (4004a4 <SystemCoreClockUpdate+0xf8>)
  4003c2:	695b      	ldr	r3, [r3, #20]
  4003c4:	f013 0f80 	tst.w	r3, #128	; 0x80
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  4003c8:	bf14      	ite	ne
  4003ca:	f44f 4200 	movne.w	r2, #32768	; 0x8000
			} else {
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
  4003ce:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
  4003d2:	4b35      	ldr	r3, [pc, #212]	; (4004a8 <SystemCoreClockUpdate+0xfc>)
  4003d4:	601a      	str	r2, [r3, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  4003d6:	4b32      	ldr	r3, [pc, #200]	; (4004a0 <SystemCoreClockUpdate+0xf4>)
  4003d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4003da:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4003de:	2b70      	cmp	r3, #112	; 0x70
  4003e0:	d055      	beq.n	40048e <SystemCoreClockUpdate+0xe2>
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
			((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  4003e2:	4b2f      	ldr	r3, [pc, #188]	; (4004a0 <SystemCoreClockUpdate+0xf4>)
  4003e4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
		SystemCoreClock >>=
  4003e6:	4930      	ldr	r1, [pc, #192]	; (4004a8 <SystemCoreClockUpdate+0xfc>)
			((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  4003e8:	f3c2 1202 	ubfx	r2, r2, #4, #3
		SystemCoreClock >>=
  4003ec:	680b      	ldr	r3, [r1, #0]
  4003ee:	40d3      	lsrs	r3, r2
  4003f0:	600b      	str	r3, [r1, #0]
  4003f2:	4770      	bx	lr
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  4003f4:	4b2a      	ldr	r3, [pc, #168]	; (4004a0 <SystemCoreClockUpdate+0xf4>)
  4003f6:	6a1b      	ldr	r3, [r3, #32]
  4003f8:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  4003fc:	d003      	beq.n	400406 <SystemCoreClockUpdate+0x5a>
			SystemCoreClock = CHIP_FREQ_XTAL;
  4003fe:	4a2b      	ldr	r2, [pc, #172]	; (4004ac <SystemCoreClockUpdate+0x100>)
  400400:	4b29      	ldr	r3, [pc, #164]	; (4004a8 <SystemCoreClockUpdate+0xfc>)
  400402:	601a      	str	r2, [r3, #0]
  400404:	e7e7      	b.n	4003d6 <SystemCoreClockUpdate+0x2a>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  400406:	4a2a      	ldr	r2, [pc, #168]	; (4004b0 <SystemCoreClockUpdate+0x104>)
  400408:	4b27      	ldr	r3, [pc, #156]	; (4004a8 <SystemCoreClockUpdate+0xfc>)
  40040a:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  40040c:	4b24      	ldr	r3, [pc, #144]	; (4004a0 <SystemCoreClockUpdate+0xf4>)
  40040e:	6a1b      	ldr	r3, [r3, #32]
  400410:	f003 0370 	and.w	r3, r3, #112	; 0x70
  400414:	2b10      	cmp	r3, #16
  400416:	d005      	beq.n	400424 <SystemCoreClockUpdate+0x78>
  400418:	2b20      	cmp	r3, #32
  40041a:	d1dc      	bne.n	4003d6 <SystemCoreClockUpdate+0x2a>
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  40041c:	4a23      	ldr	r2, [pc, #140]	; (4004ac <SystemCoreClockUpdate+0x100>)
  40041e:	4b22      	ldr	r3, [pc, #136]	; (4004a8 <SystemCoreClockUpdate+0xfc>)
  400420:	601a      	str	r2, [r3, #0]
			break;
  400422:	e7d8      	b.n	4003d6 <SystemCoreClockUpdate+0x2a>
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  400424:	4a23      	ldr	r2, [pc, #140]	; (4004b4 <SystemCoreClockUpdate+0x108>)
  400426:	4b20      	ldr	r3, [pc, #128]	; (4004a8 <SystemCoreClockUpdate+0xfc>)
  400428:	601a      	str	r2, [r3, #0]
			break;
  40042a:	e7d4      	b.n	4003d6 <SystemCoreClockUpdate+0x2a>
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  40042c:	4b1c      	ldr	r3, [pc, #112]	; (4004a0 <SystemCoreClockUpdate+0xf4>)
  40042e:	6a1b      	ldr	r3, [r3, #32]
  400430:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  400434:	d018      	beq.n	400468 <SystemCoreClockUpdate+0xbc>
				SystemCoreClock = CHIP_FREQ_XTAL;
  400436:	4a1d      	ldr	r2, [pc, #116]	; (4004ac <SystemCoreClockUpdate+0x100>)
  400438:	4b1b      	ldr	r3, [pc, #108]	; (4004a8 <SystemCoreClockUpdate+0xfc>)
  40043a:	601a      	str	r2, [r3, #0]
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
  40043c:	4b18      	ldr	r3, [pc, #96]	; (4004a0 <SystemCoreClockUpdate+0xf4>)
  40043e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  400440:	f003 0303 	and.w	r3, r3, #3
  400444:	2b02      	cmp	r3, #2
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
  400446:	4a16      	ldr	r2, [pc, #88]	; (4004a0 <SystemCoreClockUpdate+0xf4>)
  400448:	bf07      	ittee	eq
  40044a:	6a91      	ldreq	r1, [r2, #40]	; 0x28
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
  40044c:	6a92      	ldreq	r2, [r2, #40]	; 0x28
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  40044e:	6ad1      	ldrne	r1, [r2, #44]	; 0x2c
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  400450:	6ad2      	ldrne	r2, [r2, #44]	; 0x2c
  400452:	4815      	ldr	r0, [pc, #84]	; (4004a8 <SystemCoreClockUpdate+0xfc>)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
  400454:	f3c1 410a 	ubfx	r1, r1, #16, #11
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  400458:	6803      	ldr	r3, [r0, #0]
  40045a:	fb01 3303 	mla	r3, r1, r3, r3
						>> CKGR_PLLBR_DIVB_Pos));
  40045e:	b2d2      	uxtb	r2, r2
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  400460:	fbb3 f3f2 	udiv	r3, r3, r2
  400464:	6003      	str	r3, [r0, #0]
  400466:	e7b6      	b.n	4003d6 <SystemCoreClockUpdate+0x2a>
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  400468:	4a11      	ldr	r2, [pc, #68]	; (4004b0 <SystemCoreClockUpdate+0x104>)
  40046a:	4b0f      	ldr	r3, [pc, #60]	; (4004a8 <SystemCoreClockUpdate+0xfc>)
  40046c:	601a      	str	r2, [r3, #0]
				switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  40046e:	4b0c      	ldr	r3, [pc, #48]	; (4004a0 <SystemCoreClockUpdate+0xf4>)
  400470:	6a1b      	ldr	r3, [r3, #32]
  400472:	f003 0370 	and.w	r3, r3, #112	; 0x70
  400476:	2b10      	cmp	r3, #16
  400478:	d005      	beq.n	400486 <SystemCoreClockUpdate+0xda>
  40047a:	2b20      	cmp	r3, #32
  40047c:	d1de      	bne.n	40043c <SystemCoreClockUpdate+0x90>
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  40047e:	4a0b      	ldr	r2, [pc, #44]	; (4004ac <SystemCoreClockUpdate+0x100>)
  400480:	4b09      	ldr	r3, [pc, #36]	; (4004a8 <SystemCoreClockUpdate+0xfc>)
  400482:	601a      	str	r2, [r3, #0]
					break;
  400484:	e7da      	b.n	40043c <SystemCoreClockUpdate+0x90>
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  400486:	4a0b      	ldr	r2, [pc, #44]	; (4004b4 <SystemCoreClockUpdate+0x108>)
  400488:	4b07      	ldr	r3, [pc, #28]	; (4004a8 <SystemCoreClockUpdate+0xfc>)
  40048a:	601a      	str	r2, [r3, #0]
					break;
  40048c:	e7d6      	b.n	40043c <SystemCoreClockUpdate+0x90>
		SystemCoreClock /= 3U;
  40048e:	4a06      	ldr	r2, [pc, #24]	; (4004a8 <SystemCoreClockUpdate+0xfc>)
  400490:	6813      	ldr	r3, [r2, #0]
  400492:	4909      	ldr	r1, [pc, #36]	; (4004b8 <SystemCoreClockUpdate+0x10c>)
  400494:	fba1 1303 	umull	r1, r3, r1, r3
  400498:	085b      	lsrs	r3, r3, #1
  40049a:	6013      	str	r3, [r2, #0]
  40049c:	4770      	bx	lr
  40049e:	bf00      	nop
  4004a0:	400e0400 	.word	0x400e0400
  4004a4:	400e1410 	.word	0x400e1410
  4004a8:	20000000 	.word	0x20000000
  4004ac:	00b71b00 	.word	0x00b71b00
  4004b0:	003d0900 	.word	0x003d0900
  4004b4:	007a1200 	.word	0x007a1200
  4004b8:	aaaaaaab 	.word	0xaaaaaaab

004004bc <system_init_flash>:
 */
void system_init_flash( uint32_t ul_clk )
{
  /* Set FWS for embedded Flash access according to operating frequency */
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  4004bc:	4b12      	ldr	r3, [pc, #72]	; (400508 <system_init_flash+0x4c>)
  4004be:	4298      	cmp	r0, r3
  4004c0:	d911      	bls.n	4004e6 <system_init_flash+0x2a>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
  4004c2:	4b12      	ldr	r3, [pc, #72]	; (40050c <system_init_flash+0x50>)
  4004c4:	4298      	cmp	r0, r3
  4004c6:	d913      	bls.n	4004f0 <system_init_flash+0x34>
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
  4004c8:	4b11      	ldr	r3, [pc, #68]	; (400510 <system_init_flash+0x54>)
  4004ca:	4298      	cmp	r0, r3
  4004cc:	d914      	bls.n	4004f8 <system_init_flash+0x3c>
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
  4004ce:	4b11      	ldr	r3, [pc, #68]	; (400514 <system_init_flash+0x58>)
  4004d0:	4298      	cmp	r0, r3
  4004d2:	d915      	bls.n	400500 <system_init_flash+0x44>
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  4004d4:	4b10      	ldr	r3, [pc, #64]	; (400518 <system_init_flash+0x5c>)
  4004d6:	4298      	cmp	r0, r3
					EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  4004d8:	bf94      	ite	ls
  4004da:	f04f 2204 	movls.w	r2, #67109888	; 0x4000400
					} else {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  4004de:	4a0f      	ldrhi	r2, [pc, #60]	; (40051c <system_init_flash+0x60>)
  4004e0:	4b0f      	ldr	r3, [pc, #60]	; (400520 <system_init_flash+0x64>)
  4004e2:	601a      	str	r2, [r3, #0]
  4004e4:	4770      	bx	lr
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  4004e6:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  4004ea:	4b0d      	ldr	r3, [pc, #52]	; (400520 <system_init_flash+0x64>)
  4004ec:	601a      	str	r2, [r3, #0]
  4004ee:	4770      	bx	lr
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  4004f0:	4a0c      	ldr	r2, [pc, #48]	; (400524 <system_init_flash+0x68>)
  4004f2:	4b0b      	ldr	r3, [pc, #44]	; (400520 <system_init_flash+0x64>)
  4004f4:	601a      	str	r2, [r3, #0]
  4004f6:	4770      	bx	lr
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  4004f8:	4a0b      	ldr	r2, [pc, #44]	; (400528 <system_init_flash+0x6c>)
  4004fa:	4b09      	ldr	r3, [pc, #36]	; (400520 <system_init_flash+0x64>)
  4004fc:	601a      	str	r2, [r3, #0]
  4004fe:	4770      	bx	lr
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  400500:	4a0a      	ldr	r2, [pc, #40]	; (40052c <system_init_flash+0x70>)
  400502:	4b07      	ldr	r3, [pc, #28]	; (400520 <system_init_flash+0x64>)
  400504:	601a      	str	r2, [r3, #0]
  400506:	4770      	bx	lr
  400508:	01312cff 	.word	0x01312cff
  40050c:	026259ff 	.word	0x026259ff
  400510:	039386ff 	.word	0x039386ff
  400514:	04c4b3ff 	.word	0x04c4b3ff
  400518:	05f5e0ff 	.word	0x05f5e0ff
  40051c:	04000500 	.word	0x04000500
  400520:	400e0a00 	.word	0x400e0a00
  400524:	04000100 	.word	0x04000100
  400528:	04000200 	.word	0x04000200
  40052c:	04000300 	.word	0x04000300

00400530 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
  400530:	b410      	push	{r4}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  400532:	4b12      	ldr	r3, [pc, #72]	; (40057c <prvInsertBlockIntoFreeList+0x4c>)
  400534:	681a      	ldr	r2, [r3, #0]
  400536:	4282      	cmp	r2, r0
  400538:	d31a      	bcc.n	400570 <prvInsertBlockIntoFreeList+0x40>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
  40053a:	685c      	ldr	r4, [r3, #4]
  40053c:	1919      	adds	r1, r3, r4
  40053e:	4288      	cmp	r0, r1
  400540:	d103      	bne.n	40054a <prvInsertBlockIntoFreeList+0x1a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  400542:	6841      	ldr	r1, [r0, #4]
  400544:	4421      	add	r1, r4
  400546:	6059      	str	r1, [r3, #4]
  400548:	4618      	mov	r0, r3
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
  40054a:	6841      	ldr	r1, [r0, #4]
  40054c:	1844      	adds	r4, r0, r1
  40054e:	42a2      	cmp	r2, r4
  400550:	d112      	bne.n	400578 <prvInsertBlockIntoFreeList+0x48>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
  400552:	4c0b      	ldr	r4, [pc, #44]	; (400580 <prvInsertBlockIntoFreeList+0x50>)
  400554:	6824      	ldr	r4, [r4, #0]
  400556:	42a2      	cmp	r2, r4
  400558:	d00c      	beq.n	400574 <prvInsertBlockIntoFreeList+0x44>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  40055a:	6852      	ldr	r2, [r2, #4]
  40055c:	440a      	add	r2, r1
  40055e:	6042      	str	r2, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  400560:	681a      	ldr	r2, [r3, #0]
  400562:	6812      	ldr	r2, [r2, #0]
  400564:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  400566:	4298      	cmp	r0, r3
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  400568:	bf18      	it	ne
  40056a:	6018      	strne	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  40056c:	bc10      	pop	{r4}
  40056e:	4770      	bx	lr
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  400570:	4613      	mov	r3, r2
  400572:	e7df      	b.n	400534 <prvInsertBlockIntoFreeList+0x4>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  400574:	6002      	str	r2, [r0, #0]
  400576:	e7f6      	b.n	400566 <prvInsertBlockIntoFreeList+0x36>
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
  400578:	6002      	str	r2, [r0, #0]
  40057a:	e7f4      	b.n	400566 <prvInsertBlockIntoFreeList+0x36>
  40057c:	2000a46c 	.word	0x2000a46c
  400580:	2000045c 	.word	0x2000045c

00400584 <pvPortMalloc>:
{
  400584:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400588:	4604      	mov	r4, r0
	vTaskSuspendAll();
  40058a:	4b4c      	ldr	r3, [pc, #304]	; (4006bc <pvPortMalloc+0x138>)
  40058c:	4798      	blx	r3
		if( pxEnd == NULL )
  40058e:	4b4c      	ldr	r3, [pc, #304]	; (4006c0 <pvPortMalloc+0x13c>)
  400590:	681b      	ldr	r3, [r3, #0]
  400592:	b1c3      	cbz	r3, 4005c6 <pvPortMalloc+0x42>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
  400594:	4b4b      	ldr	r3, [pc, #300]	; (4006c4 <pvPortMalloc+0x140>)
  400596:	f8d3 8000 	ldr.w	r8, [r3]
  40059a:	ea18 0f04 	tst.w	r8, r4
  40059e:	d17a      	bne.n	400696 <pvPortMalloc+0x112>
			if( xWantedSize > 0 )
  4005a0:	2c00      	cmp	r4, #0
  4005a2:	f000 8087 	beq.w	4006b4 <pvPortMalloc+0x130>
				xWantedSize += xHeapStructSize;
  4005a6:	3408      	adds	r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
  4005a8:	f014 0f07 	tst.w	r4, #7
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  4005ac:	bf1c      	itt	ne
  4005ae:	f024 0407 	bicne.w	r4, r4, #7
  4005b2:	3408      	addne	r4, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
  4005b4:	2c00      	cmp	r4, #0
  4005b6:	d06e      	beq.n	400696 <pvPortMalloc+0x112>
  4005b8:	4b43      	ldr	r3, [pc, #268]	; (4006c8 <pvPortMalloc+0x144>)
  4005ba:	681f      	ldr	r7, [r3, #0]
  4005bc:	42bc      	cmp	r4, r7
  4005be:	d86a      	bhi.n	400696 <pvPortMalloc+0x112>
				pxBlock = xStart.pxNextFreeBlock;
  4005c0:	4b42      	ldr	r3, [pc, #264]	; (4006cc <pvPortMalloc+0x148>)
  4005c2:	681d      	ldr	r5, [r3, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  4005c4:	e027      	b.n	400616 <pvPortMalloc+0x92>
	uxAddress = ( size_t ) ucHeap;
  4005c6:	4a42      	ldr	r2, [pc, #264]	; (4006d0 <pvPortMalloc+0x14c>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
  4005c8:	f012 0f07 	tst.w	r2, #7
  4005cc:	d01e      	beq.n	40060c <pvPortMalloc+0x88>
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
  4005ce:	1dd1      	adds	r1, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
  4005d0:	f021 0107 	bic.w	r1, r1, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
  4005d4:	f502 4320 	add.w	r3, r2, #40960	; 0xa000
  4005d8:	1a5b      	subs	r3, r3, r1
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
  4005da:	460a      	mov	r2, r1
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  4005dc:	483b      	ldr	r0, [pc, #236]	; (4006cc <pvPortMalloc+0x148>)
  4005de:	6002      	str	r2, [r0, #0]
	xStart.xBlockSize = ( size_t ) 0;
  4005e0:	2100      	movs	r1, #0
  4005e2:	6041      	str	r1, [r0, #4]
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
  4005e4:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
  4005e6:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
  4005e8:	f023 0307 	bic.w	r3, r3, #7
	pxEnd = ( void * ) uxAddress;
  4005ec:	4834      	ldr	r0, [pc, #208]	; (4006c0 <pvPortMalloc+0x13c>)
  4005ee:	6003      	str	r3, [r0, #0]
	pxEnd->xBlockSize = 0;
  4005f0:	6059      	str	r1, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
  4005f2:	6019      	str	r1, [r3, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
  4005f4:	1a99      	subs	r1, r3, r2
  4005f6:	6051      	str	r1, [r2, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  4005f8:	6013      	str	r3, [r2, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  4005fa:	4b36      	ldr	r3, [pc, #216]	; (4006d4 <pvPortMalloc+0x150>)
  4005fc:	6019      	str	r1, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  4005fe:	4b32      	ldr	r3, [pc, #200]	; (4006c8 <pvPortMalloc+0x144>)
  400600:	6019      	str	r1, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  400602:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  400606:	4b2f      	ldr	r3, [pc, #188]	; (4006c4 <pvPortMalloc+0x140>)
  400608:	601a      	str	r2, [r3, #0]
  40060a:	e7c3      	b.n	400594 <pvPortMalloc+0x10>
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
  40060c:	f44f 4320 	mov.w	r3, #40960	; 0xa000
  400610:	e7e4      	b.n	4005dc <pvPortMalloc+0x58>
  400612:	462b      	mov	r3, r5
					pxBlock = pxBlock->pxNextFreeBlock;
  400614:	4615      	mov	r5, r2
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  400616:	686a      	ldr	r2, [r5, #4]
  400618:	4294      	cmp	r4, r2
  40061a:	d902      	bls.n	400622 <pvPortMalloc+0x9e>
  40061c:	682a      	ldr	r2, [r5, #0]
  40061e:	2a00      	cmp	r2, #0
  400620:	d1f7      	bne.n	400612 <pvPortMalloc+0x8e>
				if( pxBlock != pxEnd )
  400622:	4a27      	ldr	r2, [pc, #156]	; (4006c0 <pvPortMalloc+0x13c>)
  400624:	6812      	ldr	r2, [r2, #0]
  400626:	4295      	cmp	r5, r2
  400628:	d035      	beq.n	400696 <pvPortMalloc+0x112>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
  40062a:	681e      	ldr	r6, [r3, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  40062c:	682a      	ldr	r2, [r5, #0]
  40062e:	601a      	str	r2, [r3, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  400630:	686b      	ldr	r3, [r5, #4]
  400632:	1b1b      	subs	r3, r3, r4
  400634:	2b10      	cmp	r3, #16
  400636:	d910      	bls.n	40065a <pvPortMalloc+0xd6>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
  400638:	1928      	adds	r0, r5, r4
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
  40063a:	f010 0f07 	tst.w	r0, #7
  40063e:	d008      	beq.n	400652 <pvPortMalloc+0xce>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
  400640:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  400644:	f383 8811 	msr	BASEPRI, r3
  400648:	f3bf 8f6f 	isb	sy
  40064c:	f3bf 8f4f 	dsb	sy
  400650:	e7fe      	b.n	400650 <pvPortMalloc+0xcc>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  400652:	6043      	str	r3, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
  400654:	606c      	str	r4, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
  400656:	4b20      	ldr	r3, [pc, #128]	; (4006d8 <pvPortMalloc+0x154>)
  400658:	4798      	blx	r3
					xFreeBytesRemaining -= pxBlock->xBlockSize;
  40065a:	686a      	ldr	r2, [r5, #4]
  40065c:	1abf      	subs	r7, r7, r2
  40065e:	491a      	ldr	r1, [pc, #104]	; (4006c8 <pvPortMalloc+0x144>)
  400660:	600f      	str	r7, [r1, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
  400662:	491c      	ldr	r1, [pc, #112]	; (4006d4 <pvPortMalloc+0x150>)
  400664:	6809      	ldr	r1, [r1, #0]
  400666:	428f      	cmp	r7, r1
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
  400668:	bf3c      	itt	cc
  40066a:	491a      	ldrcc	r1, [pc, #104]	; (4006d4 <pvPortMalloc+0x150>)
  40066c:	600f      	strcc	r7, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
  40066e:	ea48 0202 	orr.w	r2, r8, r2
  400672:	606a      	str	r2, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
  400674:	2300      	movs	r3, #0
  400676:	602b      	str	r3, [r5, #0]
		traceMALLOC( pvReturn, xWantedSize );
  400678:	3608      	adds	r6, #8
  40067a:	d01b      	beq.n	4006b4 <pvPortMalloc+0x130>
  40067c:	4622      	mov	r2, r4
  40067e:	4631      	mov	r1, r6
  400680:	2094      	movs	r0, #148	; 0x94
  400682:	4b16      	ldr	r3, [pc, #88]	; (4006dc <pvPortMalloc+0x158>)
  400684:	4798      	blx	r3
	( void ) xTaskResumeAll();
  400686:	4b16      	ldr	r3, [pc, #88]	; (4006e0 <pvPortMalloc+0x15c>)
  400688:	4798      	blx	r3
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
  40068a:	f016 0f07 	tst.w	r6, #7
  40068e:	d108      	bne.n	4006a2 <pvPortMalloc+0x11e>
}
  400690:	4630      	mov	r0, r6
  400692:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	( void ) xTaskResumeAll();
  400696:	4b12      	ldr	r3, [pc, #72]	; (4006e0 <pvPortMalloc+0x15c>)
  400698:	4798      	blx	r3
			vApplicationMallocFailedHook();
  40069a:	4b12      	ldr	r3, [pc, #72]	; (4006e4 <pvPortMalloc+0x160>)
  40069c:	4798      	blx	r3
  40069e:	2600      	movs	r6, #0
  4006a0:	e7f6      	b.n	400690 <pvPortMalloc+0x10c>
  4006a2:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  4006a6:	f383 8811 	msr	BASEPRI, r3
  4006aa:	f3bf 8f6f 	isb	sy
  4006ae:	f3bf 8f4f 	dsb	sy
  4006b2:	e7fe      	b.n	4006b2 <pvPortMalloc+0x12e>
	( void ) xTaskResumeAll();
  4006b4:	4b0a      	ldr	r3, [pc, #40]	; (4006e0 <pvPortMalloc+0x15c>)
  4006b6:	4798      	blx	r3
  4006b8:	e7ef      	b.n	40069a <pvPortMalloc+0x116>
  4006ba:	bf00      	nop
  4006bc:	004019f5 	.word	0x004019f5
  4006c0:	2000045c 	.word	0x2000045c
  4006c4:	2000a460 	.word	0x2000a460
  4006c8:	2000a464 	.word	0x2000a464
  4006cc:	2000a46c 	.word	0x2000a46c
  4006d0:	20000460 	.word	0x20000460
  4006d4:	2000a468 	.word	0x2000a468
  4006d8:	00400531 	.word	0x00400531
  4006dc:	00403539 	.word	0x00403539
  4006e0:	00401b8d 	.word	0x00401b8d
  4006e4:	00403d05 	.word	0x00403d05

004006e8 <vPortFree>:
	if( pv != NULL )
  4006e8:	2800      	cmp	r0, #0
  4006ea:	d034      	beq.n	400756 <vPortFree+0x6e>
{
  4006ec:	b510      	push	{r4, lr}
  4006ee:	4604      	mov	r4, r0
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
  4006f0:	f850 3c04 	ldr.w	r3, [r0, #-4]
  4006f4:	4a18      	ldr	r2, [pc, #96]	; (400758 <vPortFree+0x70>)
  4006f6:	6812      	ldr	r2, [r2, #0]
  4006f8:	4213      	tst	r3, r2
  4006fa:	d108      	bne.n	40070e <vPortFree+0x26>
  4006fc:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  400700:	f383 8811 	msr	BASEPRI, r3
  400704:	f3bf 8f6f 	isb	sy
  400708:	f3bf 8f4f 	dsb	sy
  40070c:	e7fe      	b.n	40070c <vPortFree+0x24>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
  40070e:	f850 1c08 	ldr.w	r1, [r0, #-8]
  400712:	b141      	cbz	r1, 400726 <vPortFree+0x3e>
  400714:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  400718:	f383 8811 	msr	BASEPRI, r3
  40071c:	f3bf 8f6f 	isb	sy
  400720:	f3bf 8f4f 	dsb	sy
  400724:	e7fe      	b.n	400724 <vPortFree+0x3c>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
  400726:	ea23 0302 	bic.w	r3, r3, r2
  40072a:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
  40072e:	4b0b      	ldr	r3, [pc, #44]	; (40075c <vPortFree+0x74>)
  400730:	4798      	blx	r3
					xFreeBytesRemaining += pxLink->xBlockSize;
  400732:	f854 2c04 	ldr.w	r2, [r4, #-4]
  400736:	490a      	ldr	r1, [pc, #40]	; (400760 <vPortFree+0x78>)
  400738:	680b      	ldr	r3, [r1, #0]
  40073a:	4413      	add	r3, r2
  40073c:	600b      	str	r3, [r1, #0]
					traceFREE( pv, pxLink->xBlockSize );
  40073e:	4252      	negs	r2, r2
  400740:	4621      	mov	r1, r4
  400742:	2096      	movs	r0, #150	; 0x96
  400744:	4b07      	ldr	r3, [pc, #28]	; (400764 <vPortFree+0x7c>)
  400746:	4798      	blx	r3
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
  400748:	f1a4 0008 	sub.w	r0, r4, #8
  40074c:	4b06      	ldr	r3, [pc, #24]	; (400768 <vPortFree+0x80>)
  40074e:	4798      	blx	r3
				( void ) xTaskResumeAll();
  400750:	4b06      	ldr	r3, [pc, #24]	; (40076c <vPortFree+0x84>)
  400752:	4798      	blx	r3
  400754:	bd10      	pop	{r4, pc}
  400756:	4770      	bx	lr
  400758:	2000a460 	.word	0x2000a460
  40075c:	004019f5 	.word	0x004019f5
  400760:	2000a464 	.word	0x2000a464
  400764:	00403539 	.word	0x00403539
  400768:	00400531 	.word	0x00400531
  40076c:	00401b8d 	.word	0x00401b8d

00400770 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  400770:	f100 0308 	add.w	r3, r0, #8
  400774:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  400776:	f04f 32ff 	mov.w	r2, #4294967295
  40077a:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  40077c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  40077e:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  400780:	2300      	movs	r3, #0
  400782:	6003      	str	r3, [r0, #0]
  400784:	4770      	bx	lr

00400786 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  400786:	2300      	movs	r3, #0
  400788:	6103      	str	r3, [r0, #16]
  40078a:	4770      	bx	lr

0040078c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
  40078c:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
  40078e:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  400790:	689a      	ldr	r2, [r3, #8]
  400792:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
  400794:	689a      	ldr	r2, [r3, #8]
  400796:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
  400798:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  40079a:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  40079c:	6803      	ldr	r3, [r0, #0]
  40079e:	3301      	adds	r3, #1
  4007a0:	6003      	str	r3, [r0, #0]
  4007a2:	4770      	bx	lr

004007a4 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  4007a4:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
  4007a6:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  4007a8:	f1b5 3fff 	cmp.w	r5, #4294967295
  4007ac:	d002      	beq.n	4007b4 <vListInsert+0x10>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  4007ae:	f100 0208 	add.w	r2, r0, #8
  4007b2:	e002      	b.n	4007ba <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
  4007b4:	6902      	ldr	r2, [r0, #16]
  4007b6:	e004      	b.n	4007c2 <vListInsert+0x1e>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  4007b8:	461a      	mov	r2, r3
  4007ba:	6853      	ldr	r3, [r2, #4]
  4007bc:	681c      	ldr	r4, [r3, #0]
  4007be:	42a5      	cmp	r5, r4
  4007c0:	d2fa      	bcs.n	4007b8 <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  4007c2:	6853      	ldr	r3, [r2, #4]
  4007c4:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  4007c6:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
  4007c8:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
  4007ca:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  4007cc:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  4007ce:	6803      	ldr	r3, [r0, #0]
  4007d0:	3301      	adds	r3, #1
  4007d2:	6003      	str	r3, [r0, #0]
}
  4007d4:	bc30      	pop	{r4, r5}
  4007d6:	4770      	bx	lr

004007d8 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
  4007d8:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  4007da:	6842      	ldr	r2, [r0, #4]
  4007dc:	6881      	ldr	r1, [r0, #8]
  4007de:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  4007e0:	6882      	ldr	r2, [r0, #8]
  4007e2:	6841      	ldr	r1, [r0, #4]
  4007e4:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  4007e6:	685a      	ldr	r2, [r3, #4]
  4007e8:	4290      	cmp	r0, r2
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  4007ea:	bf04      	itt	eq
  4007ec:	6882      	ldreq	r2, [r0, #8]
  4007ee:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
  4007f0:	2200      	movs	r2, #0
  4007f2:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
  4007f4:	6818      	ldr	r0, [r3, #0]
  4007f6:	3801      	subs	r0, #1
  4007f8:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
  4007fa:	4770      	bx	lr

004007fc <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
  4007fc:	4b0b      	ldr	r3, [pc, #44]	; (40082c <prvTaskExitError+0x30>)
  4007fe:	681b      	ldr	r3, [r3, #0]
  400800:	f1b3 3fff 	cmp.w	r3, #4294967295
  400804:	d008      	beq.n	400818 <prvTaskExitError+0x1c>
  400806:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  40080a:	f383 8811 	msr	BASEPRI, r3
  40080e:	f3bf 8f6f 	isb	sy
  400812:	f3bf 8f4f 	dsb	sy
  400816:	e7fe      	b.n	400816 <prvTaskExitError+0x1a>
  400818:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  40081c:	f383 8811 	msr	BASEPRI, r3
  400820:	f3bf 8f6f 	isb	sy
  400824:	f3bf 8f4f 	dsb	sy
  400828:	e7fe      	b.n	400828 <prvTaskExitError+0x2c>
  40082a:	bf00      	nop
  40082c:	20000004 	.word	0x20000004

00400830 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
  400830:	4806      	ldr	r0, [pc, #24]	; (40084c <prvPortStartFirstTask+0x1c>)
  400832:	6800      	ldr	r0, [r0, #0]
  400834:	6800      	ldr	r0, [r0, #0]
  400836:	f380 8808 	msr	MSP, r0
  40083a:	b662      	cpsie	i
  40083c:	b661      	cpsie	f
  40083e:	f3bf 8f4f 	dsb	sy
  400842:	f3bf 8f6f 	isb	sy
  400846:	df00      	svc	0
  400848:	bf00      	nop
  40084a:	0000      	.short	0x0000
  40084c:	e000ed08 	.word	0xe000ed08

00400850 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
  400850:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
  400854:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
  400858:	f021 0101 	bic.w	r1, r1, #1
  40085c:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
  400860:	4b03      	ldr	r3, [pc, #12]	; (400870 <pxPortInitialiseStack+0x20>)
  400862:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
  400866:	f840 2c20 	str.w	r2, [r0, #-32]
}
  40086a:	3840      	subs	r0, #64	; 0x40
  40086c:	4770      	bx	lr
  40086e:	bf00      	nop
  400870:	004007fd 	.word	0x004007fd
	...

00400880 <SVC_Handler>:
	__asm volatile (
  400880:	4b07      	ldr	r3, [pc, #28]	; (4008a0 <pxCurrentTCBConst2>)
  400882:	6819      	ldr	r1, [r3, #0]
  400884:	6808      	ldr	r0, [r1, #0]
  400886:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  40088a:	f380 8809 	msr	PSP, r0
  40088e:	f3bf 8f6f 	isb	sy
  400892:	f04f 0000 	mov.w	r0, #0
  400896:	f380 8811 	msr	BASEPRI, r0
  40089a:	f04e 0e0d 	orr.w	lr, lr, #13
  40089e:	4770      	bx	lr

004008a0 <pxCurrentTCBConst2>:
  4008a0:	2000a47c 	.word	0x2000a47c

004008a4 <vPortEnterCritical>:
  4008a4:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  4008a8:	f383 8811 	msr	BASEPRI, r3
  4008ac:	f3bf 8f6f 	isb	sy
  4008b0:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
  4008b4:	4a0a      	ldr	r2, [pc, #40]	; (4008e0 <vPortEnterCritical+0x3c>)
  4008b6:	6813      	ldr	r3, [r2, #0]
  4008b8:	3301      	adds	r3, #1
  4008ba:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
  4008bc:	2b01      	cmp	r3, #1
  4008be:	d10d      	bne.n	4008dc <vPortEnterCritical+0x38>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
  4008c0:	4b08      	ldr	r3, [pc, #32]	; (4008e4 <vPortEnterCritical+0x40>)
  4008c2:	681b      	ldr	r3, [r3, #0]
  4008c4:	f013 0fff 	tst.w	r3, #255	; 0xff
  4008c8:	d008      	beq.n	4008dc <vPortEnterCritical+0x38>
  4008ca:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  4008ce:	f383 8811 	msr	BASEPRI, r3
  4008d2:	f3bf 8f6f 	isb	sy
  4008d6:	f3bf 8f4f 	dsb	sy
  4008da:	e7fe      	b.n	4008da <vPortEnterCritical+0x36>
  4008dc:	4770      	bx	lr
  4008de:	bf00      	nop
  4008e0:	20000004 	.word	0x20000004
  4008e4:	e000ed04 	.word	0xe000ed04

004008e8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
  4008e8:	4b09      	ldr	r3, [pc, #36]	; (400910 <vPortExitCritical+0x28>)
  4008ea:	681b      	ldr	r3, [r3, #0]
  4008ec:	b943      	cbnz	r3, 400900 <vPortExitCritical+0x18>
  4008ee:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  4008f2:	f383 8811 	msr	BASEPRI, r3
  4008f6:	f3bf 8f6f 	isb	sy
  4008fa:	f3bf 8f4f 	dsb	sy
  4008fe:	e7fe      	b.n	4008fe <vPortExitCritical+0x16>
	uxCriticalNesting--;
  400900:	3b01      	subs	r3, #1
  400902:	4a03      	ldr	r2, [pc, #12]	; (400910 <vPortExitCritical+0x28>)
  400904:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
  400906:	b90b      	cbnz	r3, 40090c <vPortExitCritical+0x24>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  400908:	f383 8811 	msr	BASEPRI, r3
  40090c:	4770      	bx	lr
  40090e:	bf00      	nop
  400910:	20000004 	.word	0x20000004
	...

00400920 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
  400920:	f3ef 8009 	mrs	r0, PSP
  400924:	f3bf 8f6f 	isb	sy
  400928:	4b0d      	ldr	r3, [pc, #52]	; (400960 <pxCurrentTCBConst>)
  40092a:	681a      	ldr	r2, [r3, #0]
  40092c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  400930:	6010      	str	r0, [r2, #0]
  400932:	e92d 4008 	stmdb	sp!, {r3, lr}
  400936:	f04f 00a0 	mov.w	r0, #160	; 0xa0
  40093a:	f380 8811 	msr	BASEPRI, r0
  40093e:	f001 fa4b 	bl	401dd8 <vTaskSwitchContext>
  400942:	f04f 0000 	mov.w	r0, #0
  400946:	f380 8811 	msr	BASEPRI, r0
  40094a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  40094e:	6819      	ldr	r1, [r3, #0]
  400950:	6808      	ldr	r0, [r1, #0]
  400952:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  400956:	f380 8809 	msr	PSP, r0
  40095a:	f3bf 8f6f 	isb	sy
  40095e:	4770      	bx	lr

00400960 <pxCurrentTCBConst>:
  400960:	2000a47c 	.word	0x2000a47c

00400964 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
  400964:	b508      	push	{r3, lr}
	__asm volatile
  400966:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  40096a:	f383 8811 	msr	BASEPRI, r3
  40096e:	f3bf 8f6f 	isb	sy
  400972:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
  400976:	4b05      	ldr	r3, [pc, #20]	; (40098c <SysTick_Handler+0x28>)
  400978:	4798      	blx	r3
  40097a:	b118      	cbz	r0, 400984 <SysTick_Handler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  40097c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400980:	4b03      	ldr	r3, [pc, #12]	; (400990 <SysTick_Handler+0x2c>)
  400982:	601a      	str	r2, [r3, #0]
	__asm volatile
  400984:	2300      	movs	r3, #0
  400986:	f383 8811 	msr	BASEPRI, r3
  40098a:	bd08      	pop	{r3, pc}
  40098c:	00401a11 	.word	0x00401a11
  400990:	e000ed04 	.word	0xe000ed04

00400994 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
  400994:	4b06      	ldr	r3, [pc, #24]	; (4009b0 <vPortSetupTimerInterrupt+0x1c>)
  400996:	681b      	ldr	r3, [r3, #0]
  400998:	4a06      	ldr	r2, [pc, #24]	; (4009b4 <vPortSetupTimerInterrupt+0x20>)
  40099a:	fba2 2303 	umull	r2, r3, r2, r3
  40099e:	099b      	lsrs	r3, r3, #6
  4009a0:	3b01      	subs	r3, #1
  4009a2:	4a05      	ldr	r2, [pc, #20]	; (4009b8 <vPortSetupTimerInterrupt+0x24>)
  4009a4:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
  4009a6:	2207      	movs	r2, #7
  4009a8:	4b04      	ldr	r3, [pc, #16]	; (4009bc <vPortSetupTimerInterrupt+0x28>)
  4009aa:	601a      	str	r2, [r3, #0]
  4009ac:	4770      	bx	lr
  4009ae:	bf00      	nop
  4009b0:	20000000 	.word	0x20000000
  4009b4:	10624dd3 	.word	0x10624dd3
  4009b8:	e000e014 	.word	0xe000e014
  4009bc:	e000e010 	.word	0xe000e010

004009c0 <xPortStartScheduler>:
{
  4009c0:	b500      	push	{lr}
  4009c2:	b083      	sub	sp, #12
		ulOriginalPriority = *pucFirstUserPriorityRegister;
  4009c4:	4b22      	ldr	r3, [pc, #136]	; (400a50 <xPortStartScheduler+0x90>)
  4009c6:	781a      	ldrb	r2, [r3, #0]
  4009c8:	b2d2      	uxtb	r2, r2
  4009ca:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  4009cc:	22ff      	movs	r2, #255	; 0xff
  4009ce:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
  4009d0:	781b      	ldrb	r3, [r3, #0]
  4009d2:	b2db      	uxtb	r3, r3
  4009d4:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
  4009d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
  4009dc:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
  4009e0:	4a1c      	ldr	r2, [pc, #112]	; (400a54 <xPortStartScheduler+0x94>)
  4009e2:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
  4009e4:	2207      	movs	r2, #7
  4009e6:	4b1c      	ldr	r3, [pc, #112]	; (400a58 <xPortStartScheduler+0x98>)
  4009e8:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  4009ea:	f89d 3003 	ldrb.w	r3, [sp, #3]
  4009ee:	f013 0f80 	tst.w	r3, #128	; 0x80
  4009f2:	d010      	beq.n	400a16 <xPortStartScheduler+0x56>
  4009f4:	2206      	movs	r2, #6
  4009f6:	e000      	b.n	4009fa <xPortStartScheduler+0x3a>
  4009f8:	460a      	mov	r2, r1
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
  4009fa:	f89d 3003 	ldrb.w	r3, [sp, #3]
  4009fe:	005b      	lsls	r3, r3, #1
  400a00:	b2db      	uxtb	r3, r3
  400a02:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  400a06:	f89d 3003 	ldrb.w	r3, [sp, #3]
  400a0a:	1e51      	subs	r1, r2, #1
  400a0c:	f013 0f80 	tst.w	r3, #128	; 0x80
  400a10:	d1f2      	bne.n	4009f8 <xPortStartScheduler+0x38>
  400a12:	4b11      	ldr	r3, [pc, #68]	; (400a58 <xPortStartScheduler+0x98>)
  400a14:	601a      	str	r2, [r3, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
  400a16:	4a10      	ldr	r2, [pc, #64]	; (400a58 <xPortStartScheduler+0x98>)
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
  400a18:	6813      	ldr	r3, [r2, #0]
  400a1a:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
  400a1c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  400a20:	6013      	str	r3, [r2, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
  400a22:	9b01      	ldr	r3, [sp, #4]
  400a24:	b2db      	uxtb	r3, r3
  400a26:	4a0a      	ldr	r2, [pc, #40]	; (400a50 <xPortStartScheduler+0x90>)
  400a28:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  400a2a:	4b0c      	ldr	r3, [pc, #48]	; (400a5c <xPortStartScheduler+0x9c>)
  400a2c:	681a      	ldr	r2, [r3, #0]
  400a2e:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
  400a32:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  400a34:	681a      	ldr	r2, [r3, #0]
  400a36:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
  400a3a:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
  400a3c:	4b08      	ldr	r3, [pc, #32]	; (400a60 <xPortStartScheduler+0xa0>)
  400a3e:	4798      	blx	r3
	uxCriticalNesting = 0;
  400a40:	2200      	movs	r2, #0
  400a42:	4b08      	ldr	r3, [pc, #32]	; (400a64 <xPortStartScheduler+0xa4>)
  400a44:	601a      	str	r2, [r3, #0]
	prvPortStartFirstTask();
  400a46:	4b08      	ldr	r3, [pc, #32]	; (400a68 <xPortStartScheduler+0xa8>)
  400a48:	4798      	blx	r3
	prvTaskExitError();
  400a4a:	4b08      	ldr	r3, [pc, #32]	; (400a6c <xPortStartScheduler+0xac>)
  400a4c:	4798      	blx	r3
  400a4e:	bf00      	nop
  400a50:	e000e400 	.word	0xe000e400
  400a54:	2000a474 	.word	0x2000a474
  400a58:	2000a478 	.word	0x2000a478
  400a5c:	e000ed20 	.word	0xe000ed20
  400a60:	00400995 	.word	0x00400995
  400a64:	20000004 	.word	0x20000004
  400a68:	00400831 	.word	0x00400831
  400a6c:	004007fd 	.word	0x004007fd

00400a70 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
  400a70:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
  400a74:	2b0f      	cmp	r3, #15
  400a76:	d90f      	bls.n	400a98 <vPortValidateInterruptPriority+0x28>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
  400a78:	4a10      	ldr	r2, [pc, #64]	; (400abc <vPortValidateInterruptPriority+0x4c>)
  400a7a:	5c9b      	ldrb	r3, [r3, r2]
  400a7c:	b2db      	uxtb	r3, r3
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
  400a7e:	4a10      	ldr	r2, [pc, #64]	; (400ac0 <vPortValidateInterruptPriority+0x50>)
  400a80:	7812      	ldrb	r2, [r2, #0]
  400a82:	429a      	cmp	r2, r3
  400a84:	d908      	bls.n	400a98 <vPortValidateInterruptPriority+0x28>
	__asm volatile
  400a86:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  400a8a:	f383 8811 	msr	BASEPRI, r3
  400a8e:	f3bf 8f6f 	isb	sy
  400a92:	f3bf 8f4f 	dsb	sy
  400a96:	e7fe      	b.n	400a96 <vPortValidateInterruptPriority+0x26>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
  400a98:	4b0a      	ldr	r3, [pc, #40]	; (400ac4 <vPortValidateInterruptPriority+0x54>)
  400a9a:	681b      	ldr	r3, [r3, #0]
  400a9c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  400aa0:	4a09      	ldr	r2, [pc, #36]	; (400ac8 <vPortValidateInterruptPriority+0x58>)
  400aa2:	6812      	ldr	r2, [r2, #0]
  400aa4:	4293      	cmp	r3, r2
  400aa6:	d908      	bls.n	400aba <vPortValidateInterruptPriority+0x4a>
  400aa8:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  400aac:	f383 8811 	msr	BASEPRI, r3
  400ab0:	f3bf 8f6f 	isb	sy
  400ab4:	f3bf 8f4f 	dsb	sy
  400ab8:	e7fe      	b.n	400ab8 <vPortValidateInterruptPriority+0x48>
  400aba:	4770      	bx	lr
  400abc:	e000e3f0 	.word	0xe000e3f0
  400ac0:	2000a474 	.word	0x2000a474
  400ac4:	e000ed0c 	.word	0xe000ed0c
  400ac8:	2000a478 	.word	0x2000a478

00400acc <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
  400acc:	b570      	push	{r4, r5, r6, lr}
  400ace:	4604      	mov	r4, r0
  400ad0:	4616      	mov	r6, r2
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  400ad2:	6b85      	ldr	r5, [r0, #56]	; 0x38

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
  400ad4:	6c02      	ldr	r2, [r0, #64]	; 0x40
  400ad6:	b952      	cbnz	r2, 400aee <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  400ad8:	6803      	ldr	r3, [r0, #0]
  400ada:	2b00      	cmp	r3, #0
  400adc:	d12a      	bne.n	400b34 <prvCopyDataToQueue+0x68>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  400ade:	6840      	ldr	r0, [r0, #4]
  400ae0:	4b18      	ldr	r3, [pc, #96]	; (400b44 <prvCopyDataToQueue+0x78>)
  400ae2:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  400ae4:	2300      	movs	r3, #0
  400ae6:	6063      	str	r3, [r4, #4]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
  400ae8:	3501      	adds	r5, #1
  400aea:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
  400aec:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
  400aee:	b96e      	cbnz	r6, 400b0c <prvCopyDataToQueue+0x40>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
  400af0:	6880      	ldr	r0, [r0, #8]
  400af2:	4b15      	ldr	r3, [pc, #84]	; (400b48 <prvCopyDataToQueue+0x7c>)
  400af4:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  400af6:	68a3      	ldr	r3, [r4, #8]
  400af8:	6c22      	ldr	r2, [r4, #64]	; 0x40
  400afa:	4413      	add	r3, r2
  400afc:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  400afe:	6862      	ldr	r2, [r4, #4]
  400b00:	4293      	cmp	r3, r2
  400b02:	d319      	bcc.n	400b38 <prvCopyDataToQueue+0x6c>
			pxQueue->pcWriteTo = pxQueue->pcHead;
  400b04:	6823      	ldr	r3, [r4, #0]
  400b06:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
  400b08:	2000      	movs	r0, #0
  400b0a:	e7ed      	b.n	400ae8 <prvCopyDataToQueue+0x1c>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  400b0c:	68c0      	ldr	r0, [r0, #12]
  400b0e:	4b0e      	ldr	r3, [pc, #56]	; (400b48 <prvCopyDataToQueue+0x7c>)
  400b10:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
  400b12:	6c23      	ldr	r3, [r4, #64]	; 0x40
  400b14:	425b      	negs	r3, r3
  400b16:	68e2      	ldr	r2, [r4, #12]
  400b18:	441a      	add	r2, r3
  400b1a:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  400b1c:	6821      	ldr	r1, [r4, #0]
  400b1e:	428a      	cmp	r2, r1
  400b20:	d202      	bcs.n	400b28 <prvCopyDataToQueue+0x5c>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  400b22:	6862      	ldr	r2, [r4, #4]
  400b24:	4413      	add	r3, r2
  400b26:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
  400b28:	2e02      	cmp	r6, #2
  400b2a:	d107      	bne.n	400b3c <prvCopyDataToQueue+0x70>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  400b2c:	b145      	cbz	r5, 400b40 <prvCopyDataToQueue+0x74>
				--uxMessagesWaiting;
  400b2e:	3d01      	subs	r5, #1
BaseType_t xReturn = pdFALSE;
  400b30:	2000      	movs	r0, #0
  400b32:	e7d9      	b.n	400ae8 <prvCopyDataToQueue+0x1c>
  400b34:	2000      	movs	r0, #0
  400b36:	e7d7      	b.n	400ae8 <prvCopyDataToQueue+0x1c>
  400b38:	2000      	movs	r0, #0
  400b3a:	e7d5      	b.n	400ae8 <prvCopyDataToQueue+0x1c>
  400b3c:	2000      	movs	r0, #0
  400b3e:	e7d3      	b.n	400ae8 <prvCopyDataToQueue+0x1c>
  400b40:	2000      	movs	r0, #0
  400b42:	e7d1      	b.n	400ae8 <prvCopyDataToQueue+0x1c>
  400b44:	00402205 	.word	0x00402205
  400b48:	00403d7d 	.word	0x00403d7d

00400b4c <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
  400b4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  400b50:	b083      	sub	sp, #12
  400b52:	9001      	str	r0, [sp, #4]
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
  400b54:	6c84      	ldr	r4, [r0, #72]	; 0x48
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
  400b56:	b164      	cbz	r4, 400b72 <prvNotifyQueueSetContainer+0x26>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
  400b58:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  400b5a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  400b5c:	429a      	cmp	r2, r3
  400b5e:	d311      	bcc.n	400b84 <prvNotifyQueueSetContainer+0x38>
  400b60:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  400b64:	f383 8811 	msr	BASEPRI, r3
  400b68:	f3bf 8f6f 	isb	sy
  400b6c:	f3bf 8f4f 	dsb	sy
  400b70:	e7fe      	b.n	400b70 <prvNotifyQueueSetContainer+0x24>
  400b72:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  400b76:	f383 8811 	msr	BASEPRI, r3
  400b7a:	f3bf 8f6f 	isb	sy
  400b7e:	f3bf 8f4f 	dsb	sy
  400b82:	e7fe      	b.n	400b82 <prvNotifyQueueSetContainer+0x36>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
  400b84:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  400b86:	4293      	cmp	r3, r2
  400b88:	d804      	bhi.n	400b94 <prvNotifyQueueSetContainer+0x48>
	BaseType_t xReturn = pdFALSE;
  400b8a:	2600      	movs	r6, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
  400b8c:	4630      	mov	r0, r6
  400b8e:	b003      	add	sp, #12
  400b90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  400b94:	468a      	mov	sl, r1
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
  400b96:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
  400b9a:	b26d      	sxtb	r5, r5
			traceQUEUE_SEND( pxQueueSetContainer );
  400b9c:	4620      	mov	r0, r4
  400b9e:	4f21      	ldr	r7, [pc, #132]	; (400c24 <prvNotifyQueueSetContainer+0xd8>)
  400ba0:	47b8      	blx	r7
  400ba2:	f8df 9094 	ldr.w	r9, [pc, #148]	; 400c38 <prvNotifyQueueSetContainer+0xec>
  400ba6:	f819 6000 	ldrb.w	r6, [r9, r0]
  400baa:	3620      	adds	r6, #32
  400bac:	b2f6      	uxtb	r6, r6
  400bae:	4620      	mov	r0, r4
  400bb0:	47b8      	blx	r7
  400bb2:	f819 b000 	ldrb.w	fp, [r9, r0]
  400bb6:	4620      	mov	r0, r4
  400bb8:	f8df 8080 	ldr.w	r8, [pc, #128]	; 400c3c <prvNotifyQueueSetContainer+0xf0>
  400bbc:	47c0      	blx	r8
  400bbe:	4602      	mov	r2, r0
  400bc0:	4659      	mov	r1, fp
  400bc2:	4630      	mov	r0, r6
  400bc4:	4b18      	ldr	r3, [pc, #96]	; (400c28 <prvNotifyQueueSetContainer+0xdc>)
  400bc6:	4798      	blx	r3
  400bc8:	4620      	mov	r0, r4
  400bca:	47b8      	blx	r7
  400bcc:	f819 6000 	ldrb.w	r6, [r9, r0]
  400bd0:	4620      	mov	r0, r4
  400bd2:	47c0      	blx	r8
  400bd4:	4680      	mov	r8, r0
  400bd6:	4620      	mov	r0, r4
  400bd8:	47b8      	blx	r7
  400bda:	f819 3000 	ldrb.w	r3, [r9, r0]
  400bde:	2b02      	cmp	r3, #2
  400be0:	bf1d      	ittte	ne
  400be2:	6ba2      	ldrne	r2, [r4, #56]	; 0x38
  400be4:	3201      	addne	r2, #1
  400be6:	b2d2      	uxtbne	r2, r2
  400be8:	2200      	moveq	r2, #0
  400bea:	4641      	mov	r1, r8
  400bec:	4630      	mov	r0, r6
  400bee:	4b0f      	ldr	r3, [pc, #60]	; (400c2c <prvNotifyQueueSetContainer+0xe0>)
  400bf0:	4798      	blx	r3
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
  400bf2:	4652      	mov	r2, sl
  400bf4:	a901      	add	r1, sp, #4
  400bf6:	4620      	mov	r0, r4
  400bf8:	4b0d      	ldr	r3, [pc, #52]	; (400c30 <prvNotifyQueueSetContainer+0xe4>)
  400bfa:	4798      	blx	r3
  400bfc:	4606      	mov	r6, r0
			if( cTxLock == queueUNLOCKED )
  400bfe:	f1b5 3fff 	cmp.w	r5, #4294967295
  400c02:	d10a      	bne.n	400c1a <prvNotifyQueueSetContainer+0xce>
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
  400c04:	6a63      	ldr	r3, [r4, #36]	; 0x24
  400c06:	2b00      	cmp	r3, #0
  400c08:	d0c0      	beq.n	400b8c <prvNotifyQueueSetContainer+0x40>
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
  400c0a:	f104 0024 	add.w	r0, r4, #36	; 0x24
  400c0e:	4b09      	ldr	r3, [pc, #36]	; (400c34 <prvNotifyQueueSetContainer+0xe8>)
  400c10:	4798      	blx	r3
  400c12:	2800      	cmp	r0, #0
						xReturn = pdTRUE;
  400c14:	bf18      	it	ne
  400c16:	2601      	movne	r6, #1
  400c18:	e7b8      	b.n	400b8c <prvNotifyQueueSetContainer+0x40>
				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
  400c1a:	1c6b      	adds	r3, r5, #1
  400c1c:	b25b      	sxtb	r3, r3
  400c1e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  400c22:	e7b3      	b.n	400b8c <prvNotifyQueueSetContainer+0x40>
  400c24:	00402819 	.word	0x00402819
  400c28:	00403615 	.word	0x00403615
  400c2c:	00402fed 	.word	0x00402fed
  400c30:	00400acd 	.word	0x00400acd
  400c34:	00401f69 	.word	0x00401f69
  400c38:	20000008 	.word	0x20000008
  400c3c:	00402809 	.word	0x00402809

00400c40 <prvCopyDataFromQueue>:
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
  400c40:	6c02      	ldr	r2, [r0, #64]	; 0x40
  400c42:	b172      	cbz	r2, 400c62 <prvCopyDataFromQueue+0x22>
{
  400c44:	b510      	push	{r4, lr}
  400c46:	4603      	mov	r3, r0
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
  400c48:	68c4      	ldr	r4, [r0, #12]
  400c4a:	4414      	add	r4, r2
  400c4c:	60c4      	str	r4, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  400c4e:	6840      	ldr	r0, [r0, #4]
  400c50:	4284      	cmp	r4, r0
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
  400c52:	bf24      	itt	cs
  400c54:	6818      	ldrcs	r0, [r3, #0]
  400c56:	60d8      	strcs	r0, [r3, #12]
  400c58:	4608      	mov	r0, r1
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
  400c5a:	68d9      	ldr	r1, [r3, #12]
  400c5c:	4b01      	ldr	r3, [pc, #4]	; (400c64 <prvCopyDataFromQueue+0x24>)
  400c5e:	4798      	blx	r3
  400c60:	bd10      	pop	{r4, pc}
  400c62:	4770      	bx	lr
  400c64:	00403d7d 	.word	0x00403d7d

00400c68 <prvUnlockQueue>:
{
  400c68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400c6c:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
  400c6e:	4b23      	ldr	r3, [pc, #140]	; (400cfc <prvUnlockQueue+0x94>)
  400c70:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
  400c72:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
  400c76:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
  400c78:	2c00      	cmp	r4, #0
  400c7a:	dd19      	ble.n	400cb0 <prvUnlockQueue+0x48>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
  400c7c:	4e20      	ldr	r6, [pc, #128]	; (400d00 <prvUnlockQueue+0x98>)
						vTaskMissedYield();
  400c7e:	f8df 808c 	ldr.w	r8, [pc, #140]	; 400d0c <prvUnlockQueue+0xa4>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  400c82:	4f20      	ldr	r7, [pc, #128]	; (400d04 <prvUnlockQueue+0x9c>)
  400c84:	e008      	b.n	400c98 <prvUnlockQueue+0x30>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  400c86:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  400c88:	b193      	cbz	r3, 400cb0 <prvUnlockQueue+0x48>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  400c8a:	f105 0024 	add.w	r0, r5, #36	; 0x24
  400c8e:	47b8      	blx	r7
  400c90:	b960      	cbnz	r0, 400cac <prvUnlockQueue+0x44>
  400c92:	3c01      	subs	r4, #1
  400c94:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
  400c96:	b15c      	cbz	r4, 400cb0 <prvUnlockQueue+0x48>
				if( pxQueue->pxQueueSetContainer != NULL )
  400c98:	6cab      	ldr	r3, [r5, #72]	; 0x48
  400c9a:	2b00      	cmp	r3, #0
  400c9c:	d0f3      	beq.n	400c86 <prvUnlockQueue+0x1e>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
  400c9e:	2100      	movs	r1, #0
  400ca0:	4628      	mov	r0, r5
  400ca2:	47b0      	blx	r6
  400ca4:	2800      	cmp	r0, #0
  400ca6:	d0f4      	beq.n	400c92 <prvUnlockQueue+0x2a>
						vTaskMissedYield();
  400ca8:	47c0      	blx	r8
  400caa:	e7f2      	b.n	400c92 <prvUnlockQueue+0x2a>
							vTaskMissedYield();
  400cac:	47c0      	blx	r8
  400cae:	e7f0      	b.n	400c92 <prvUnlockQueue+0x2a>
		pxQueue->cTxLock = queueUNLOCKED;
  400cb0:	23ff      	movs	r3, #255	; 0xff
  400cb2:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
  400cb6:	4b14      	ldr	r3, [pc, #80]	; (400d08 <prvUnlockQueue+0xa0>)
  400cb8:	4798      	blx	r3
	taskENTER_CRITICAL();
  400cba:	4b10      	ldr	r3, [pc, #64]	; (400cfc <prvUnlockQueue+0x94>)
  400cbc:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
  400cbe:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
  400cc2:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
  400cc4:	2c00      	cmp	r4, #0
  400cc6:	dd12      	ble.n	400cee <prvUnlockQueue+0x86>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  400cc8:	692b      	ldr	r3, [r5, #16]
  400cca:	b183      	cbz	r3, 400cee <prvUnlockQueue+0x86>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  400ccc:	f105 0710 	add.w	r7, r5, #16
  400cd0:	4e0c      	ldr	r6, [pc, #48]	; (400d04 <prvUnlockQueue+0x9c>)
					vTaskMissedYield();
  400cd2:	f8df 8038 	ldr.w	r8, [pc, #56]	; 400d0c <prvUnlockQueue+0xa4>
  400cd6:	e004      	b.n	400ce2 <prvUnlockQueue+0x7a>
  400cd8:	3c01      	subs	r4, #1
  400cda:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
  400cdc:	b13c      	cbz	r4, 400cee <prvUnlockQueue+0x86>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  400cde:	692b      	ldr	r3, [r5, #16]
  400ce0:	b12b      	cbz	r3, 400cee <prvUnlockQueue+0x86>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  400ce2:	4638      	mov	r0, r7
  400ce4:	47b0      	blx	r6
  400ce6:	2800      	cmp	r0, #0
  400ce8:	d0f6      	beq.n	400cd8 <prvUnlockQueue+0x70>
					vTaskMissedYield();
  400cea:	47c0      	blx	r8
  400cec:	e7f4      	b.n	400cd8 <prvUnlockQueue+0x70>
		pxQueue->cRxLock = queueUNLOCKED;
  400cee:	23ff      	movs	r3, #255	; 0xff
  400cf0:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	taskEXIT_CRITICAL();
  400cf4:	4b04      	ldr	r3, [pc, #16]	; (400d08 <prvUnlockQueue+0xa0>)
  400cf6:	4798      	blx	r3
  400cf8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  400cfc:	004008a5 	.word	0x004008a5
  400d00:	00400b4d 	.word	0x00400b4d
  400d04:	00401f69 	.word	0x00401f69
  400d08:	004008e9 	.word	0x004008e9
  400d0c:	004020c9 	.word	0x004020c9

00400d10 <xQueueGenericReset>:
{
  400d10:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxQueue );
  400d12:	b330      	cbz	r0, 400d62 <xQueueGenericReset+0x52>
  400d14:	4604      	mov	r4, r0
  400d16:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
  400d18:	4b1c      	ldr	r3, [pc, #112]	; (400d8c <xQueueGenericReset+0x7c>)
  400d1a:	4798      	blx	r3
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  400d1c:	6822      	ldr	r2, [r4, #0]
  400d1e:	6c21      	ldr	r1, [r4, #64]	; 0x40
  400d20:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  400d22:	fb03 f301 	mul.w	r3, r3, r1
  400d26:	18d0      	adds	r0, r2, r3
  400d28:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  400d2a:	2000      	movs	r0, #0
  400d2c:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  400d2e:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
  400d30:	1a5b      	subs	r3, r3, r1
  400d32:	4413      	add	r3, r2
  400d34:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
  400d36:	23ff      	movs	r3, #255	; 0xff
  400d38:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
  400d3c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
  400d40:	b9c5      	cbnz	r5, 400d74 <xQueueGenericReset+0x64>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  400d42:	6923      	ldr	r3, [r4, #16]
  400d44:	b1eb      	cbz	r3, 400d82 <xQueueGenericReset+0x72>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  400d46:	f104 0010 	add.w	r0, r4, #16
  400d4a:	4b11      	ldr	r3, [pc, #68]	; (400d90 <xQueueGenericReset+0x80>)
  400d4c:	4798      	blx	r3
  400d4e:	b1c0      	cbz	r0, 400d82 <xQueueGenericReset+0x72>
					queueYIELD_IF_USING_PREEMPTION();
  400d50:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400d54:	4b0f      	ldr	r3, [pc, #60]	; (400d94 <xQueueGenericReset+0x84>)
  400d56:	601a      	str	r2, [r3, #0]
  400d58:	f3bf 8f4f 	dsb	sy
  400d5c:	f3bf 8f6f 	isb	sy
  400d60:	e00f      	b.n	400d82 <xQueueGenericReset+0x72>
  400d62:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  400d66:	f383 8811 	msr	BASEPRI, r3
  400d6a:	f3bf 8f6f 	isb	sy
  400d6e:	f3bf 8f4f 	dsb	sy
  400d72:	e7fe      	b.n	400d72 <xQueueGenericReset+0x62>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  400d74:	f104 0010 	add.w	r0, r4, #16
  400d78:	4d07      	ldr	r5, [pc, #28]	; (400d98 <xQueueGenericReset+0x88>)
  400d7a:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  400d7c:	f104 0024 	add.w	r0, r4, #36	; 0x24
  400d80:	47a8      	blx	r5
	taskEXIT_CRITICAL();
  400d82:	4b06      	ldr	r3, [pc, #24]	; (400d9c <xQueueGenericReset+0x8c>)
  400d84:	4798      	blx	r3
}
  400d86:	2001      	movs	r0, #1
  400d88:	bd38      	pop	{r3, r4, r5, pc}
  400d8a:	bf00      	nop
  400d8c:	004008a5 	.word	0x004008a5
  400d90:	00401f69 	.word	0x00401f69
  400d94:	e000ed04 	.word	0xe000ed04
  400d98:	00400771 	.word	0x00400771
  400d9c:	004008e9 	.word	0x004008e9

00400da0 <xQueueGenericCreate>:
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  400da0:	b940      	cbnz	r0, 400db4 <xQueueGenericCreate+0x14>
  400da2:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  400da6:	f383 8811 	msr	BASEPRI, r3
  400daa:	f3bf 8f6f 	isb	sy
  400dae:	f3bf 8f4f 	dsb	sy
  400db2:	e7fe      	b.n	400db2 <xQueueGenericCreate+0x12>
	{
  400db4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  400db8:	4606      	mov	r6, r0
  400dba:	4617      	mov	r7, r2
  400dbc:	460d      	mov	r5, r1
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  400dbe:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
  400dc2:	3054      	adds	r0, #84	; 0x54
  400dc4:	4b23      	ldr	r3, [pc, #140]	; (400e54 <xQueueGenericCreate+0xb4>)
  400dc6:	4798      	blx	r3
		if( pxNewQueue != NULL )
  400dc8:	4604      	mov	r4, r0
  400dca:	2800      	cmp	r0, #0
  400dcc:	d03e      	beq.n	400e4c <xQueueGenericCreate+0xac>
	if( uxItemSize == ( UBaseType_t ) 0 )
  400dce:	b11d      	cbz	r5, 400dd8 <xQueueGenericCreate+0x38>
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
  400dd0:	f100 0354 	add.w	r3, r0, #84	; 0x54
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
  400dd4:	6003      	str	r3, [r0, #0]
  400dd6:	e000      	b.n	400dda <xQueueGenericCreate+0x3a>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  400dd8:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
  400dda:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
  400ddc:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  400dde:	2101      	movs	r1, #1
  400de0:	4620      	mov	r0, r4
  400de2:	4b1d      	ldr	r3, [pc, #116]	; (400e58 <xQueueGenericCreate+0xb8>)
  400de4:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
  400de6:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewQueue->pxQueueSetContainer = NULL;
  400dea:	f04f 0900 	mov.w	r9, #0
  400dee:	f8c4 9048 	str.w	r9, [r4, #72]	; 0x48
	traceQUEUE_CREATE( pxNewQueue );
  400df2:	4620      	mov	r0, r4
  400df4:	4e19      	ldr	r6, [pc, #100]	; (400e5c <xQueueGenericCreate+0xbc>)
  400df6:	47b0      	blx	r6
  400df8:	4d19      	ldr	r5, [pc, #100]	; (400e60 <xQueueGenericCreate+0xc0>)
  400dfa:	5c28      	ldrb	r0, [r5, r0]
  400dfc:	4b19      	ldr	r3, [pc, #100]	; (400e64 <xQueueGenericCreate+0xc4>)
  400dfe:	4798      	blx	r3
  400e00:	64e0      	str	r0, [r4, #76]	; 0x4c
  400e02:	4620      	mov	r0, r4
  400e04:	47b0      	blx	r6
  400e06:	5c2f      	ldrb	r7, [r5, r0]
  400e08:	4620      	mov	r0, r4
  400e0a:	f8df 8068 	ldr.w	r8, [pc, #104]	; 400e74 <xQueueGenericCreate+0xd4>
  400e0e:	47c0      	blx	r8
  400e10:	4601      	mov	r1, r0
  400e12:	4638      	mov	r0, r7
  400e14:	4b14      	ldr	r3, [pc, #80]	; (400e68 <xQueueGenericCreate+0xc8>)
  400e16:	4798      	blx	r3
  400e18:	4620      	mov	r0, r4
  400e1a:	47b0      	blx	r6
  400e1c:	5c2f      	ldrb	r7, [r5, r0]
  400e1e:	3718      	adds	r7, #24
  400e20:	b2ff      	uxtb	r7, r7
  400e22:	4620      	mov	r0, r4
  400e24:	47b0      	blx	r6
  400e26:	f815 a000 	ldrb.w	sl, [r5, r0]
  400e2a:	4620      	mov	r0, r4
  400e2c:	47c0      	blx	r8
  400e2e:	4602      	mov	r2, r0
  400e30:	4651      	mov	r1, sl
  400e32:	4638      	mov	r0, r7
  400e34:	4b0d      	ldr	r3, [pc, #52]	; (400e6c <xQueueGenericCreate+0xcc>)
  400e36:	4798      	blx	r3
  400e38:	4620      	mov	r0, r4
  400e3a:	47b0      	blx	r6
  400e3c:	5c2d      	ldrb	r5, [r5, r0]
  400e3e:	4620      	mov	r0, r4
  400e40:	47c0      	blx	r8
  400e42:	464a      	mov	r2, r9
  400e44:	4601      	mov	r1, r0
  400e46:	4628      	mov	r0, r5
  400e48:	4b09      	ldr	r3, [pc, #36]	; (400e70 <xQueueGenericCreate+0xd0>)
  400e4a:	4798      	blx	r3
	}
  400e4c:	4620      	mov	r0, r4
  400e4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  400e52:	bf00      	nop
  400e54:	00400585 	.word	0x00400585
  400e58:	00400d11 	.word	0x00400d11
  400e5c:	00402819 	.word	0x00402819
  400e60:	20000008 	.word	0x20000008
  400e64:	00403085 	.word	0x00403085
  400e68:	00402e05 	.word	0x00402e05
  400e6c:	00403615 	.word	0x00403615
  400e70:	00402fed 	.word	0x00402fed
  400e74:	00402809 	.word	0x00402809

00400e78 <xQueueGenericSend>:
{
  400e78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  400e7c:	b085      	sub	sp, #20
  400e7e:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
  400e80:	b198      	cbz	r0, 400eaa <xQueueGenericSend+0x32>
  400e82:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  400e84:	b1d1      	cbz	r1, 400ebc <xQueueGenericSend+0x44>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  400e86:	2b02      	cmp	r3, #2
  400e88:	d024      	beq.n	400ed4 <xQueueGenericSend+0x5c>
  400e8a:	461d      	mov	r5, r3
  400e8c:	9100      	str	r1, [sp, #0]
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  400e8e:	4b97      	ldr	r3, [pc, #604]	; (4010ec <xQueueGenericSend+0x274>)
  400e90:	4798      	blx	r3
  400e92:	bb58      	cbnz	r0, 400eec <xQueueGenericSend+0x74>
  400e94:	9b01      	ldr	r3, [sp, #4]
  400e96:	b383      	cbz	r3, 400efa <xQueueGenericSend+0x82>
  400e98:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  400e9c:	f383 8811 	msr	BASEPRI, r3
  400ea0:	f3bf 8f6f 	isb	sy
  400ea4:	f3bf 8f4f 	dsb	sy
  400ea8:	e7fe      	b.n	400ea8 <xQueueGenericSend+0x30>
  400eaa:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  400eae:	f383 8811 	msr	BASEPRI, r3
  400eb2:	f3bf 8f6f 	isb	sy
  400eb6:	f3bf 8f4f 	dsb	sy
  400eba:	e7fe      	b.n	400eba <xQueueGenericSend+0x42>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  400ebc:	6c02      	ldr	r2, [r0, #64]	; 0x40
  400ebe:	2a00      	cmp	r2, #0
  400ec0:	d0e1      	beq.n	400e86 <xQueueGenericSend+0xe>
  400ec2:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  400ec6:	f383 8811 	msr	BASEPRI, r3
  400eca:	f3bf 8f6f 	isb	sy
  400ece:	f3bf 8f4f 	dsb	sy
  400ed2:	e7fe      	b.n	400ed2 <xQueueGenericSend+0x5a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  400ed4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
  400ed6:	2a01      	cmp	r2, #1
  400ed8:	d0d7      	beq.n	400e8a <xQueueGenericSend+0x12>
  400eda:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  400ede:	f383 8811 	msr	BASEPRI, r3
  400ee2:	f3bf 8f6f 	isb	sy
  400ee6:	f3bf 8f4f 	dsb	sy
  400eea:	e7fe      	b.n	400eea <xQueueGenericSend+0x72>
  400eec:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
  400eee:	4f80      	ldr	r7, [pc, #512]	; (4010f0 <xQueueGenericSend+0x278>)
					vTaskSetTimeOutState( &xTimeOut );
  400ef0:	f8df b23c 	ldr.w	fp, [pc, #572]	; 401130 <xQueueGenericSend+0x2b8>
					portYIELD_WITHIN_API();
  400ef4:	f8df a210 	ldr.w	sl, [pc, #528]	; 401108 <xQueueGenericSend+0x290>
  400ef8:	e07e      	b.n	400ff8 <xQueueGenericSend+0x180>
  400efa:	2600      	movs	r6, #0
  400efc:	e7f7      	b.n	400eee <xQueueGenericSend+0x76>
				traceQUEUE_SEND( pxQueue );
  400efe:	4620      	mov	r0, r4
  400f00:	f8df 9210 	ldr.w	r9, [pc, #528]	; 401114 <xQueueGenericSend+0x29c>
  400f04:	47c8      	blx	r9
  400f06:	f8df 8210 	ldr.w	r8, [pc, #528]	; 401118 <xQueueGenericSend+0x2a0>
  400f0a:	f818 6000 	ldrb.w	r6, [r8, r0]
  400f0e:	3620      	adds	r6, #32
  400f10:	b2f6      	uxtb	r6, r6
  400f12:	4620      	mov	r0, r4
  400f14:	47c8      	blx	r9
  400f16:	f818 a000 	ldrb.w	sl, [r8, r0]
  400f1a:	4620      	mov	r0, r4
  400f1c:	4f75      	ldr	r7, [pc, #468]	; (4010f4 <xQueueGenericSend+0x27c>)
  400f1e:	47b8      	blx	r7
  400f20:	4602      	mov	r2, r0
  400f22:	4651      	mov	r1, sl
  400f24:	4630      	mov	r0, r6
  400f26:	4b74      	ldr	r3, [pc, #464]	; (4010f8 <xQueueGenericSend+0x280>)
  400f28:	4798      	blx	r3
  400f2a:	4620      	mov	r0, r4
  400f2c:	47c8      	blx	r9
  400f2e:	f818 6000 	ldrb.w	r6, [r8, r0]
  400f32:	4620      	mov	r0, r4
  400f34:	47b8      	blx	r7
  400f36:	4607      	mov	r7, r0
  400f38:	4620      	mov	r0, r4
  400f3a:	47c8      	blx	r9
  400f3c:	f818 3000 	ldrb.w	r3, [r8, r0]
  400f40:	2b02      	cmp	r3, #2
  400f42:	bf1d      	ittte	ne
  400f44:	6ba2      	ldrne	r2, [r4, #56]	; 0x38
  400f46:	3201      	addne	r2, #1
  400f48:	b2d2      	uxtbne	r2, r2
  400f4a:	2200      	moveq	r2, #0
  400f4c:	4639      	mov	r1, r7
  400f4e:	4630      	mov	r0, r6
  400f50:	4b6a      	ldr	r3, [pc, #424]	; (4010fc <xQueueGenericSend+0x284>)
  400f52:	4798      	blx	r3
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  400f54:	462a      	mov	r2, r5
  400f56:	9900      	ldr	r1, [sp, #0]
  400f58:	4620      	mov	r0, r4
  400f5a:	4b69      	ldr	r3, [pc, #420]	; (401100 <xQueueGenericSend+0x288>)
  400f5c:	4798      	blx	r3
					if( pxQueue->pxQueueSetContainer != NULL )
  400f5e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  400f60:	b193      	cbz	r3, 400f88 <xQueueGenericSend+0x110>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
  400f62:	4629      	mov	r1, r5
  400f64:	4620      	mov	r0, r4
  400f66:	4b67      	ldr	r3, [pc, #412]	; (401104 <xQueueGenericSend+0x28c>)
  400f68:	4798      	blx	r3
  400f6a:	b138      	cbz	r0, 400f7c <xQueueGenericSend+0x104>
							queueYIELD_IF_USING_PREEMPTION();
  400f6c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400f70:	4b65      	ldr	r3, [pc, #404]	; (401108 <xQueueGenericSend+0x290>)
  400f72:	601a      	str	r2, [r3, #0]
  400f74:	f3bf 8f4f 	dsb	sy
  400f78:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
  400f7c:	4b63      	ldr	r3, [pc, #396]	; (40110c <xQueueGenericSend+0x294>)
  400f7e:	4798      	blx	r3
				return pdPASS;
  400f80:	2001      	movs	r0, #1
}
  400f82:	b005      	add	sp, #20
  400f84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  400f88:	6a63      	ldr	r3, [r4, #36]	; 0x24
  400f8a:	b173      	cbz	r3, 400faa <xQueueGenericSend+0x132>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  400f8c:	f104 0024 	add.w	r0, r4, #36	; 0x24
  400f90:	4b5f      	ldr	r3, [pc, #380]	; (401110 <xQueueGenericSend+0x298>)
  400f92:	4798      	blx	r3
  400f94:	2800      	cmp	r0, #0
  400f96:	d0f1      	beq.n	400f7c <xQueueGenericSend+0x104>
								queueYIELD_IF_USING_PREEMPTION();
  400f98:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400f9c:	4b5a      	ldr	r3, [pc, #360]	; (401108 <xQueueGenericSend+0x290>)
  400f9e:	601a      	str	r2, [r3, #0]
  400fa0:	f3bf 8f4f 	dsb	sy
  400fa4:	f3bf 8f6f 	isb	sy
  400fa8:	e7e8      	b.n	400f7c <xQueueGenericSend+0x104>
						else if( xYieldRequired != pdFALSE )
  400faa:	2800      	cmp	r0, #0
  400fac:	d0e6      	beq.n	400f7c <xQueueGenericSend+0x104>
							queueYIELD_IF_USING_PREEMPTION();
  400fae:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400fb2:	4b55      	ldr	r3, [pc, #340]	; (401108 <xQueueGenericSend+0x290>)
  400fb4:	601a      	str	r2, [r3, #0]
  400fb6:	f3bf 8f4f 	dsb	sy
  400fba:	f3bf 8f6f 	isb	sy
  400fbe:	e7dd      	b.n	400f7c <xQueueGenericSend+0x104>
					taskEXIT_CRITICAL();
  400fc0:	4b52      	ldr	r3, [pc, #328]	; (40110c <xQueueGenericSend+0x294>)
  400fc2:	4798      	blx	r3
					traceQUEUE_SEND_FAILED( pxQueue );
  400fc4:	4620      	mov	r0, r4
  400fc6:	4f53      	ldr	r7, [pc, #332]	; (401114 <xQueueGenericSend+0x29c>)
  400fc8:	47b8      	blx	r7
  400fca:	4e53      	ldr	r6, [pc, #332]	; (401118 <xQueueGenericSend+0x2a0>)
  400fcc:	5c35      	ldrb	r5, [r6, r0]
  400fce:	3548      	adds	r5, #72	; 0x48
  400fd0:	b2ed      	uxtb	r5, r5
  400fd2:	4620      	mov	r0, r4
  400fd4:	47b8      	blx	r7
  400fd6:	5c36      	ldrb	r6, [r6, r0]
  400fd8:	4620      	mov	r0, r4
  400fda:	4b46      	ldr	r3, [pc, #280]	; (4010f4 <xQueueGenericSend+0x27c>)
  400fdc:	4798      	blx	r3
  400fde:	4602      	mov	r2, r0
  400fe0:	4631      	mov	r1, r6
  400fe2:	4628      	mov	r0, r5
  400fe4:	4b44      	ldr	r3, [pc, #272]	; (4010f8 <xQueueGenericSend+0x280>)
  400fe6:	4798      	blx	r3
					return errQUEUE_FULL;
  400fe8:	2000      	movs	r0, #0
  400fea:	e7ca      	b.n	400f82 <xQueueGenericSend+0x10a>
				prvUnlockQueue( pxQueue );
  400fec:	4620      	mov	r0, r4
  400fee:	4b4b      	ldr	r3, [pc, #300]	; (40111c <xQueueGenericSend+0x2a4>)
  400ff0:	4798      	blx	r3
				( void ) xTaskResumeAll();
  400ff2:	4b4b      	ldr	r3, [pc, #300]	; (401120 <xQueueGenericSend+0x2a8>)
  400ff4:	4798      	blx	r3
  400ff6:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
  400ff8:	47b8      	blx	r7
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  400ffa:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  400ffc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  400ffe:	429a      	cmp	r2, r3
  401000:	f4ff af7d 	bcc.w	400efe <xQueueGenericSend+0x86>
  401004:	2d02      	cmp	r5, #2
  401006:	f43f af7a 	beq.w	400efe <xQueueGenericSend+0x86>
				if( xTicksToWait == ( TickType_t ) 0 )
  40100a:	9b01      	ldr	r3, [sp, #4]
  40100c:	2b00      	cmp	r3, #0
  40100e:	d0d7      	beq.n	400fc0 <xQueueGenericSend+0x148>
				else if( xEntryTimeSet == pdFALSE )
  401010:	b90e      	cbnz	r6, 401016 <xQueueGenericSend+0x19e>
					vTaskSetTimeOutState( &xTimeOut );
  401012:	a802      	add	r0, sp, #8
  401014:	47d8      	blx	fp
		taskEXIT_CRITICAL();
  401016:	4b3d      	ldr	r3, [pc, #244]	; (40110c <xQueueGenericSend+0x294>)
  401018:	4798      	blx	r3
		vTaskSuspendAll();
  40101a:	4b42      	ldr	r3, [pc, #264]	; (401124 <xQueueGenericSend+0x2ac>)
  40101c:	4798      	blx	r3
		prvLockQueue( pxQueue );
  40101e:	47b8      	blx	r7
  401020:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  401024:	b25b      	sxtb	r3, r3
  401026:	f1b3 3fff 	cmp.w	r3, #4294967295
  40102a:	bf04      	itt	eq
  40102c:	2300      	moveq	r3, #0
  40102e:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
  401032:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  401036:	b25b      	sxtb	r3, r3
  401038:	f1b3 3fff 	cmp.w	r3, #4294967295
  40103c:	bf04      	itt	eq
  40103e:	2300      	moveq	r3, #0
  401040:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
  401044:	4b31      	ldr	r3, [pc, #196]	; (40110c <xQueueGenericSend+0x294>)
  401046:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  401048:	a901      	add	r1, sp, #4
  40104a:	a802      	add	r0, sp, #8
  40104c:	4b36      	ldr	r3, [pc, #216]	; (401128 <xQueueGenericSend+0x2b0>)
  40104e:	4798      	blx	r3
  401050:	2800      	cmp	r0, #0
  401052:	d132      	bne.n	4010ba <xQueueGenericSend+0x242>
	taskENTER_CRITICAL();
  401054:	47b8      	blx	r7
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  401056:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
  40105a:	6be6      	ldr	r6, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
  40105c:	4b2b      	ldr	r3, [pc, #172]	; (40110c <xQueueGenericSend+0x294>)
  40105e:	4798      	blx	r3
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  401060:	45b0      	cmp	r8, r6
  401062:	d1c3      	bne.n	400fec <xQueueGenericSend+0x174>
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
  401064:	4620      	mov	r0, r4
  401066:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 401114 <xQueueGenericSend+0x29c>
  40106a:	47c8      	blx	r9
  40106c:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 401118 <xQueueGenericSend+0x2a0>
  401070:	f818 6000 	ldrb.w	r6, [r8, r0]
  401074:	3670      	adds	r6, #112	; 0x70
  401076:	b2f6      	uxtb	r6, r6
  401078:	4620      	mov	r0, r4
  40107a:	47c8      	blx	r9
  40107c:	f818 8000 	ldrb.w	r8, [r8, r0]
  401080:	4620      	mov	r0, r4
  401082:	4b1c      	ldr	r3, [pc, #112]	; (4010f4 <xQueueGenericSend+0x27c>)
  401084:	4798      	blx	r3
  401086:	4602      	mov	r2, r0
  401088:	4641      	mov	r1, r8
  40108a:	4630      	mov	r0, r6
  40108c:	4b1a      	ldr	r3, [pc, #104]	; (4010f8 <xQueueGenericSend+0x280>)
  40108e:	4798      	blx	r3
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  401090:	9901      	ldr	r1, [sp, #4]
  401092:	f104 0010 	add.w	r0, r4, #16
  401096:	4b25      	ldr	r3, [pc, #148]	; (40112c <xQueueGenericSend+0x2b4>)
  401098:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  40109a:	4620      	mov	r0, r4
  40109c:	4b1f      	ldr	r3, [pc, #124]	; (40111c <xQueueGenericSend+0x2a4>)
  40109e:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  4010a0:	4b1f      	ldr	r3, [pc, #124]	; (401120 <xQueueGenericSend+0x2a8>)
  4010a2:	4798      	blx	r3
  4010a4:	2800      	cmp	r0, #0
  4010a6:	d1a6      	bne.n	400ff6 <xQueueGenericSend+0x17e>
					portYIELD_WITHIN_API();
  4010a8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  4010ac:	f8ca 3000 	str.w	r3, [sl]
  4010b0:	f3bf 8f4f 	dsb	sy
  4010b4:	f3bf 8f6f 	isb	sy
  4010b8:	e79d      	b.n	400ff6 <xQueueGenericSend+0x17e>
			prvUnlockQueue( pxQueue );
  4010ba:	4620      	mov	r0, r4
  4010bc:	4b17      	ldr	r3, [pc, #92]	; (40111c <xQueueGenericSend+0x2a4>)
  4010be:	4798      	blx	r3
			( void ) xTaskResumeAll();
  4010c0:	4b17      	ldr	r3, [pc, #92]	; (401120 <xQueueGenericSend+0x2a8>)
  4010c2:	4798      	blx	r3
			traceQUEUE_SEND_FAILED( pxQueue );
  4010c4:	4620      	mov	r0, r4
  4010c6:	4f13      	ldr	r7, [pc, #76]	; (401114 <xQueueGenericSend+0x29c>)
  4010c8:	47b8      	blx	r7
  4010ca:	4e13      	ldr	r6, [pc, #76]	; (401118 <xQueueGenericSend+0x2a0>)
  4010cc:	5c35      	ldrb	r5, [r6, r0]
  4010ce:	3548      	adds	r5, #72	; 0x48
  4010d0:	b2ed      	uxtb	r5, r5
  4010d2:	4620      	mov	r0, r4
  4010d4:	47b8      	blx	r7
  4010d6:	5c36      	ldrb	r6, [r6, r0]
  4010d8:	4620      	mov	r0, r4
  4010da:	4b06      	ldr	r3, [pc, #24]	; (4010f4 <xQueueGenericSend+0x27c>)
  4010dc:	4798      	blx	r3
  4010de:	4602      	mov	r2, r0
  4010e0:	4631      	mov	r1, r6
  4010e2:	4628      	mov	r0, r5
  4010e4:	4b04      	ldr	r3, [pc, #16]	; (4010f8 <xQueueGenericSend+0x280>)
  4010e6:	4798      	blx	r3
			return errQUEUE_FULL;
  4010e8:	2000      	movs	r0, #0
  4010ea:	e74a      	b.n	400f82 <xQueueGenericSend+0x10a>
  4010ec:	004020ed 	.word	0x004020ed
  4010f0:	004008a5 	.word	0x004008a5
  4010f4:	00402809 	.word	0x00402809
  4010f8:	00403615 	.word	0x00403615
  4010fc:	00402fed 	.word	0x00402fed
  401100:	00400acd 	.word	0x00400acd
  401104:	00400b4d 	.word	0x00400b4d
  401108:	e000ed04 	.word	0xe000ed04
  40110c:	004008e9 	.word	0x004008e9
  401110:	00401f69 	.word	0x00401f69
  401114:	00402819 	.word	0x00402819
  401118:	20000008 	.word	0x20000008
  40111c:	00400c69 	.word	0x00400c69
  401120:	00401b8d 	.word	0x00401b8d
  401124:	004019f5 	.word	0x004019f5
  401128:	0040203d 	.word	0x0040203d
  40112c:	00401eb9 	.word	0x00401eb9
  401130:	00402011 	.word	0x00402011

00401134 <xQueueGenericSendFromISR>:
	configASSERT( pxQueue );
  401134:	2800      	cmp	r0, #0
  401136:	d05f      	beq.n	4011f8 <xQueueGenericSendFromISR+0xc4>
{
  401138:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40113c:	b085      	sub	sp, #20
  40113e:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  401140:	2900      	cmp	r1, #0
  401142:	d062      	beq.n	40120a <xQueueGenericSendFromISR+0xd6>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  401144:	2b02      	cmp	r3, #2
  401146:	d06c      	beq.n	401222 <xQueueGenericSendFromISR+0xee>
  401148:	461d      	mov	r5, r3
  40114a:	9301      	str	r3, [sp, #4]
  40114c:	4616      	mov	r6, r2
  40114e:	9103      	str	r1, [sp, #12]
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  401150:	4b51      	ldr	r3, [pc, #324]	; (401298 <xQueueGenericSendFromISR+0x164>)
  401152:	4798      	blx	r3
	__asm volatile
  401154:	f3ef 8b11 	mrs	fp, BASEPRI
  401158:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  40115c:	f383 8811 	msr	BASEPRI, r3
  401160:	f3bf 8f6f 	isb	sy
  401164:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  401168:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  40116a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  40116c:	429a      	cmp	r2, r3
  40116e:	d301      	bcc.n	401174 <xQueueGenericSendFromISR+0x40>
  401170:	2d02      	cmp	r5, #2
  401172:	d173      	bne.n	40125c <xQueueGenericSendFromISR+0x128>
			const int8_t cTxLock = pxQueue->cTxLock;
  401174:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
  401178:	b26d      	sxtb	r5, r5
			traceQUEUE_SEND_FROM_ISR( pxQueue );
  40117a:	4620      	mov	r0, r4
  40117c:	f8df 9130 	ldr.w	r9, [pc, #304]	; 4012b0 <xQueueGenericSendFromISR+0x17c>
  401180:	47c8      	blx	r9
  401182:	f8df 8130 	ldr.w	r8, [pc, #304]	; 4012b4 <xQueueGenericSendFromISR+0x180>
  401186:	f818 7000 	ldrb.w	r7, [r8, r0]
  40118a:	3730      	adds	r7, #48	; 0x30
  40118c:	b2ff      	uxtb	r7, r7
  40118e:	4620      	mov	r0, r4
  401190:	47c8      	blx	r9
  401192:	f818 3000 	ldrb.w	r3, [r8, r0]
  401196:	9302      	str	r3, [sp, #8]
  401198:	4620      	mov	r0, r4
  40119a:	f8df a11c 	ldr.w	sl, [pc, #284]	; 4012b8 <xQueueGenericSendFromISR+0x184>
  40119e:	47d0      	blx	sl
  4011a0:	4602      	mov	r2, r0
  4011a2:	9902      	ldr	r1, [sp, #8]
  4011a4:	4638      	mov	r0, r7
  4011a6:	4b3d      	ldr	r3, [pc, #244]	; (40129c <xQueueGenericSendFromISR+0x168>)
  4011a8:	4798      	blx	r3
  4011aa:	4620      	mov	r0, r4
  4011ac:	47c8      	blx	r9
  4011ae:	f818 7000 	ldrb.w	r7, [r8, r0]
  4011b2:	4620      	mov	r0, r4
  4011b4:	47d0      	blx	sl
  4011b6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  4011b8:	3201      	adds	r2, #1
  4011ba:	b2d2      	uxtb	r2, r2
  4011bc:	4601      	mov	r1, r0
  4011be:	4638      	mov	r0, r7
  4011c0:	4b37      	ldr	r3, [pc, #220]	; (4012a0 <xQueueGenericSendFromISR+0x16c>)
  4011c2:	4798      	blx	r3
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  4011c4:	9a01      	ldr	r2, [sp, #4]
  4011c6:	9903      	ldr	r1, [sp, #12]
  4011c8:	4620      	mov	r0, r4
  4011ca:	4b36      	ldr	r3, [pc, #216]	; (4012a4 <xQueueGenericSendFromISR+0x170>)
  4011cc:	4798      	blx	r3
			if( cTxLock == queueUNLOCKED )
  4011ce:	f1b5 3fff 	cmp.w	r5, #4294967295
  4011d2:	d13d      	bne.n	401250 <xQueueGenericSendFromISR+0x11c>
					if( pxQueue->pxQueueSetContainer != NULL )
  4011d4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4011d6:	2b00      	cmp	r3, #0
  4011d8:	d02f      	beq.n	40123a <xQueueGenericSendFromISR+0x106>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
  4011da:	9901      	ldr	r1, [sp, #4]
  4011dc:	4620      	mov	r0, r4
  4011de:	4b32      	ldr	r3, [pc, #200]	; (4012a8 <xQueueGenericSendFromISR+0x174>)
  4011e0:	4798      	blx	r3
  4011e2:	2800      	cmp	r0, #0
  4011e4:	d04e      	beq.n	401284 <xQueueGenericSendFromISR+0x150>
							if( pxHigherPriorityTaskWoken != NULL )
  4011e6:	2e00      	cmp	r6, #0
  4011e8:	d04e      	beq.n	401288 <xQueueGenericSendFromISR+0x154>
								*pxHigherPriorityTaskWoken = pdTRUE;
  4011ea:	2001      	movs	r0, #1
  4011ec:	6030      	str	r0, [r6, #0]
	__asm volatile
  4011ee:	f38b 8811 	msr	BASEPRI, fp
}
  4011f2:	b005      	add	sp, #20
  4011f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__asm volatile
  4011f8:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  4011fc:	f383 8811 	msr	BASEPRI, r3
  401200:	f3bf 8f6f 	isb	sy
  401204:	f3bf 8f4f 	dsb	sy
  401208:	e7fe      	b.n	401208 <xQueueGenericSendFromISR+0xd4>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  40120a:	6c00      	ldr	r0, [r0, #64]	; 0x40
  40120c:	2800      	cmp	r0, #0
  40120e:	d099      	beq.n	401144 <xQueueGenericSendFromISR+0x10>
  401210:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  401214:	f383 8811 	msr	BASEPRI, r3
  401218:	f3bf 8f6f 	isb	sy
  40121c:	f3bf 8f4f 	dsb	sy
  401220:	e7fe      	b.n	401220 <xQueueGenericSendFromISR+0xec>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  401222:	6be0      	ldr	r0, [r4, #60]	; 0x3c
  401224:	2801      	cmp	r0, #1
  401226:	d08f      	beq.n	401148 <xQueueGenericSendFromISR+0x14>
  401228:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  40122c:	f383 8811 	msr	BASEPRI, r3
  401230:	f3bf 8f6f 	isb	sy
  401234:	f3bf 8f4f 	dsb	sy
  401238:	e7fe      	b.n	401238 <xQueueGenericSendFromISR+0x104>
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  40123a:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40123c:	b333      	cbz	r3, 40128c <xQueueGenericSendFromISR+0x158>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  40123e:	f104 0024 	add.w	r0, r4, #36	; 0x24
  401242:	4b1a      	ldr	r3, [pc, #104]	; (4012ac <xQueueGenericSendFromISR+0x178>)
  401244:	4798      	blx	r3
  401246:	b318      	cbz	r0, 401290 <xQueueGenericSendFromISR+0x15c>
								if( pxHigherPriorityTaskWoken != NULL )
  401248:	b326      	cbz	r6, 401294 <xQueueGenericSendFromISR+0x160>
									*pxHigherPriorityTaskWoken = pdTRUE;
  40124a:	2001      	movs	r0, #1
  40124c:	6030      	str	r0, [r6, #0]
  40124e:	e7ce      	b.n	4011ee <xQueueGenericSendFromISR+0xba>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  401250:	1c6b      	adds	r3, r5, #1
  401252:	b25b      	sxtb	r3, r3
  401254:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
  401258:	2001      	movs	r0, #1
  40125a:	e7c8      	b.n	4011ee <xQueueGenericSendFromISR+0xba>
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
  40125c:	4620      	mov	r0, r4
  40125e:	4f14      	ldr	r7, [pc, #80]	; (4012b0 <xQueueGenericSendFromISR+0x17c>)
  401260:	47b8      	blx	r7
  401262:	4e14      	ldr	r6, [pc, #80]	; (4012b4 <xQueueGenericSendFromISR+0x180>)
  401264:	5c35      	ldrb	r5, [r6, r0]
  401266:	3558      	adds	r5, #88	; 0x58
  401268:	b2ed      	uxtb	r5, r5
  40126a:	4620      	mov	r0, r4
  40126c:	47b8      	blx	r7
  40126e:	5c36      	ldrb	r6, [r6, r0]
  401270:	4620      	mov	r0, r4
  401272:	4b11      	ldr	r3, [pc, #68]	; (4012b8 <xQueueGenericSendFromISR+0x184>)
  401274:	4798      	blx	r3
  401276:	4602      	mov	r2, r0
  401278:	4631      	mov	r1, r6
  40127a:	4628      	mov	r0, r5
  40127c:	4b07      	ldr	r3, [pc, #28]	; (40129c <xQueueGenericSendFromISR+0x168>)
  40127e:	4798      	blx	r3
			xReturn = errQUEUE_FULL;
  401280:	2000      	movs	r0, #0
  401282:	e7b4      	b.n	4011ee <xQueueGenericSendFromISR+0xba>
			xReturn = pdPASS;
  401284:	2001      	movs	r0, #1
  401286:	e7b2      	b.n	4011ee <xQueueGenericSendFromISR+0xba>
  401288:	2001      	movs	r0, #1
  40128a:	e7b0      	b.n	4011ee <xQueueGenericSendFromISR+0xba>
  40128c:	2001      	movs	r0, #1
  40128e:	e7ae      	b.n	4011ee <xQueueGenericSendFromISR+0xba>
  401290:	2001      	movs	r0, #1
  401292:	e7ac      	b.n	4011ee <xQueueGenericSendFromISR+0xba>
  401294:	2001      	movs	r0, #1
  401296:	e7aa      	b.n	4011ee <xQueueGenericSendFromISR+0xba>
  401298:	00400a71 	.word	0x00400a71
  40129c:	00403615 	.word	0x00403615
  4012a0:	00402fed 	.word	0x00402fed
  4012a4:	00400acd 	.word	0x00400acd
  4012a8:	00400b4d 	.word	0x00400b4d
  4012ac:	00401f69 	.word	0x00401f69
  4012b0:	00402819 	.word	0x00402819
  4012b4:	20000008 	.word	0x20000008
  4012b8:	00402809 	.word	0x00402809

004012bc <xQueueGenericReceive>:
{
  4012bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4012c0:	b087      	sub	sp, #28
  4012c2:	9203      	str	r2, [sp, #12]
	configASSERT( pxQueue );
  4012c4:	b188      	cbz	r0, 4012ea <xQueueGenericReceive+0x2e>
  4012c6:	4604      	mov	r4, r0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  4012c8:	b1c1      	cbz	r1, 4012fc <xQueueGenericReceive+0x40>
  4012ca:	9302      	str	r3, [sp, #8]
  4012cc:	9101      	str	r1, [sp, #4]
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  4012ce:	4b97      	ldr	r3, [pc, #604]	; (40152c <xQueueGenericReceive+0x270>)
  4012d0:	4798      	blx	r3
  4012d2:	b9f8      	cbnz	r0, 401314 <xQueueGenericReceive+0x58>
  4012d4:	9b03      	ldr	r3, [sp, #12]
  4012d6:	b323      	cbz	r3, 401322 <xQueueGenericReceive+0x66>
  4012d8:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  4012dc:	f383 8811 	msr	BASEPRI, r3
  4012e0:	f3bf 8f6f 	isb	sy
  4012e4:	f3bf 8f4f 	dsb	sy
  4012e8:	e7fe      	b.n	4012e8 <xQueueGenericReceive+0x2c>
  4012ea:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  4012ee:	f383 8811 	msr	BASEPRI, r3
  4012f2:	f3bf 8f6f 	isb	sy
  4012f6:	f3bf 8f4f 	dsb	sy
  4012fa:	e7fe      	b.n	4012fa <xQueueGenericReceive+0x3e>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  4012fc:	6c02      	ldr	r2, [r0, #64]	; 0x40
  4012fe:	2a00      	cmp	r2, #0
  401300:	d0e3      	beq.n	4012ca <xQueueGenericReceive+0xe>
  401302:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  401306:	f383 8811 	msr	BASEPRI, r3
  40130a:	f3bf 8f6f 	isb	sy
  40130e:	f3bf 8f4f 	dsb	sy
  401312:	e7fe      	b.n	401312 <xQueueGenericReceive+0x56>
  401314:	2700      	movs	r7, #0
		taskENTER_CRITICAL();
  401316:	4d86      	ldr	r5, [pc, #536]	; (401530 <xQueueGenericReceive+0x274>)
					vTaskSetTimeOutState( &xTimeOut );
  401318:	f8df a264 	ldr.w	sl, [pc, #612]	; 401580 <xQueueGenericReceive+0x2c4>
					portYIELD_WITHIN_API();
  40131c:	f8df 9234 	ldr.w	r9, [pc, #564]	; 401554 <xQueueGenericReceive+0x298>
  401320:	e09e      	b.n	401460 <xQueueGenericReceive+0x1a4>
  401322:	2700      	movs	r7, #0
  401324:	e7f7      	b.n	401316 <xQueueGenericReceive+0x5a>
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
  401326:	68e7      	ldr	r7, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  401328:	9901      	ldr	r1, [sp, #4]
  40132a:	4620      	mov	r0, r4
  40132c:	4b81      	ldr	r3, [pc, #516]	; (401534 <xQueueGenericReceive+0x278>)
  40132e:	4798      	blx	r3
				if( xJustPeeking == pdFALSE )
  401330:	9b02      	ldr	r3, [sp, #8]
  401332:	2b00      	cmp	r3, #0
  401334:	d148      	bne.n	4013c8 <xQueueGenericReceive+0x10c>
					traceQUEUE_RECEIVE( pxQueue );
  401336:	4620      	mov	r0, r4
  401338:	f8df 9224 	ldr.w	r9, [pc, #548]	; 401560 <xQueueGenericReceive+0x2a4>
  40133c:	47c8      	blx	r9
  40133e:	4f7e      	ldr	r7, [pc, #504]	; (401538 <xQueueGenericReceive+0x27c>)
  401340:	5c3d      	ldrb	r5, [r7, r0]
  401342:	3528      	adds	r5, #40	; 0x28
  401344:	b2ed      	uxtb	r5, r5
  401346:	4620      	mov	r0, r4
  401348:	47c8      	blx	r9
  40134a:	f817 a000 	ldrb.w	sl, [r7, r0]
  40134e:	4620      	mov	r0, r4
  401350:	f8df 8208 	ldr.w	r8, [pc, #520]	; 40155c <xQueueGenericReceive+0x2a0>
  401354:	47c0      	blx	r8
  401356:	4602      	mov	r2, r0
  401358:	4651      	mov	r1, sl
  40135a:	4628      	mov	r0, r5
  40135c:	4b77      	ldr	r3, [pc, #476]	; (40153c <xQueueGenericReceive+0x280>)
  40135e:	4798      	blx	r3
  401360:	4620      	mov	r0, r4
  401362:	47c8      	blx	r9
  401364:	5c3d      	ldrb	r5, [r7, r0]
  401366:	4620      	mov	r0, r4
  401368:	47c0      	blx	r8
  40136a:	4680      	mov	r8, r0
  40136c:	4620      	mov	r0, r4
  40136e:	47c8      	blx	r9
  401370:	5c3b      	ldrb	r3, [r7, r0]
  401372:	2b02      	cmp	r3, #2
  401374:	d124      	bne.n	4013c0 <xQueueGenericReceive+0x104>
  401376:	4b72      	ldr	r3, [pc, #456]	; (401540 <xQueueGenericReceive+0x284>)
  401378:	4798      	blx	r3
  40137a:	4b72      	ldr	r3, [pc, #456]	; (401544 <xQueueGenericReceive+0x288>)
  40137c:	4798      	blx	r3
  40137e:	4602      	mov	r2, r0
  401380:	4641      	mov	r1, r8
  401382:	4628      	mov	r0, r5
  401384:	4b70      	ldr	r3, [pc, #448]	; (401548 <xQueueGenericReceive+0x28c>)
  401386:	4798      	blx	r3
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
  401388:	3e01      	subs	r6, #1
  40138a:	63a6      	str	r6, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  40138c:	6823      	ldr	r3, [r4, #0]
  40138e:	b913      	cbnz	r3, 401396 <xQueueGenericReceive+0xda>
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
  401390:	4b6e      	ldr	r3, [pc, #440]	; (40154c <xQueueGenericReceive+0x290>)
  401392:	4798      	blx	r3
  401394:	6060      	str	r0, [r4, #4]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  401396:	6923      	ldr	r3, [r4, #16]
  401398:	b163      	cbz	r3, 4013b4 <xQueueGenericReceive+0xf8>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  40139a:	f104 0010 	add.w	r0, r4, #16
  40139e:	4b6c      	ldr	r3, [pc, #432]	; (401550 <xQueueGenericReceive+0x294>)
  4013a0:	4798      	blx	r3
  4013a2:	b138      	cbz	r0, 4013b4 <xQueueGenericReceive+0xf8>
							queueYIELD_IF_USING_PREEMPTION();
  4013a4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4013a8:	4b6a      	ldr	r3, [pc, #424]	; (401554 <xQueueGenericReceive+0x298>)
  4013aa:	601a      	str	r2, [r3, #0]
  4013ac:	f3bf 8f4f 	dsb	sy
  4013b0:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
  4013b4:	4b68      	ldr	r3, [pc, #416]	; (401558 <xQueueGenericReceive+0x29c>)
  4013b6:	4798      	blx	r3
				return pdPASS;
  4013b8:	2001      	movs	r0, #1
}
  4013ba:	b007      	add	sp, #28
  4013bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					traceQUEUE_RECEIVE( pxQueue );
  4013c0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  4013c2:	3a01      	subs	r2, #1
  4013c4:	b2d2      	uxtb	r2, r2
  4013c6:	e7db      	b.n	401380 <xQueueGenericReceive+0xc4>
					traceQUEUE_PEEK( pxQueue );
  4013c8:	4620      	mov	r0, r4
  4013ca:	f8df 8194 	ldr.w	r8, [pc, #404]	; 401560 <xQueueGenericReceive+0x2a4>
  4013ce:	47c0      	blx	r8
  4013d0:	4e59      	ldr	r6, [pc, #356]	; (401538 <xQueueGenericReceive+0x27c>)
  4013d2:	5c35      	ldrb	r5, [r6, r0]
  4013d4:	3578      	adds	r5, #120	; 0x78
  4013d6:	b2ed      	uxtb	r5, r5
  4013d8:	4620      	mov	r0, r4
  4013da:	47c0      	blx	r8
  4013dc:	5c36      	ldrb	r6, [r6, r0]
  4013de:	4620      	mov	r0, r4
  4013e0:	4b5e      	ldr	r3, [pc, #376]	; (40155c <xQueueGenericReceive+0x2a0>)
  4013e2:	4798      	blx	r3
  4013e4:	4602      	mov	r2, r0
  4013e6:	4631      	mov	r1, r6
  4013e8:	4628      	mov	r0, r5
  4013ea:	4b54      	ldr	r3, [pc, #336]	; (40153c <xQueueGenericReceive+0x280>)
  4013ec:	4798      	blx	r3
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
  4013ee:	60e7      	str	r7, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4013f0:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4013f2:	2b00      	cmp	r3, #0
  4013f4:	d0de      	beq.n	4013b4 <xQueueGenericReceive+0xf8>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4013f6:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4013fa:	4b55      	ldr	r3, [pc, #340]	; (401550 <xQueueGenericReceive+0x294>)
  4013fc:	4798      	blx	r3
  4013fe:	2800      	cmp	r0, #0
  401400:	d0d8      	beq.n	4013b4 <xQueueGenericReceive+0xf8>
							queueYIELD_IF_USING_PREEMPTION();
  401402:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401406:	4b53      	ldr	r3, [pc, #332]	; (401554 <xQueueGenericReceive+0x298>)
  401408:	601a      	str	r2, [r3, #0]
  40140a:	f3bf 8f4f 	dsb	sy
  40140e:	f3bf 8f6f 	isb	sy
  401412:	e7cf      	b.n	4013b4 <xQueueGenericReceive+0xf8>
					taskEXIT_CRITICAL();
  401414:	4b50      	ldr	r3, [pc, #320]	; (401558 <xQueueGenericReceive+0x29c>)
  401416:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
  401418:	4620      	mov	r0, r4
  40141a:	4f51      	ldr	r7, [pc, #324]	; (401560 <xQueueGenericReceive+0x2a4>)
  40141c:	47b8      	blx	r7
  40141e:	4e46      	ldr	r6, [pc, #280]	; (401538 <xQueueGenericReceive+0x27c>)
  401420:	5c35      	ldrb	r5, [r6, r0]
  401422:	3550      	adds	r5, #80	; 0x50
  401424:	b2ed      	uxtb	r5, r5
  401426:	4620      	mov	r0, r4
  401428:	47b8      	blx	r7
  40142a:	5c36      	ldrb	r6, [r6, r0]
  40142c:	4620      	mov	r0, r4
  40142e:	4b4b      	ldr	r3, [pc, #300]	; (40155c <xQueueGenericReceive+0x2a0>)
  401430:	4798      	blx	r3
  401432:	4602      	mov	r2, r0
  401434:	4631      	mov	r1, r6
  401436:	4628      	mov	r0, r5
  401438:	4b40      	ldr	r3, [pc, #256]	; (40153c <xQueueGenericReceive+0x280>)
  40143a:	4798      	blx	r3
					return errQUEUE_EMPTY;
  40143c:	2000      	movs	r0, #0
  40143e:	e7bc      	b.n	4013ba <xQueueGenericReceive+0xfe>
					vTaskSetTimeOutState( &xTimeOut );
  401440:	a804      	add	r0, sp, #16
  401442:	47d0      	blx	sl
  401444:	e016      	b.n	401474 <xQueueGenericReceive+0x1b8>
						taskENTER_CRITICAL();
  401446:	47a8      	blx	r5
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  401448:	6860      	ldr	r0, [r4, #4]
  40144a:	4b46      	ldr	r3, [pc, #280]	; (401564 <xQueueGenericReceive+0x2a8>)
  40144c:	4798      	blx	r3
						taskEXIT_CRITICAL();
  40144e:	4b42      	ldr	r3, [pc, #264]	; (401558 <xQueueGenericReceive+0x29c>)
  401450:	4798      	blx	r3
  401452:	e056      	b.n	401502 <xQueueGenericReceive+0x246>
				prvUnlockQueue( pxQueue );
  401454:	4620      	mov	r0, r4
  401456:	4b44      	ldr	r3, [pc, #272]	; (401568 <xQueueGenericReceive+0x2ac>)
  401458:	4798      	blx	r3
				( void ) xTaskResumeAll();
  40145a:	4b44      	ldr	r3, [pc, #272]	; (40156c <xQueueGenericReceive+0x2b0>)
  40145c:	4798      	blx	r3
  40145e:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
  401460:	47a8      	blx	r5
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  401462:	6ba6      	ldr	r6, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  401464:	2e00      	cmp	r6, #0
  401466:	f47f af5e 	bne.w	401326 <xQueueGenericReceive+0x6a>
				if( xTicksToWait == ( TickType_t ) 0 )
  40146a:	9b03      	ldr	r3, [sp, #12]
  40146c:	2b00      	cmp	r3, #0
  40146e:	d0d1      	beq.n	401414 <xQueueGenericReceive+0x158>
				else if( xEntryTimeSet == pdFALSE )
  401470:	2f00      	cmp	r7, #0
  401472:	d0e5      	beq.n	401440 <xQueueGenericReceive+0x184>
		taskEXIT_CRITICAL();
  401474:	4b38      	ldr	r3, [pc, #224]	; (401558 <xQueueGenericReceive+0x29c>)
  401476:	4798      	blx	r3
		vTaskSuspendAll();
  401478:	4b3d      	ldr	r3, [pc, #244]	; (401570 <xQueueGenericReceive+0x2b4>)
  40147a:	4798      	blx	r3
		prvLockQueue( pxQueue );
  40147c:	47a8      	blx	r5
  40147e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  401482:	b25b      	sxtb	r3, r3
  401484:	f1b3 3fff 	cmp.w	r3, #4294967295
  401488:	bf04      	itt	eq
  40148a:	2300      	moveq	r3, #0
  40148c:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
  401490:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  401494:	b25b      	sxtb	r3, r3
  401496:	f1b3 3fff 	cmp.w	r3, #4294967295
  40149a:	bf04      	itt	eq
  40149c:	2300      	moveq	r3, #0
  40149e:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
  4014a2:	4b2d      	ldr	r3, [pc, #180]	; (401558 <xQueueGenericReceive+0x29c>)
  4014a4:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  4014a6:	a903      	add	r1, sp, #12
  4014a8:	a804      	add	r0, sp, #16
  4014aa:	4b32      	ldr	r3, [pc, #200]	; (401574 <xQueueGenericReceive+0x2b8>)
  4014ac:	4798      	blx	r3
  4014ae:	2800      	cmp	r0, #0
  4014b0:	d168      	bne.n	401584 <xQueueGenericReceive+0x2c8>
	taskENTER_CRITICAL();
  4014b2:	47a8      	blx	r5
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  4014b4:	6ba6      	ldr	r6, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
  4014b6:	4b28      	ldr	r3, [pc, #160]	; (401558 <xQueueGenericReceive+0x29c>)
  4014b8:	4798      	blx	r3
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  4014ba:	2e00      	cmp	r6, #0
  4014bc:	d1ca      	bne.n	401454 <xQueueGenericReceive+0x198>
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
  4014be:	4620      	mov	r0, r4
  4014c0:	f8df 809c 	ldr.w	r8, [pc, #156]	; 401560 <xQueueGenericReceive+0x2a4>
  4014c4:	47c0      	blx	r8
  4014c6:	4f1c      	ldr	r7, [pc, #112]	; (401538 <xQueueGenericReceive+0x27c>)
  4014c8:	5c3e      	ldrb	r6, [r7, r0]
  4014ca:	3668      	adds	r6, #104	; 0x68
  4014cc:	b2f6      	uxtb	r6, r6
  4014ce:	4620      	mov	r0, r4
  4014d0:	47c0      	blx	r8
  4014d2:	f817 b000 	ldrb.w	fp, [r7, r0]
  4014d6:	4620      	mov	r0, r4
  4014d8:	4b20      	ldr	r3, [pc, #128]	; (40155c <xQueueGenericReceive+0x2a0>)
  4014da:	4798      	blx	r3
  4014dc:	4602      	mov	r2, r0
  4014de:	4659      	mov	r1, fp
  4014e0:	4630      	mov	r0, r6
  4014e2:	4b16      	ldr	r3, [pc, #88]	; (40153c <xQueueGenericReceive+0x280>)
  4014e4:	4798      	blx	r3
  4014e6:	4620      	mov	r0, r4
  4014e8:	47c0      	blx	r8
  4014ea:	5c3b      	ldrb	r3, [r7, r0]
  4014ec:	2b02      	cmp	r3, #2
  4014ee:	d005      	beq.n	4014fc <xQueueGenericReceive+0x240>
  4014f0:	4b13      	ldr	r3, [pc, #76]	; (401540 <xQueueGenericReceive+0x284>)
  4014f2:	4798      	blx	r3
  4014f4:	4b13      	ldr	r3, [pc, #76]	; (401544 <xQueueGenericReceive+0x288>)
  4014f6:	4798      	blx	r3
  4014f8:	4b1f      	ldr	r3, [pc, #124]	; (401578 <xQueueGenericReceive+0x2bc>)
  4014fa:	4798      	blx	r3
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  4014fc:	6823      	ldr	r3, [r4, #0]
  4014fe:	2b00      	cmp	r3, #0
  401500:	d0a1      	beq.n	401446 <xQueueGenericReceive+0x18a>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  401502:	9903      	ldr	r1, [sp, #12]
  401504:	f104 0024 	add.w	r0, r4, #36	; 0x24
  401508:	4b1c      	ldr	r3, [pc, #112]	; (40157c <xQueueGenericReceive+0x2c0>)
  40150a:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  40150c:	4620      	mov	r0, r4
  40150e:	4b16      	ldr	r3, [pc, #88]	; (401568 <xQueueGenericReceive+0x2ac>)
  401510:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  401512:	4b16      	ldr	r3, [pc, #88]	; (40156c <xQueueGenericReceive+0x2b0>)
  401514:	4798      	blx	r3
  401516:	2800      	cmp	r0, #0
  401518:	d1a1      	bne.n	40145e <xQueueGenericReceive+0x1a2>
					portYIELD_WITHIN_API();
  40151a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  40151e:	f8c9 3000 	str.w	r3, [r9]
  401522:	f3bf 8f4f 	dsb	sy
  401526:	f3bf 8f6f 	isb	sy
  40152a:	e798      	b.n	40145e <xQueueGenericReceive+0x1a2>
  40152c:	004020ed 	.word	0x004020ed
  401530:	004008a5 	.word	0x004008a5
  401534:	00400c41 	.word	0x00400c41
  401538:	20000008 	.word	0x20000008
  40153c:	00403615 	.word	0x00403615
  401540:	004027fd 	.word	0x004027fd
  401544:	00402825 	.word	0x00402825
  401548:	00402fed 	.word	0x00402fed
  40154c:	0040230d 	.word	0x0040230d
  401550:	00401f69 	.word	0x00401f69
  401554:	e000ed04 	.word	0xe000ed04
  401558:	004008e9 	.word	0x004008e9
  40155c:	00402809 	.word	0x00402809
  401560:	00402819 	.word	0x00402819
  401564:	0040210d 	.word	0x0040210d
  401568:	00400c69 	.word	0x00400c69
  40156c:	00401b8d 	.word	0x00401b8d
  401570:	004019f5 	.word	0x004019f5
  401574:	0040203d 	.word	0x0040203d
  401578:	00403045 	.word	0x00403045
  40157c:	00401eb9 	.word	0x00401eb9
  401580:	00402011 	.word	0x00402011
			prvUnlockQueue( pxQueue );
  401584:	4620      	mov	r0, r4
  401586:	4b0f      	ldr	r3, [pc, #60]	; (4015c4 <xQueueGenericReceive+0x308>)
  401588:	4798      	blx	r3
			( void ) xTaskResumeAll();
  40158a:	4b0f      	ldr	r3, [pc, #60]	; (4015c8 <xQueueGenericReceive+0x30c>)
  40158c:	4798      	blx	r3
	taskENTER_CRITICAL();
  40158e:	47a8      	blx	r5
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  401590:	6ba6      	ldr	r6, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
  401592:	4b0e      	ldr	r3, [pc, #56]	; (4015cc <xQueueGenericReceive+0x310>)
  401594:	4798      	blx	r3
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  401596:	2e00      	cmp	r6, #0
  401598:	f47f af61 	bne.w	40145e <xQueueGenericReceive+0x1a2>
				traceQUEUE_RECEIVE_FAILED( pxQueue );
  40159c:	4620      	mov	r0, r4
  40159e:	4f0c      	ldr	r7, [pc, #48]	; (4015d0 <xQueueGenericReceive+0x314>)
  4015a0:	47b8      	blx	r7
  4015a2:	4e0c      	ldr	r6, [pc, #48]	; (4015d4 <xQueueGenericReceive+0x318>)
  4015a4:	5c35      	ldrb	r5, [r6, r0]
  4015a6:	3550      	adds	r5, #80	; 0x50
  4015a8:	b2ed      	uxtb	r5, r5
  4015aa:	4620      	mov	r0, r4
  4015ac:	47b8      	blx	r7
  4015ae:	5c36      	ldrb	r6, [r6, r0]
  4015b0:	4620      	mov	r0, r4
  4015b2:	4b09      	ldr	r3, [pc, #36]	; (4015d8 <xQueueGenericReceive+0x31c>)
  4015b4:	4798      	blx	r3
  4015b6:	4602      	mov	r2, r0
  4015b8:	4631      	mov	r1, r6
  4015ba:	4628      	mov	r0, r5
  4015bc:	4b07      	ldr	r3, [pc, #28]	; (4015dc <xQueueGenericReceive+0x320>)
  4015be:	4798      	blx	r3
				return errQUEUE_EMPTY;
  4015c0:	2000      	movs	r0, #0
  4015c2:	e6fa      	b.n	4013ba <xQueueGenericReceive+0xfe>
  4015c4:	00400c69 	.word	0x00400c69
  4015c8:	00401b8d 	.word	0x00401b8d
  4015cc:	004008e9 	.word	0x004008e9
  4015d0:	00402819 	.word	0x00402819
  4015d4:	20000008 	.word	0x20000008
  4015d8:	00402809 	.word	0x00402809
  4015dc:	00403615 	.word	0x00403615

004015e0 <uxQueueGetQueueNumber>:
	}
  4015e0:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
  4015e2:	4770      	bx	lr

004015e4 <ucQueueGetQueueType>:
	}
  4015e4:	f890 0050 	ldrb.w	r0, [r0, #80]	; 0x50
  4015e8:	4770      	bx	lr
	...

004015ec <vQueueWaitForMessageRestricted>:
	{
  4015ec:	b570      	push	{r4, r5, r6, lr}
  4015ee:	4604      	mov	r4, r0
  4015f0:	460d      	mov	r5, r1
  4015f2:	4616      	mov	r6, r2
		prvLockQueue( pxQueue );
  4015f4:	4b11      	ldr	r3, [pc, #68]	; (40163c <vQueueWaitForMessageRestricted+0x50>)
  4015f6:	4798      	blx	r3
  4015f8:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  4015fc:	b25b      	sxtb	r3, r3
  4015fe:	f1b3 3fff 	cmp.w	r3, #4294967295
  401602:	bf04      	itt	eq
  401604:	2300      	moveq	r3, #0
  401606:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
  40160a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  40160e:	b25b      	sxtb	r3, r3
  401610:	f1b3 3fff 	cmp.w	r3, #4294967295
  401614:	bf04      	itt	eq
  401616:	2300      	moveq	r3, #0
  401618:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
  40161c:	4b08      	ldr	r3, [pc, #32]	; (401640 <vQueueWaitForMessageRestricted+0x54>)
  40161e:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  401620:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  401622:	b11b      	cbz	r3, 40162c <vQueueWaitForMessageRestricted+0x40>
		prvUnlockQueue( pxQueue );
  401624:	4620      	mov	r0, r4
  401626:	4b07      	ldr	r3, [pc, #28]	; (401644 <vQueueWaitForMessageRestricted+0x58>)
  401628:	4798      	blx	r3
  40162a:	bd70      	pop	{r4, r5, r6, pc}
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  40162c:	4632      	mov	r2, r6
  40162e:	4629      	mov	r1, r5
  401630:	f104 0024 	add.w	r0, r4, #36	; 0x24
  401634:	4b04      	ldr	r3, [pc, #16]	; (401648 <vQueueWaitForMessageRestricted+0x5c>)
  401636:	4798      	blx	r3
  401638:	e7f4      	b.n	401624 <vQueueWaitForMessageRestricted+0x38>
  40163a:	bf00      	nop
  40163c:	004008a5 	.word	0x004008a5
  401640:	004008e9 	.word	0x004008e9
  401644:	00400c69 	.word	0x00400c69
  401648:	00401ef1 	.word	0x00401ef1

0040164c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  40164c:	4b08      	ldr	r3, [pc, #32]	; (401670 <prvResetNextTaskUnblockTime+0x24>)
  40164e:	681b      	ldr	r3, [r3, #0]
  401650:	681b      	ldr	r3, [r3, #0]
  401652:	b13b      	cbz	r3, 401664 <prvResetNextTaskUnblockTime+0x18>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  401654:	4b06      	ldr	r3, [pc, #24]	; (401670 <prvResetNextTaskUnblockTime+0x24>)
  401656:	681b      	ldr	r3, [r3, #0]
  401658:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  40165a:	68db      	ldr	r3, [r3, #12]
  40165c:	685a      	ldr	r2, [r3, #4]
  40165e:	4b05      	ldr	r3, [pc, #20]	; (401674 <prvResetNextTaskUnblockTime+0x28>)
  401660:	601a      	str	r2, [r3, #0]
  401662:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
  401664:	f04f 32ff 	mov.w	r2, #4294967295
  401668:	4b02      	ldr	r3, [pc, #8]	; (401674 <prvResetNextTaskUnblockTime+0x28>)
  40166a:	601a      	str	r2, [r3, #0]
  40166c:	4770      	bx	lr
  40166e:	bf00      	nop
  401670:	2000a480 	.word	0x2000a480
  401674:	2000a530 	.word	0x2000a530

00401678 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
  401678:	b570      	push	{r4, r5, r6, lr}
  40167a:	4604      	mov	r4, r0
  40167c:	460e      	mov	r6, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
  40167e:	4b1d      	ldr	r3, [pc, #116]	; (4016f4 <prvAddCurrentTaskToDelayedList+0x7c>)
  401680:	681d      	ldr	r5, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  401682:	4b1d      	ldr	r3, [pc, #116]	; (4016f8 <prvAddCurrentTaskToDelayedList+0x80>)
  401684:	6818      	ldr	r0, [r3, #0]
  401686:	3004      	adds	r0, #4
  401688:	4b1c      	ldr	r3, [pc, #112]	; (4016fc <prvAddCurrentTaskToDelayedList+0x84>)
  40168a:	4798      	blx	r3
  40168c:	b948      	cbnz	r0, 4016a2 <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  40168e:	4b1a      	ldr	r3, [pc, #104]	; (4016f8 <prvAddCurrentTaskToDelayedList+0x80>)
  401690:	681a      	ldr	r2, [r3, #0]
  401692:	491b      	ldr	r1, [pc, #108]	; (401700 <prvAddCurrentTaskToDelayedList+0x88>)
  401694:	680b      	ldr	r3, [r1, #0]
  401696:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
  401698:	2201      	movs	r2, #1
  40169a:	4082      	lsls	r2, r0
  40169c:	ea23 0302 	bic.w	r3, r3, r2
  4016a0:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
  4016a2:	f1b4 3fff 	cmp.w	r4, #4294967295
  4016a6:	d013      	beq.n	4016d0 <prvAddCurrentTaskToDelayedList+0x58>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
  4016a8:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
  4016aa:	4b13      	ldr	r3, [pc, #76]	; (4016f8 <prvAddCurrentTaskToDelayedList+0x80>)
  4016ac:	681b      	ldr	r3, [r3, #0]
  4016ae:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
  4016b0:	42a5      	cmp	r5, r4
  4016b2:	d816      	bhi.n	4016e2 <prvAddCurrentTaskToDelayedList+0x6a>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  4016b4:	4b13      	ldr	r3, [pc, #76]	; (401704 <prvAddCurrentTaskToDelayedList+0x8c>)
  4016b6:	6818      	ldr	r0, [r3, #0]
  4016b8:	4b0f      	ldr	r3, [pc, #60]	; (4016f8 <prvAddCurrentTaskToDelayedList+0x80>)
  4016ba:	6819      	ldr	r1, [r3, #0]
  4016bc:	3104      	adds	r1, #4
  4016be:	4b12      	ldr	r3, [pc, #72]	; (401708 <prvAddCurrentTaskToDelayedList+0x90>)
  4016c0:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
  4016c2:	4b12      	ldr	r3, [pc, #72]	; (40170c <prvAddCurrentTaskToDelayedList+0x94>)
  4016c4:	681b      	ldr	r3, [r3, #0]
  4016c6:	429c      	cmp	r4, r3
				{
					xNextTaskUnblockTime = xTimeToWake;
  4016c8:	bf3c      	itt	cc
  4016ca:	4b10      	ldrcc	r3, [pc, #64]	; (40170c <prvAddCurrentTaskToDelayedList+0x94>)
  4016cc:	601c      	strcc	r4, [r3, #0]
  4016ce:	bd70      	pop	{r4, r5, r6, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
  4016d0:	2e00      	cmp	r6, #0
  4016d2:	d0e9      	beq.n	4016a8 <prvAddCurrentTaskToDelayedList+0x30>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
  4016d4:	4b08      	ldr	r3, [pc, #32]	; (4016f8 <prvAddCurrentTaskToDelayedList+0x80>)
  4016d6:	6819      	ldr	r1, [r3, #0]
  4016d8:	3104      	adds	r1, #4
  4016da:	480d      	ldr	r0, [pc, #52]	; (401710 <prvAddCurrentTaskToDelayedList+0x98>)
  4016dc:	4b0d      	ldr	r3, [pc, #52]	; (401714 <prvAddCurrentTaskToDelayedList+0x9c>)
  4016de:	4798      	blx	r3
  4016e0:	bd70      	pop	{r4, r5, r6, pc}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  4016e2:	4b0d      	ldr	r3, [pc, #52]	; (401718 <prvAddCurrentTaskToDelayedList+0xa0>)
  4016e4:	6818      	ldr	r0, [r3, #0]
  4016e6:	4b04      	ldr	r3, [pc, #16]	; (4016f8 <prvAddCurrentTaskToDelayedList+0x80>)
  4016e8:	6819      	ldr	r1, [r3, #0]
  4016ea:	3104      	adds	r1, #4
  4016ec:	4b06      	ldr	r3, [pc, #24]	; (401708 <prvAddCurrentTaskToDelayedList+0x90>)
  4016ee:	4798      	blx	r3
  4016f0:	bd70      	pop	{r4, r5, r6, pc}
  4016f2:	bf00      	nop
  4016f4:	2000a578 	.word	0x2000a578
  4016f8:	2000a47c 	.word	0x2000a47c
  4016fc:	004007d9 	.word	0x004007d9
  401700:	2000a500 	.word	0x2000a500
  401704:	2000a480 	.word	0x2000a480
  401708:	004007a5 	.word	0x004007a5
  40170c:	2000a530 	.word	0x2000a530
  401710:	2000a550 	.word	0x2000a550
  401714:	0040078d 	.word	0x0040078d
  401718:	2000a484 	.word	0x2000a484

0040171c <xTaskCreate>:
	{
  40171c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401720:	b083      	sub	sp, #12
  401722:	4683      	mov	fp, r0
  401724:	460d      	mov	r5, r1
  401726:	9301      	str	r3, [sp, #4]
  401728:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  40172c:	0096      	lsls	r6, r2, #2
  40172e:	4630      	mov	r0, r6
  401730:	4b70      	ldr	r3, [pc, #448]	; (4018f4 <xTaskCreate+0x1d8>)
  401732:	4798      	blx	r3
			if( pxStack != NULL )
  401734:	2800      	cmp	r0, #0
  401736:	f000 80ad 	beq.w	401894 <xTaskCreate+0x178>
  40173a:	4607      	mov	r7, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
  40173c:	2058      	movs	r0, #88	; 0x58
  40173e:	4b6d      	ldr	r3, [pc, #436]	; (4018f4 <xTaskCreate+0x1d8>)
  401740:	4798      	blx	r3
				if( pxNewTCB != NULL )
  401742:	4604      	mov	r4, r0
  401744:	2800      	cmp	r0, #0
  401746:	f000 80a2 	beq.w	40188e <xTaskCreate+0x172>
					pxNewTCB->pxStack = pxStack;
  40174a:	6307      	str	r7, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
  40174c:	4632      	mov	r2, r6
  40174e:	21a5      	movs	r1, #165	; 0xa5
  401750:	4638      	mov	r0, r7
  401752:	4b69      	ldr	r3, [pc, #420]	; (4018f8 <xTaskCreate+0x1dc>)
  401754:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
  401756:	3e04      	subs	r6, #4
  401758:	6b23      	ldr	r3, [r4, #48]	; 0x30
  40175a:	441e      	add	r6, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
  40175c:	f026 0607 	bic.w	r6, r6, #7
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
  401760:	782b      	ldrb	r3, [r5, #0]
  401762:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
		if( pcName[ x ] == 0x00 )
  401766:	782b      	ldrb	r3, [r5, #0]
  401768:	b163      	cbz	r3, 401784 <xTaskCreate+0x68>
  40176a:	462b      	mov	r3, r5
  40176c:	f104 0234 	add.w	r2, r4, #52	; 0x34
  401770:	f105 0109 	add.w	r1, r5, #9
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
  401774:	7858      	ldrb	r0, [r3, #1]
  401776:	f802 0f01 	strb.w	r0, [r2, #1]!
		if( pcName[ x ] == 0x00 )
  40177a:	f813 0f01 	ldrb.w	r0, [r3, #1]!
  40177e:	b108      	cbz	r0, 401784 <xTaskCreate+0x68>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  401780:	428b      	cmp	r3, r1
  401782:	d1f7      	bne.n	401774 <xTaskCreate+0x58>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
  401784:	2700      	movs	r7, #0
  401786:	f884 703d 	strb.w	r7, [r4, #61]	; 0x3d
  40178a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  40178c:	2d04      	cmp	r5, #4
  40178e:	bf28      	it	cs
  401790:	2504      	movcs	r5, #4
	pxNewTCB->uxPriority = uxPriority;
  401792:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
  401794:	64a5      	str	r5, [r4, #72]	; 0x48
		pxNewTCB->uxMutexesHeld = 0;
  401796:	64e7      	str	r7, [r4, #76]	; 0x4c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
  401798:	f104 0804 	add.w	r8, r4, #4
  40179c:	4640      	mov	r0, r8
  40179e:	f8df 91c4 	ldr.w	r9, [pc, #452]	; 401964 <xTaskCreate+0x248>
  4017a2:	47c8      	blx	r9
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
  4017a4:	f104 0018 	add.w	r0, r4, #24
  4017a8:	47c8      	blx	r9
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
  4017aa:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  4017ac:	f1c5 0505 	rsb	r5, r5, #5
  4017b0:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
  4017b2:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
  4017b4:	6527      	str	r7, [r4, #80]	; 0x50
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  4017b6:	f884 7054 	strb.w	r7, [r4, #84]	; 0x54
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  4017ba:	9a01      	ldr	r2, [sp, #4]
  4017bc:	4659      	mov	r1, fp
  4017be:	4630      	mov	r0, r6
  4017c0:	4b4e      	ldr	r3, [pc, #312]	; (4018fc <xTaskCreate+0x1e0>)
  4017c2:	4798      	blx	r3
  4017c4:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
  4017c6:	f1ba 0f00 	cmp.w	sl, #0
  4017ca:	d001      	beq.n	4017d0 <xTaskCreate+0xb4>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
  4017cc:	f8ca 4000 	str.w	r4, [sl]
	taskENTER_CRITICAL();
  4017d0:	4b4b      	ldr	r3, [pc, #300]	; (401900 <xTaskCreate+0x1e4>)
  4017d2:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
  4017d4:	4a4b      	ldr	r2, [pc, #300]	; (401904 <xTaskCreate+0x1e8>)
  4017d6:	6813      	ldr	r3, [r2, #0]
  4017d8:	3301      	adds	r3, #1
  4017da:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
  4017dc:	4b4a      	ldr	r3, [pc, #296]	; (401908 <xTaskCreate+0x1ec>)
  4017de:	681b      	ldr	r3, [r3, #0]
  4017e0:	2b00      	cmp	r3, #0
  4017e2:	d05a      	beq.n	40189a <xTaskCreate+0x17e>
			if( xSchedulerRunning == pdFALSE )
  4017e4:	4b49      	ldr	r3, [pc, #292]	; (40190c <xTaskCreate+0x1f0>)
  4017e6:	681b      	ldr	r3, [r3, #0]
  4017e8:	b93b      	cbnz	r3, 4017fa <xTaskCreate+0xde>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
  4017ea:	4b47      	ldr	r3, [pc, #284]	; (401908 <xTaskCreate+0x1ec>)
  4017ec:	681b      	ldr	r3, [r3, #0]
  4017ee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4017f0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  4017f2:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
  4017f4:	bf9c      	itt	ls
  4017f6:	4b44      	ldrls	r3, [pc, #272]	; (401908 <xTaskCreate+0x1ec>)
  4017f8:	601c      	strls	r4, [r3, #0]
		uxTaskNumber++;
  4017fa:	4a45      	ldr	r2, [pc, #276]	; (401910 <xTaskCreate+0x1f4>)
  4017fc:	6813      	ldr	r3, [r2, #0]
  4017fe:	3301      	adds	r3, #1
  401800:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
  401802:	6423      	str	r3, [r4, #64]	; 0x40
		traceTASK_CREATE( pxNewTCB );
  401804:	2003      	movs	r0, #3
  401806:	4b43      	ldr	r3, [pc, #268]	; (401914 <xTaskCreate+0x1f8>)
  401808:	4798      	blx	r3
  40180a:	6460      	str	r0, [r4, #68]	; 0x44
  40180c:	4620      	mov	r0, r4
  40180e:	4d42      	ldr	r5, [pc, #264]	; (401918 <xTaskCreate+0x1fc>)
  401810:	47a8      	blx	r5
  401812:	f104 0234 	add.w	r2, r4, #52	; 0x34
  401816:	4601      	mov	r1, r0
  401818:	2003      	movs	r0, #3
  40181a:	4b40      	ldr	r3, [pc, #256]	; (40191c <xTaskCreate+0x200>)
  40181c:	4798      	blx	r3
  40181e:	4620      	mov	r0, r4
  401820:	47a8      	blx	r5
  401822:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
  401826:	4601      	mov	r1, r0
  401828:	2003      	movs	r0, #3
  40182a:	4b3d      	ldr	r3, [pc, #244]	; (401920 <xTaskCreate+0x204>)
  40182c:	4798      	blx	r3
  40182e:	4620      	mov	r0, r4
  401830:	47a8      	blx	r5
  401832:	4602      	mov	r2, r0
  401834:	2103      	movs	r1, #3
  401836:	201b      	movs	r0, #27
  401838:	4b3a      	ldr	r3, [pc, #232]	; (401924 <xTaskCreate+0x208>)
  40183a:	4798      	blx	r3
		prvAddTaskToReadyList( pxNewTCB );
  40183c:	4620      	mov	r0, r4
  40183e:	47a8      	blx	r5
  401840:	4b39      	ldr	r3, [pc, #228]	; (401928 <xTaskCreate+0x20c>)
  401842:	4798      	blx	r3
  401844:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  401846:	4a39      	ldr	r2, [pc, #228]	; (40192c <xTaskCreate+0x210>)
  401848:	6811      	ldr	r1, [r2, #0]
  40184a:	2301      	movs	r3, #1
  40184c:	4083      	lsls	r3, r0
  40184e:	430b      	orrs	r3, r1
  401850:	6013      	str	r3, [r2, #0]
  401852:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  401856:	4641      	mov	r1, r8
  401858:	4b35      	ldr	r3, [pc, #212]	; (401930 <xTaskCreate+0x214>)
  40185a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  40185e:	4b35      	ldr	r3, [pc, #212]	; (401934 <xTaskCreate+0x218>)
  401860:	4798      	blx	r3
	taskEXIT_CRITICAL();
  401862:	4b35      	ldr	r3, [pc, #212]	; (401938 <xTaskCreate+0x21c>)
  401864:	4798      	blx	r3
	if( xSchedulerRunning != pdFALSE )
  401866:	4b29      	ldr	r3, [pc, #164]	; (40190c <xTaskCreate+0x1f0>)
  401868:	681b      	ldr	r3, [r3, #0]
  40186a:	2b00      	cmp	r3, #0
  40186c:	d03b      	beq.n	4018e6 <xTaskCreate+0x1ca>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
  40186e:	4b26      	ldr	r3, [pc, #152]	; (401908 <xTaskCreate+0x1ec>)
  401870:	681b      	ldr	r3, [r3, #0]
  401872:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  401874:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  401876:	429a      	cmp	r2, r3
  401878:	d239      	bcs.n	4018ee <xTaskCreate+0x1d2>
			taskYIELD_IF_USING_PREEMPTION();
  40187a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40187e:	4b2f      	ldr	r3, [pc, #188]	; (40193c <xTaskCreate+0x220>)
  401880:	601a      	str	r2, [r3, #0]
  401882:	f3bf 8f4f 	dsb	sy
  401886:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
  40188a:	2001      	movs	r0, #1
  40188c:	e02c      	b.n	4018e8 <xTaskCreate+0x1cc>
					vPortFree( pxStack );
  40188e:	4638      	mov	r0, r7
  401890:	4b2b      	ldr	r3, [pc, #172]	; (401940 <xTaskCreate+0x224>)
  401892:	4798      	blx	r3
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  401894:	f04f 30ff 	mov.w	r0, #4294967295
  401898:	e026      	b.n	4018e8 <xTaskCreate+0x1cc>
			pxCurrentTCB = pxNewTCB;
  40189a:	4b1b      	ldr	r3, [pc, #108]	; (401908 <xTaskCreate+0x1ec>)
  40189c:	601c      	str	r4, [r3, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
  40189e:	6813      	ldr	r3, [r2, #0]
  4018a0:	2b01      	cmp	r3, #1
  4018a2:	d1aa      	bne.n	4017fa <xTaskCreate+0xde>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  4018a4:	4e22      	ldr	r6, [pc, #136]	; (401930 <xTaskCreate+0x214>)
  4018a6:	4630      	mov	r0, r6
  4018a8:	4d26      	ldr	r5, [pc, #152]	; (401944 <xTaskCreate+0x228>)
  4018aa:	47a8      	blx	r5
  4018ac:	f106 0014 	add.w	r0, r6, #20
  4018b0:	47a8      	blx	r5
  4018b2:	f106 0028 	add.w	r0, r6, #40	; 0x28
  4018b6:	47a8      	blx	r5
  4018b8:	f106 003c 	add.w	r0, r6, #60	; 0x3c
  4018bc:	47a8      	blx	r5
  4018be:	f106 0050 	add.w	r0, r6, #80	; 0x50
  4018c2:	47a8      	blx	r5
	vListInitialise( &xDelayedTaskList1 );
  4018c4:	4f20      	ldr	r7, [pc, #128]	; (401948 <xTaskCreate+0x22c>)
  4018c6:	4638      	mov	r0, r7
  4018c8:	47a8      	blx	r5
	vListInitialise( &xDelayedTaskList2 );
  4018ca:	4e20      	ldr	r6, [pc, #128]	; (40194c <xTaskCreate+0x230>)
  4018cc:	4630      	mov	r0, r6
  4018ce:	47a8      	blx	r5
	vListInitialise( &xPendingReadyList );
  4018d0:	481f      	ldr	r0, [pc, #124]	; (401950 <xTaskCreate+0x234>)
  4018d2:	47a8      	blx	r5
		vListInitialise( &xTasksWaitingTermination );
  4018d4:	481f      	ldr	r0, [pc, #124]	; (401954 <xTaskCreate+0x238>)
  4018d6:	47a8      	blx	r5
		vListInitialise( &xSuspendedTaskList );
  4018d8:	481f      	ldr	r0, [pc, #124]	; (401958 <xTaskCreate+0x23c>)
  4018da:	47a8      	blx	r5
	pxDelayedTaskList = &xDelayedTaskList1;
  4018dc:	4b1f      	ldr	r3, [pc, #124]	; (40195c <xTaskCreate+0x240>)
  4018de:	601f      	str	r7, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  4018e0:	4b1f      	ldr	r3, [pc, #124]	; (401960 <xTaskCreate+0x244>)
  4018e2:	601e      	str	r6, [r3, #0]
  4018e4:	e789      	b.n	4017fa <xTaskCreate+0xde>
			xReturn = pdPASS;
  4018e6:	2001      	movs	r0, #1
	}
  4018e8:	b003      	add	sp, #12
  4018ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			xReturn = pdPASS;
  4018ee:	2001      	movs	r0, #1
		return xReturn;
  4018f0:	e7fa      	b.n	4018e8 <xTaskCreate+0x1cc>
  4018f2:	bf00      	nop
  4018f4:	00400585 	.word	0x00400585
  4018f8:	00403eb1 	.word	0x00403eb1
  4018fc:	00400851 	.word	0x00400851
  401900:	004008a5 	.word	0x004008a5
  401904:	2000a4ec 	.word	0x2000a4ec
  401908:	2000a47c 	.word	0x2000a47c
  40190c:	2000a54c 	.word	0x2000a54c
  401910:	2000a4fc 	.word	0x2000a4fc
  401914:	00403085 	.word	0x00403085
  401918:	00402825 	.word	0x00402825
  40191c:	00403225 	.word	0x00403225
  401920:	00402f39 	.word	0x00402f39
  401924:	00403615 	.word	0x00403615
  401928:	00403485 	.word	0x00403485
  40192c:	2000a500 	.word	0x2000a500
  401930:	2000a488 	.word	0x2000a488
  401934:	0040078d 	.word	0x0040078d
  401938:	004008e9 	.word	0x004008e9
  40193c:	e000ed04 	.word	0xe000ed04
  401940:	004006e9 	.word	0x004006e9
  401944:	00400771 	.word	0x00400771
  401948:	2000a504 	.word	0x2000a504
  40194c:	2000a518 	.word	0x2000a518
  401950:	2000a538 	.word	0x2000a538
  401954:	2000a564 	.word	0x2000a564
  401958:	2000a550 	.word	0x2000a550
  40195c:	2000a480 	.word	0x2000a480
  401960:	2000a484 	.word	0x2000a484
  401964:	00400787 	.word	0x00400787

00401968 <vTaskStartScheduler>:
{
  401968:	b510      	push	{r4, lr}
  40196a:	b082      	sub	sp, #8
		xReturn = xTaskCreate(	prvIdleTask,
  40196c:	4b18      	ldr	r3, [pc, #96]	; (4019d0 <vTaskStartScheduler+0x68>)
  40196e:	9301      	str	r3, [sp, #4]
  401970:	2300      	movs	r3, #0
  401972:	9300      	str	r3, [sp, #0]
  401974:	2282      	movs	r2, #130	; 0x82
  401976:	4917      	ldr	r1, [pc, #92]	; (4019d4 <vTaskStartScheduler+0x6c>)
  401978:	4817      	ldr	r0, [pc, #92]	; (4019d8 <vTaskStartScheduler+0x70>)
  40197a:	4c18      	ldr	r4, [pc, #96]	; (4019dc <vTaskStartScheduler+0x74>)
  40197c:	47a0      	blx	r4
		if( xReturn == pdPASS )
  40197e:	2801      	cmp	r0, #1
  401980:	d004      	beq.n	40198c <vTaskStartScheduler+0x24>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
  401982:	f1b0 3fff 	cmp.w	r0, #4294967295
  401986:	d01a      	beq.n	4019be <vTaskStartScheduler+0x56>
}
  401988:	b002      	add	sp, #8
  40198a:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
  40198c:	4b14      	ldr	r3, [pc, #80]	; (4019e0 <vTaskStartScheduler+0x78>)
  40198e:	4798      	blx	r3
	if( xReturn == pdPASS )
  401990:	2801      	cmp	r0, #1
  401992:	d1f6      	bne.n	401982 <vTaskStartScheduler+0x1a>
  401994:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  401998:	f383 8811 	msr	BASEPRI, r3
  40199c:	f3bf 8f6f 	isb	sy
  4019a0:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
  4019a4:	f04f 32ff 	mov.w	r2, #4294967295
  4019a8:	4b0e      	ldr	r3, [pc, #56]	; (4019e4 <vTaskStartScheduler+0x7c>)
  4019aa:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
  4019ac:	2201      	movs	r2, #1
  4019ae:	4b0e      	ldr	r3, [pc, #56]	; (4019e8 <vTaskStartScheduler+0x80>)
  4019b0:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
  4019b2:	2200      	movs	r2, #0
  4019b4:	4b0d      	ldr	r3, [pc, #52]	; (4019ec <vTaskStartScheduler+0x84>)
  4019b6:	601a      	str	r2, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
  4019b8:	4b0d      	ldr	r3, [pc, #52]	; (4019f0 <vTaskStartScheduler+0x88>)
  4019ba:	4798      	blx	r3
  4019bc:	e7e4      	b.n	401988 <vTaskStartScheduler+0x20>
  4019be:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  4019c2:	f383 8811 	msr	BASEPRI, r3
  4019c6:	f3bf 8f6f 	isb	sy
  4019ca:	f3bf 8f4f 	dsb	sy
  4019ce:	e7fe      	b.n	4019ce <vTaskStartScheduler+0x66>
  4019d0:	2000a52c 	.word	0x2000a52c
  4019d4:	004040e8 	.word	0x004040e8
  4019d8:	00401d3d 	.word	0x00401d3d
  4019dc:	0040171d 	.word	0x0040171d
  4019e0:	004023d1 	.word	0x004023d1
  4019e4:	2000a530 	.word	0x2000a530
  4019e8:	2000a54c 	.word	0x2000a54c
  4019ec:	2000a578 	.word	0x2000a578
  4019f0:	004009c1 	.word	0x004009c1

004019f4 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
  4019f4:	4a02      	ldr	r2, [pc, #8]	; (401a00 <vTaskSuspendAll+0xc>)
  4019f6:	6813      	ldr	r3, [r2, #0]
  4019f8:	3301      	adds	r3, #1
  4019fa:	6013      	str	r3, [r2, #0]
  4019fc:	4770      	bx	lr
  4019fe:	bf00      	nop
  401a00:	2000a4f8 	.word	0x2000a4f8

00401a04 <xTaskGetTickCount>:
		xTicks = xTickCount;
  401a04:	4b01      	ldr	r3, [pc, #4]	; (401a0c <xTaskGetTickCount+0x8>)
  401a06:	6818      	ldr	r0, [r3, #0]
}
  401a08:	4770      	bx	lr
  401a0a:	bf00      	nop
  401a0c:	2000a578 	.word	0x2000a578

00401a10 <xTaskIncrementTick>:
{
  401a10:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	traceTASK_INCREMENT_TICK( xTickCount );
  401a14:	4b4a      	ldr	r3, [pc, #296]	; (401b40 <xTaskIncrementTick+0x130>)
  401a16:	681b      	ldr	r3, [r3, #0]
  401a18:	2b01      	cmp	r3, #1
  401a1a:	d002      	beq.n	401a22 <xTaskIncrementTick+0x12>
  401a1c:	4b49      	ldr	r3, [pc, #292]	; (401b44 <xTaskIncrementTick+0x134>)
  401a1e:	681b      	ldr	r3, [r3, #0]
  401a20:	b933      	cbnz	r3, 401a30 <xTaskIncrementTick+0x20>
  401a22:	4a49      	ldr	r2, [pc, #292]	; (401b48 <xTaskIncrementTick+0x138>)
  401a24:	6813      	ldr	r3, [r2, #0]
  401a26:	3301      	adds	r3, #1
  401a28:	6013      	str	r3, [r2, #0]
  401a2a:	2000      	movs	r0, #0
  401a2c:	4b47      	ldr	r3, [pc, #284]	; (401b4c <xTaskIncrementTick+0x13c>)
  401a2e:	4798      	blx	r3
  401a30:	4b43      	ldr	r3, [pc, #268]	; (401b40 <xTaskIncrementTick+0x130>)
  401a32:	681a      	ldr	r2, [r3, #0]
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  401a34:	681b      	ldr	r3, [r3, #0]
  401a36:	2b00      	cmp	r3, #0
  401a38:	d17a      	bne.n	401b30 <xTaskIncrementTick+0x120>
		const TickType_t xConstTickCount = xTickCount + 1;
  401a3a:	4b45      	ldr	r3, [pc, #276]	; (401b50 <xTaskIncrementTick+0x140>)
  401a3c:	681e      	ldr	r6, [r3, #0]
  401a3e:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
  401a40:	601e      	str	r6, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U )
  401a42:	b9c6      	cbnz	r6, 401a76 <xTaskIncrementTick+0x66>
			taskSWITCH_DELAYED_LISTS();
  401a44:	4b43      	ldr	r3, [pc, #268]	; (401b54 <xTaskIncrementTick+0x144>)
  401a46:	681b      	ldr	r3, [r3, #0]
  401a48:	681b      	ldr	r3, [r3, #0]
  401a4a:	b143      	cbz	r3, 401a5e <xTaskIncrementTick+0x4e>
  401a4c:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  401a50:	f383 8811 	msr	BASEPRI, r3
  401a54:	f3bf 8f6f 	isb	sy
  401a58:	f3bf 8f4f 	dsb	sy
  401a5c:	e7fe      	b.n	401a5c <xTaskIncrementTick+0x4c>
  401a5e:	4a3d      	ldr	r2, [pc, #244]	; (401b54 <xTaskIncrementTick+0x144>)
  401a60:	6811      	ldr	r1, [r2, #0]
  401a62:	4b3d      	ldr	r3, [pc, #244]	; (401b58 <xTaskIncrementTick+0x148>)
  401a64:	6818      	ldr	r0, [r3, #0]
  401a66:	6010      	str	r0, [r2, #0]
  401a68:	6019      	str	r1, [r3, #0]
  401a6a:	4a3c      	ldr	r2, [pc, #240]	; (401b5c <xTaskIncrementTick+0x14c>)
  401a6c:	6813      	ldr	r3, [r2, #0]
  401a6e:	3301      	adds	r3, #1
  401a70:	6013      	str	r3, [r2, #0]
  401a72:	4b3b      	ldr	r3, [pc, #236]	; (401b60 <xTaskIncrementTick+0x150>)
  401a74:	4798      	blx	r3
		if( xConstTickCount >= xNextTaskUnblockTime )
  401a76:	4b3b      	ldr	r3, [pc, #236]	; (401b64 <xTaskIncrementTick+0x154>)
  401a78:	681b      	ldr	r3, [r3, #0]
  401a7a:	429e      	cmp	r6, r3
  401a7c:	d218      	bcs.n	401ab0 <xTaskIncrementTick+0xa0>
BaseType_t xSwitchRequired = pdFALSE;
  401a7e:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
  401a80:	4b39      	ldr	r3, [pc, #228]	; (401b68 <xTaskIncrementTick+0x158>)
  401a82:	681b      	ldr	r3, [r3, #0]
  401a84:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401a86:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  401a8a:	4a38      	ldr	r2, [pc, #224]	; (401b6c <xTaskIncrementTick+0x15c>)
  401a8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
				xSwitchRequired = pdTRUE;
  401a90:	2b02      	cmp	r3, #2
  401a92:	bf28      	it	cs
  401a94:	2401      	movcs	r4, #1
			if( uxPendedTicks == ( UBaseType_t ) 0U )
  401a96:	4b2b      	ldr	r3, [pc, #172]	; (401b44 <xTaskIncrementTick+0x134>)
  401a98:	681b      	ldr	r3, [r3, #0]
  401a9a:	b90b      	cbnz	r3, 401aa0 <xTaskIncrementTick+0x90>
				vApplicationTickHook();
  401a9c:	4b34      	ldr	r3, [pc, #208]	; (401b70 <xTaskIncrementTick+0x160>)
  401a9e:	4798      	blx	r3
		if( xYieldPending != pdFALSE )
  401aa0:	4b34      	ldr	r3, [pc, #208]	; (401b74 <xTaskIncrementTick+0x164>)
  401aa2:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
  401aa4:	2b00      	cmp	r3, #0
}
  401aa6:	bf0c      	ite	eq
  401aa8:	4620      	moveq	r0, r4
  401aaa:	2001      	movne	r0, #1
  401aac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  401ab0:	2400      	movs	r4, #0
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  401ab2:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 401b54 <xTaskIncrementTick+0x144>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  401ab6:	4f30      	ldr	r7, [pc, #192]	; (401b78 <xTaskIncrementTick+0x168>)
					prvAddTaskToReadyList( pxTCB );
  401ab8:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 401b88 <xTaskIncrementTick+0x178>
  401abc:	e024      	b.n	401b08 <xTaskIncrementTick+0xf8>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  401abe:	f04f 32ff 	mov.w	r2, #4294967295
  401ac2:	4b28      	ldr	r3, [pc, #160]	; (401b64 <xTaskIncrementTick+0x154>)
  401ac4:	601a      	str	r2, [r3, #0]
					break;
  401ac6:	e7db      	b.n	401a80 <xTaskIncrementTick+0x70>
						xNextTaskUnblockTime = xItemValue;
  401ac8:	4a26      	ldr	r2, [pc, #152]	; (401b64 <xTaskIncrementTick+0x154>)
  401aca:	6013      	str	r3, [r2, #0]
						break;
  401acc:	e7d8      	b.n	401a80 <xTaskIncrementTick+0x70>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  401ace:	f105 0018 	add.w	r0, r5, #24
  401ad2:	47b8      	blx	r7
					prvAddTaskToReadyList( pxTCB );
  401ad4:	4628      	mov	r0, r5
  401ad6:	47d0      	blx	sl
  401ad8:	4b28      	ldr	r3, [pc, #160]	; (401b7c <xTaskIncrementTick+0x16c>)
  401ada:	4798      	blx	r3
  401adc:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
  401ade:	4a28      	ldr	r2, [pc, #160]	; (401b80 <xTaskIncrementTick+0x170>)
  401ae0:	6811      	ldr	r1, [r2, #0]
  401ae2:	2301      	movs	r3, #1
  401ae4:	4083      	lsls	r3, r0
  401ae6:	430b      	orrs	r3, r1
  401ae8:	6013      	str	r3, [r2, #0]
  401aea:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  401aee:	4649      	mov	r1, r9
  401af0:	4b1e      	ldr	r3, [pc, #120]	; (401b6c <xTaskIncrementTick+0x15c>)
  401af2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  401af6:	4b23      	ldr	r3, [pc, #140]	; (401b84 <xTaskIncrementTick+0x174>)
  401af8:	4798      	blx	r3
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  401afa:	4b1b      	ldr	r3, [pc, #108]	; (401b68 <xTaskIncrementTick+0x158>)
  401afc:	681b      	ldr	r3, [r3, #0]
  401afe:	6aea      	ldr	r2, [r5, #44]	; 0x2c
  401b00:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
  401b02:	429a      	cmp	r2, r3
  401b04:	bf28      	it	cs
  401b06:	2401      	movcs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  401b08:	f8d8 3000 	ldr.w	r3, [r8]
  401b0c:	681b      	ldr	r3, [r3, #0]
  401b0e:	2b00      	cmp	r3, #0
  401b10:	d0d5      	beq.n	401abe <xTaskIncrementTick+0xae>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  401b12:	f8d8 3000 	ldr.w	r3, [r8]
  401b16:	68db      	ldr	r3, [r3, #12]
  401b18:	68dd      	ldr	r5, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
  401b1a:	686b      	ldr	r3, [r5, #4]
					if( xConstTickCount < xItemValue )
  401b1c:	429e      	cmp	r6, r3
  401b1e:	d3d3      	bcc.n	401ac8 <xTaskIncrementTick+0xb8>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  401b20:	f105 0904 	add.w	r9, r5, #4
  401b24:	4648      	mov	r0, r9
  401b26:	47b8      	blx	r7
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  401b28:	6aab      	ldr	r3, [r5, #40]	; 0x28
  401b2a:	2b00      	cmp	r3, #0
  401b2c:	d1cf      	bne.n	401ace <xTaskIncrementTick+0xbe>
  401b2e:	e7d1      	b.n	401ad4 <xTaskIncrementTick+0xc4>
		++uxPendedTicks;
  401b30:	4a04      	ldr	r2, [pc, #16]	; (401b44 <xTaskIncrementTick+0x134>)
  401b32:	6813      	ldr	r3, [r2, #0]
  401b34:	3301      	adds	r3, #1
  401b36:	6013      	str	r3, [r2, #0]
			vApplicationTickHook();
  401b38:	4b0d      	ldr	r3, [pc, #52]	; (401b70 <xTaskIncrementTick+0x160>)
  401b3a:	4798      	blx	r3
BaseType_t xSwitchRequired = pdFALSE;
  401b3c:	2400      	movs	r4, #0
  401b3e:	e7af      	b.n	401aa0 <xTaskIncrementTick+0x90>
  401b40:	2000a4f8 	.word	0x2000a4f8
  401b44:	2000a4f4 	.word	0x2000a4f4
  401b48:	2000a690 	.word	0x2000a690
  401b4c:	00403315 	.word	0x00403315
  401b50:	2000a578 	.word	0x2000a578
  401b54:	2000a480 	.word	0x2000a480
  401b58:	2000a484 	.word	0x2000a484
  401b5c:	2000a534 	.word	0x2000a534
  401b60:	0040164d 	.word	0x0040164d
  401b64:	2000a530 	.word	0x2000a530
  401b68:	2000a47c 	.word	0x2000a47c
  401b6c:	2000a488 	.word	0x2000a488
  401b70:	00403d2b 	.word	0x00403d2b
  401b74:	2000a57c 	.word	0x2000a57c
  401b78:	004007d9 	.word	0x004007d9
  401b7c:	00403485 	.word	0x00403485
  401b80:	2000a500 	.word	0x2000a500
  401b84:	0040078d 	.word	0x0040078d
  401b88:	00402825 	.word	0x00402825

00401b8c <xTaskResumeAll>:
	configASSERT( uxSchedulerSuspended );
  401b8c:	4b38      	ldr	r3, [pc, #224]	; (401c70 <xTaskResumeAll+0xe4>)
  401b8e:	681b      	ldr	r3, [r3, #0]
  401b90:	b943      	cbnz	r3, 401ba4 <xTaskResumeAll+0x18>
  401b92:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  401b96:	f383 8811 	msr	BASEPRI, r3
  401b9a:	f3bf 8f6f 	isb	sy
  401b9e:	f3bf 8f4f 	dsb	sy
  401ba2:	e7fe      	b.n	401ba2 <xTaskResumeAll+0x16>
{
  401ba4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	taskENTER_CRITICAL();
  401ba8:	4b32      	ldr	r3, [pc, #200]	; (401c74 <xTaskResumeAll+0xe8>)
  401baa:	4798      	blx	r3
		--uxSchedulerSuspended;
  401bac:	4b30      	ldr	r3, [pc, #192]	; (401c70 <xTaskResumeAll+0xe4>)
  401bae:	681a      	ldr	r2, [r3, #0]
  401bb0:	3a01      	subs	r2, #1
  401bb2:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  401bb4:	681b      	ldr	r3, [r3, #0]
  401bb6:	2b00      	cmp	r3, #0
  401bb8:	d155      	bne.n	401c66 <xTaskResumeAll+0xda>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
  401bba:	4b2f      	ldr	r3, [pc, #188]	; (401c78 <xTaskResumeAll+0xec>)
  401bbc:	681b      	ldr	r3, [r3, #0]
  401bbe:	b92b      	cbnz	r3, 401bcc <xTaskResumeAll+0x40>
BaseType_t xAlreadyYielded = pdFALSE;
  401bc0:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
  401bc2:	4b2e      	ldr	r3, [pc, #184]	; (401c7c <xTaskResumeAll+0xf0>)
  401bc4:	4798      	blx	r3
}
  401bc6:	4620      	mov	r0, r4
  401bc8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401bcc:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  401bce:	4e2c      	ldr	r6, [pc, #176]	; (401c80 <xTaskResumeAll+0xf4>)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  401bd0:	4d2c      	ldr	r5, [pc, #176]	; (401c84 <xTaskResumeAll+0xf8>)
					prvAddTaskToReadyList( pxTCB );
  401bd2:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 401cb0 <xTaskResumeAll+0x124>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  401bd6:	6833      	ldr	r3, [r6, #0]
  401bd8:	b323      	cbz	r3, 401c24 <xTaskResumeAll+0x98>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
  401bda:	68f3      	ldr	r3, [r6, #12]
  401bdc:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  401bde:	f104 0018 	add.w	r0, r4, #24
  401be2:	47a8      	blx	r5
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  401be4:	1d27      	adds	r7, r4, #4
  401be6:	4638      	mov	r0, r7
  401be8:	47a8      	blx	r5
					prvAddTaskToReadyList( pxTCB );
  401bea:	4620      	mov	r0, r4
  401bec:	47c0      	blx	r8
  401bee:	4b26      	ldr	r3, [pc, #152]	; (401c88 <xTaskResumeAll+0xfc>)
  401bf0:	4798      	blx	r3
  401bf2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  401bf4:	4a25      	ldr	r2, [pc, #148]	; (401c8c <xTaskResumeAll+0x100>)
  401bf6:	6811      	ldr	r1, [r2, #0]
  401bf8:	2301      	movs	r3, #1
  401bfa:	4083      	lsls	r3, r0
  401bfc:	430b      	orrs	r3, r1
  401bfe:	6013      	str	r3, [r2, #0]
  401c00:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  401c04:	4639      	mov	r1, r7
  401c06:	4b22      	ldr	r3, [pc, #136]	; (401c90 <xTaskResumeAll+0x104>)
  401c08:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  401c0c:	4b21      	ldr	r3, [pc, #132]	; (401c94 <xTaskResumeAll+0x108>)
  401c0e:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  401c10:	4b21      	ldr	r3, [pc, #132]	; (401c98 <xTaskResumeAll+0x10c>)
  401c12:	681b      	ldr	r3, [r3, #0]
  401c14:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  401c16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401c18:	429a      	cmp	r2, r3
  401c1a:	d3dc      	bcc.n	401bd6 <xTaskResumeAll+0x4a>
						xYieldPending = pdTRUE;
  401c1c:	2201      	movs	r2, #1
  401c1e:	4b1f      	ldr	r3, [pc, #124]	; (401c9c <xTaskResumeAll+0x110>)
  401c20:	601a      	str	r2, [r3, #0]
  401c22:	e7d8      	b.n	401bd6 <xTaskResumeAll+0x4a>
				if( pxTCB != NULL )
  401c24:	b10c      	cbz	r4, 401c2a <xTaskResumeAll+0x9e>
					prvResetNextTaskUnblockTime();
  401c26:	4b1e      	ldr	r3, [pc, #120]	; (401ca0 <xTaskResumeAll+0x114>)
  401c28:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
  401c2a:	4b1e      	ldr	r3, [pc, #120]	; (401ca4 <xTaskResumeAll+0x118>)
  401c2c:	681c      	ldr	r4, [r3, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
  401c2e:	b16c      	cbz	r4, 401c4c <xTaskResumeAll+0xc0>
							if( xTaskIncrementTick() != pdFALSE )
  401c30:	4f1d      	ldr	r7, [pc, #116]	; (401ca8 <xTaskResumeAll+0x11c>)
								xYieldPending = pdTRUE;
  401c32:	4e1a      	ldr	r6, [pc, #104]	; (401c9c <xTaskResumeAll+0x110>)
  401c34:	2501      	movs	r5, #1
  401c36:	e001      	b.n	401c3c <xTaskResumeAll+0xb0>
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
  401c38:	3c01      	subs	r4, #1
  401c3a:	d004      	beq.n	401c46 <xTaskResumeAll+0xba>
							if( xTaskIncrementTick() != pdFALSE )
  401c3c:	47b8      	blx	r7
  401c3e:	2800      	cmp	r0, #0
  401c40:	d0fa      	beq.n	401c38 <xTaskResumeAll+0xac>
								xYieldPending = pdTRUE;
  401c42:	6035      	str	r5, [r6, #0]
  401c44:	e7f8      	b.n	401c38 <xTaskResumeAll+0xac>
						uxPendedTicks = 0;
  401c46:	2200      	movs	r2, #0
  401c48:	4b16      	ldr	r3, [pc, #88]	; (401ca4 <xTaskResumeAll+0x118>)
  401c4a:	601a      	str	r2, [r3, #0]
				if( xYieldPending != pdFALSE )
  401c4c:	4b13      	ldr	r3, [pc, #76]	; (401c9c <xTaskResumeAll+0x110>)
  401c4e:	681b      	ldr	r3, [r3, #0]
  401c50:	b15b      	cbz	r3, 401c6a <xTaskResumeAll+0xde>
					taskYIELD_IF_USING_PREEMPTION();
  401c52:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401c56:	4b15      	ldr	r3, [pc, #84]	; (401cac <xTaskResumeAll+0x120>)
  401c58:	601a      	str	r2, [r3, #0]
  401c5a:	f3bf 8f4f 	dsb	sy
  401c5e:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
  401c62:	2401      	movs	r4, #1
  401c64:	e7ad      	b.n	401bc2 <xTaskResumeAll+0x36>
BaseType_t xAlreadyYielded = pdFALSE;
  401c66:	2400      	movs	r4, #0
  401c68:	e7ab      	b.n	401bc2 <xTaskResumeAll+0x36>
  401c6a:	2400      	movs	r4, #0
  401c6c:	e7a9      	b.n	401bc2 <xTaskResumeAll+0x36>
  401c6e:	bf00      	nop
  401c70:	2000a4f8 	.word	0x2000a4f8
  401c74:	004008a5 	.word	0x004008a5
  401c78:	2000a4ec 	.word	0x2000a4ec
  401c7c:	004008e9 	.word	0x004008e9
  401c80:	2000a538 	.word	0x2000a538
  401c84:	004007d9 	.word	0x004007d9
  401c88:	00403485 	.word	0x00403485
  401c8c:	2000a500 	.word	0x2000a500
  401c90:	2000a488 	.word	0x2000a488
  401c94:	0040078d 	.word	0x0040078d
  401c98:	2000a47c 	.word	0x2000a47c
  401c9c:	2000a57c 	.word	0x2000a57c
  401ca0:	0040164d 	.word	0x0040164d
  401ca4:	2000a4f4 	.word	0x2000a4f4
  401ca8:	00401a11 	.word	0x00401a11
  401cac:	e000ed04 	.word	0xe000ed04
  401cb0:	00402825 	.word	0x00402825

00401cb4 <vTaskDelay>:
	{
  401cb4:	b570      	push	{r4, r5, r6, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
  401cb6:	b318      	cbz	r0, 401d00 <vTaskDelay+0x4c>
  401cb8:	4604      	mov	r4, r0
			configASSERT( uxSchedulerSuspended == 0 );
  401cba:	4b16      	ldr	r3, [pc, #88]	; (401d14 <vTaskDelay+0x60>)
  401cbc:	681b      	ldr	r3, [r3, #0]
  401cbe:	b143      	cbz	r3, 401cd2 <vTaskDelay+0x1e>
  401cc0:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  401cc4:	f383 8811 	msr	BASEPRI, r3
  401cc8:	f3bf 8f6f 	isb	sy
  401ccc:	f3bf 8f4f 	dsb	sy
  401cd0:	e7fe      	b.n	401cd0 <vTaskDelay+0x1c>
			vTaskSuspendAll();
  401cd2:	4b11      	ldr	r3, [pc, #68]	; (401d18 <vTaskDelay+0x64>)
  401cd4:	4798      	blx	r3
				traceTASK_DELAY();
  401cd6:	4621      	mov	r1, r4
  401cd8:	2089      	movs	r0, #137	; 0x89
  401cda:	4b10      	ldr	r3, [pc, #64]	; (401d1c <vTaskDelay+0x68>)
  401cdc:	4798      	blx	r3
  401cde:	4b10      	ldr	r3, [pc, #64]	; (401d20 <vTaskDelay+0x6c>)
  401ce0:	6818      	ldr	r0, [r3, #0]
  401ce2:	4e10      	ldr	r6, [pc, #64]	; (401d24 <vTaskDelay+0x70>)
  401ce4:	47b0      	blx	r6
  401ce6:	4d10      	ldr	r5, [pc, #64]	; (401d28 <vTaskDelay+0x74>)
  401ce8:	47a8      	blx	r5
  401cea:	4b10      	ldr	r3, [pc, #64]	; (401d2c <vTaskDelay+0x78>)
  401cec:	4798      	blx	r3
  401cee:	47b0      	blx	r6
  401cf0:	47a8      	blx	r5
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
  401cf2:	2100      	movs	r1, #0
  401cf4:	4620      	mov	r0, r4
  401cf6:	4b0e      	ldr	r3, [pc, #56]	; (401d30 <vTaskDelay+0x7c>)
  401cf8:	4798      	blx	r3
			xAlreadyYielded = xTaskResumeAll();
  401cfa:	4b0e      	ldr	r3, [pc, #56]	; (401d34 <vTaskDelay+0x80>)
  401cfc:	4798      	blx	r3
		if( xAlreadyYielded == pdFALSE )
  401cfe:	b938      	cbnz	r0, 401d10 <vTaskDelay+0x5c>
			portYIELD_WITHIN_API();
  401d00:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401d04:	4b0c      	ldr	r3, [pc, #48]	; (401d38 <vTaskDelay+0x84>)
  401d06:	601a      	str	r2, [r3, #0]
  401d08:	f3bf 8f4f 	dsb	sy
  401d0c:	f3bf 8f6f 	isb	sy
  401d10:	bd70      	pop	{r4, r5, r6, pc}
  401d12:	bf00      	nop
  401d14:	2000a4f8 	.word	0x2000a4f8
  401d18:	004019f5 	.word	0x004019f5
  401d1c:	00403821 	.word	0x00403821
  401d20:	2000a47c 	.word	0x2000a47c
  401d24:	00402825 	.word	0x00402825
  401d28:	00403045 	.word	0x00403045
  401d2c:	004027fd 	.word	0x004027fd
  401d30:	00401679 	.word	0x00401679
  401d34:	00401b8d 	.word	0x00401b8d
  401d38:	e000ed04 	.word	0xe000ed04

00401d3c <prvIdleTask>:
{
  401d3c:	b580      	push	{r7, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  401d3e:	4d1a      	ldr	r5, [pc, #104]	; (401da8 <prvIdleTask+0x6c>)
			vTaskSuspendAll();
  401d40:	f8df 8088 	ldr.w	r8, [pc, #136]	; 401dcc <prvIdleTask+0x90>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  401d44:	4f19      	ldr	r7, [pc, #100]	; (401dac <prvIdleTask+0x70>)
				taskYIELD();
  401d46:	f8df 9088 	ldr.w	r9, [pc, #136]	; 401dd0 <prvIdleTask+0x94>
  401d4a:	e00d      	b.n	401d68 <prvIdleTask+0x2c>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
  401d4c:	4b18      	ldr	r3, [pc, #96]	; (401db0 <prvIdleTask+0x74>)
  401d4e:	681b      	ldr	r3, [r3, #0]
  401d50:	2b01      	cmp	r3, #1
  401d52:	d907      	bls.n	401d64 <prvIdleTask+0x28>
				taskYIELD();
  401d54:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  401d58:	f8c9 3000 	str.w	r3, [r9]
  401d5c:	f3bf 8f4f 	dsb	sy
  401d60:	f3bf 8f6f 	isb	sy
			vApplicationIdleHook();
  401d64:	4b13      	ldr	r3, [pc, #76]	; (401db4 <prvIdleTask+0x78>)
  401d66:	4798      	blx	r3
			( void ) xTaskResumeAll();
  401d68:	4e13      	ldr	r6, [pc, #76]	; (401db8 <prvIdleTask+0x7c>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  401d6a:	682b      	ldr	r3, [r5, #0]
  401d6c:	2b00      	cmp	r3, #0
  401d6e:	d0ed      	beq.n	401d4c <prvIdleTask+0x10>
			vTaskSuspendAll();
  401d70:	47c0      	blx	r8
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  401d72:	683c      	ldr	r4, [r7, #0]
			( void ) xTaskResumeAll();
  401d74:	47b0      	blx	r6
			if( xListIsEmpty == pdFALSE )
  401d76:	2c00      	cmp	r4, #0
  401d78:	d0f7      	beq.n	401d6a <prvIdleTask+0x2e>
				taskENTER_CRITICAL();
  401d7a:	4b10      	ldr	r3, [pc, #64]	; (401dbc <prvIdleTask+0x80>)
  401d7c:	4798      	blx	r3
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
  401d7e:	68fb      	ldr	r3, [r7, #12]
  401d80:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  401d82:	1d20      	adds	r0, r4, #4
  401d84:	4b0e      	ldr	r3, [pc, #56]	; (401dc0 <prvIdleTask+0x84>)
  401d86:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
  401d88:	4a0e      	ldr	r2, [pc, #56]	; (401dc4 <prvIdleTask+0x88>)
  401d8a:	6813      	ldr	r3, [r2, #0]
  401d8c:	3b01      	subs	r3, #1
  401d8e:	6013      	str	r3, [r2, #0]
					--uxDeletedTasksWaitingCleanUp;
  401d90:	682b      	ldr	r3, [r5, #0]
  401d92:	3b01      	subs	r3, #1
  401d94:	602b      	str	r3, [r5, #0]
				taskEXIT_CRITICAL();
  401d96:	4b0c      	ldr	r3, [pc, #48]	; (401dc8 <prvIdleTask+0x8c>)
  401d98:	4798      	blx	r3
			vPortFree( pxTCB->pxStack );
  401d9a:	6b20      	ldr	r0, [r4, #48]	; 0x30
  401d9c:	f8df a034 	ldr.w	sl, [pc, #52]	; 401dd4 <prvIdleTask+0x98>
  401da0:	47d0      	blx	sl
			vPortFree( pxTCB );
  401da2:	4620      	mov	r0, r4
  401da4:	47d0      	blx	sl
  401da6:	e7e0      	b.n	401d6a <prvIdleTask+0x2e>
  401da8:	2000a4f0 	.word	0x2000a4f0
  401dac:	2000a564 	.word	0x2000a564
  401db0:	2000a488 	.word	0x2000a488
  401db4:	00403d17 	.word	0x00403d17
  401db8:	00401b8d 	.word	0x00401b8d
  401dbc:	004008a5 	.word	0x004008a5
  401dc0:	004007d9 	.word	0x004007d9
  401dc4:	2000a4ec 	.word	0x2000a4ec
  401dc8:	004008e9 	.word	0x004008e9
  401dcc:	004019f5 	.word	0x004019f5
  401dd0:	e000ed04 	.word	0xe000ed04
  401dd4:	004006e9 	.word	0x004006e9

00401dd8 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
  401dd8:	4b2e      	ldr	r3, [pc, #184]	; (401e94 <vTaskSwitchContext+0xbc>)
  401dda:	681b      	ldr	r3, [r3, #0]
  401ddc:	bb53      	cbnz	r3, 401e34 <vTaskSwitchContext+0x5c>
{
  401dde:	b510      	push	{r4, lr}
		xYieldPending = pdFALSE;
  401de0:	2200      	movs	r2, #0
  401de2:	4b2d      	ldr	r3, [pc, #180]	; (401e98 <vTaskSwitchContext+0xc0>)
  401de4:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
  401de6:	4b2d      	ldr	r3, [pc, #180]	; (401e9c <vTaskSwitchContext+0xc4>)
  401de8:	681b      	ldr	r3, [r3, #0]
  401dea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401dec:	681a      	ldr	r2, [r3, #0]
  401dee:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
  401df2:	d103      	bne.n	401dfc <vTaskSwitchContext+0x24>
  401df4:	685a      	ldr	r2, [r3, #4]
  401df6:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
  401dfa:	d01f      	beq.n	401e3c <vTaskSwitchContext+0x64>
  401dfc:	4b27      	ldr	r3, [pc, #156]	; (401e9c <vTaskSwitchContext+0xc4>)
  401dfe:	6818      	ldr	r0, [r3, #0]
  401e00:	6819      	ldr	r1, [r3, #0]
  401e02:	3134      	adds	r1, #52	; 0x34
  401e04:	4b26      	ldr	r3, [pc, #152]	; (401ea0 <vTaskSwitchContext+0xc8>)
  401e06:	4798      	blx	r3
		taskSELECT_HIGHEST_PRIORITY_TASK();
  401e08:	4b26      	ldr	r3, [pc, #152]	; (401ea4 <vTaskSwitchContext+0xcc>)
  401e0a:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
  401e0c:	fab3 f383 	clz	r3, r3
  401e10:	b2db      	uxtb	r3, r3
  401e12:	f1c3 031f 	rsb	r3, r3, #31
  401e16:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  401e1a:	4a23      	ldr	r2, [pc, #140]	; (401ea8 <vTaskSwitchContext+0xd0>)
  401e1c:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  401e20:	b9aa      	cbnz	r2, 401e4e <vTaskSwitchContext+0x76>
	__asm volatile
  401e22:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  401e26:	f383 8811 	msr	BASEPRI, r3
  401e2a:	f3bf 8f6f 	isb	sy
  401e2e:	f3bf 8f4f 	dsb	sy
  401e32:	e7fe      	b.n	401e32 <vTaskSwitchContext+0x5a>
		xYieldPending = pdTRUE;
  401e34:	2201      	movs	r2, #1
  401e36:	4b18      	ldr	r3, [pc, #96]	; (401e98 <vTaskSwitchContext+0xc0>)
  401e38:	601a      	str	r2, [r3, #0]
  401e3a:	4770      	bx	lr
		taskCHECK_FOR_STACK_OVERFLOW();
  401e3c:	689a      	ldr	r2, [r3, #8]
  401e3e:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
  401e42:	d1db      	bne.n	401dfc <vTaskSwitchContext+0x24>
  401e44:	68db      	ldr	r3, [r3, #12]
  401e46:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
  401e4a:	d1d7      	bne.n	401dfc <vTaskSwitchContext+0x24>
  401e4c:	e7dc      	b.n	401e08 <vTaskSwitchContext+0x30>
		taskSELECT_HIGHEST_PRIORITY_TASK();
  401e4e:	4a16      	ldr	r2, [pc, #88]	; (401ea8 <vTaskSwitchContext+0xd0>)
  401e50:	0099      	lsls	r1, r3, #2
  401e52:	18c8      	adds	r0, r1, r3
  401e54:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  401e58:	6844      	ldr	r4, [r0, #4]
  401e5a:	6864      	ldr	r4, [r4, #4]
  401e5c:	6044      	str	r4, [r0, #4]
  401e5e:	4419      	add	r1, r3
  401e60:	4602      	mov	r2, r0
  401e62:	3208      	adds	r2, #8
  401e64:	4294      	cmp	r4, r2
  401e66:	d00f      	beq.n	401e88 <vTaskSwitchContext+0xb0>
  401e68:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  401e6c:	4a0e      	ldr	r2, [pc, #56]	; (401ea8 <vTaskSwitchContext+0xd0>)
  401e6e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401e72:	685b      	ldr	r3, [r3, #4]
  401e74:	68da      	ldr	r2, [r3, #12]
  401e76:	4b09      	ldr	r3, [pc, #36]	; (401e9c <vTaskSwitchContext+0xc4>)
  401e78:	601a      	str	r2, [r3, #0]
		traceTASK_SWITCHED_IN();
  401e7a:	4b0c      	ldr	r3, [pc, #48]	; (401eac <vTaskSwitchContext+0xd4>)
  401e7c:	4798      	blx	r3
  401e7e:	4b0c      	ldr	r3, [pc, #48]	; (401eb0 <vTaskSwitchContext+0xd8>)
  401e80:	4798      	blx	r3
  401e82:	4b0c      	ldr	r3, [pc, #48]	; (401eb4 <vTaskSwitchContext+0xdc>)
  401e84:	4798      	blx	r3
  401e86:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
  401e88:	6860      	ldr	r0, [r4, #4]
  401e8a:	4a07      	ldr	r2, [pc, #28]	; (401ea8 <vTaskSwitchContext+0xd0>)
  401e8c:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  401e90:	6050      	str	r0, [r2, #4]
  401e92:	e7e9      	b.n	401e68 <vTaskSwitchContext+0x90>
  401e94:	2000a4f8 	.word	0x2000a4f8
  401e98:	2000a57c 	.word	0x2000a57c
  401e9c:	2000a47c 	.word	0x2000a47c
  401ea0:	00403d19 	.word	0x00403d19
  401ea4:	2000a500 	.word	0x2000a500
  401ea8:	2000a488 	.word	0x2000a488
  401eac:	004027fd 	.word	0x004027fd
  401eb0:	00402825 	.word	0x00402825
  401eb4:	004038ed 	.word	0x004038ed

00401eb8 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
  401eb8:	b940      	cbnz	r0, 401ecc <vTaskPlaceOnEventList+0x14>
  401eba:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  401ebe:	f383 8811 	msr	BASEPRI, r3
  401ec2:	f3bf 8f6f 	isb	sy
  401ec6:	f3bf 8f4f 	dsb	sy
  401eca:	e7fe      	b.n	401eca <vTaskPlaceOnEventList+0x12>
{
  401ecc:	b510      	push	{r4, lr}
  401ece:	460c      	mov	r4, r1
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  401ed0:	4b04      	ldr	r3, [pc, #16]	; (401ee4 <vTaskPlaceOnEventList+0x2c>)
  401ed2:	6819      	ldr	r1, [r3, #0]
  401ed4:	3118      	adds	r1, #24
  401ed6:	4b04      	ldr	r3, [pc, #16]	; (401ee8 <vTaskPlaceOnEventList+0x30>)
  401ed8:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  401eda:	2101      	movs	r1, #1
  401edc:	4620      	mov	r0, r4
  401ede:	4b03      	ldr	r3, [pc, #12]	; (401eec <vTaskPlaceOnEventList+0x34>)
  401ee0:	4798      	blx	r3
  401ee2:	bd10      	pop	{r4, pc}
  401ee4:	2000a47c 	.word	0x2000a47c
  401ee8:	004007a5 	.word	0x004007a5
  401eec:	00401679 	.word	0x00401679

00401ef0 <vTaskPlaceOnEventListRestricted>:
	{
  401ef0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( pxEventList );
  401ef2:	b1f8      	cbz	r0, 401f34 <vTaskPlaceOnEventListRestricted+0x44>
  401ef4:	460c      	mov	r4, r1
  401ef6:	4615      	mov	r5, r2
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  401ef8:	4a13      	ldr	r2, [pc, #76]	; (401f48 <vTaskPlaceOnEventListRestricted+0x58>)
  401efa:	6811      	ldr	r1, [r2, #0]
  401efc:	3118      	adds	r1, #24
  401efe:	4b13      	ldr	r3, [pc, #76]	; (401f4c <vTaskPlaceOnEventListRestricted+0x5c>)
  401f00:	4798      	blx	r3
			xTicksToWait = portMAX_DELAY;
  401f02:	2d00      	cmp	r5, #0
  401f04:	bf18      	it	ne
  401f06:	f04f 34ff 	movne.w	r4, #4294967295
		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
  401f0a:	4b11      	ldr	r3, [pc, #68]	; (401f50 <vTaskPlaceOnEventListRestricted+0x60>)
  401f0c:	6819      	ldr	r1, [r3, #0]
  401f0e:	4421      	add	r1, r4
  401f10:	2088      	movs	r0, #136	; 0x88
  401f12:	4b10      	ldr	r3, [pc, #64]	; (401f54 <vTaskPlaceOnEventListRestricted+0x64>)
  401f14:	4798      	blx	r3
  401f16:	4b0c      	ldr	r3, [pc, #48]	; (401f48 <vTaskPlaceOnEventListRestricted+0x58>)
  401f18:	6818      	ldr	r0, [r3, #0]
  401f1a:	4f0f      	ldr	r7, [pc, #60]	; (401f58 <vTaskPlaceOnEventListRestricted+0x68>)
  401f1c:	47b8      	blx	r7
  401f1e:	4e0f      	ldr	r6, [pc, #60]	; (401f5c <vTaskPlaceOnEventListRestricted+0x6c>)
  401f20:	47b0      	blx	r6
  401f22:	4b0f      	ldr	r3, [pc, #60]	; (401f60 <vTaskPlaceOnEventListRestricted+0x70>)
  401f24:	4798      	blx	r3
  401f26:	47b8      	blx	r7
  401f28:	47b0      	blx	r6
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
  401f2a:	4629      	mov	r1, r5
  401f2c:	4620      	mov	r0, r4
  401f2e:	4b0d      	ldr	r3, [pc, #52]	; (401f64 <vTaskPlaceOnEventListRestricted+0x74>)
  401f30:	4798      	blx	r3
  401f32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401f34:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  401f38:	f383 8811 	msr	BASEPRI, r3
  401f3c:	f3bf 8f6f 	isb	sy
  401f40:	f3bf 8f4f 	dsb	sy
  401f44:	e7fe      	b.n	401f44 <vTaskPlaceOnEventListRestricted+0x54>
  401f46:	bf00      	nop
  401f48:	2000a47c 	.word	0x2000a47c
  401f4c:	0040078d 	.word	0x0040078d
  401f50:	2000a578 	.word	0x2000a578
  401f54:	00403821 	.word	0x00403821
  401f58:	00402825 	.word	0x00402825
  401f5c:	00403045 	.word	0x00403045
  401f60:	004027fd 	.word	0x004027fd
  401f64:	00401679 	.word	0x00401679

00401f68 <xTaskRemoveFromEventList>:
{
  401f68:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  401f6a:	68c3      	ldr	r3, [r0, #12]
  401f6c:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
  401f6e:	2c00      	cmp	r4, #0
  401f70:	d02b      	beq.n	401fca <xTaskRemoveFromEventList+0x62>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  401f72:	f104 0518 	add.w	r5, r4, #24
  401f76:	4628      	mov	r0, r5
  401f78:	4b1b      	ldr	r3, [pc, #108]	; (401fe8 <xTaskRemoveFromEventList+0x80>)
  401f7a:	4798      	blx	r3
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  401f7c:	4b1b      	ldr	r3, [pc, #108]	; (401fec <xTaskRemoveFromEventList+0x84>)
  401f7e:	681b      	ldr	r3, [r3, #0]
  401f80:	2b00      	cmp	r3, #0
  401f82:	d12b      	bne.n	401fdc <xTaskRemoveFromEventList+0x74>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  401f84:	1d25      	adds	r5, r4, #4
  401f86:	4628      	mov	r0, r5
  401f88:	4b17      	ldr	r3, [pc, #92]	; (401fe8 <xTaskRemoveFromEventList+0x80>)
  401f8a:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
  401f8c:	4620      	mov	r0, r4
  401f8e:	4b18      	ldr	r3, [pc, #96]	; (401ff0 <xTaskRemoveFromEventList+0x88>)
  401f90:	4798      	blx	r3
  401f92:	4b18      	ldr	r3, [pc, #96]	; (401ff4 <xTaskRemoveFromEventList+0x8c>)
  401f94:	4798      	blx	r3
  401f96:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  401f98:	4a17      	ldr	r2, [pc, #92]	; (401ff8 <xTaskRemoveFromEventList+0x90>)
  401f9a:	6811      	ldr	r1, [r2, #0]
  401f9c:	2301      	movs	r3, #1
  401f9e:	4083      	lsls	r3, r0
  401fa0:	430b      	orrs	r3, r1
  401fa2:	6013      	str	r3, [r2, #0]
  401fa4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  401fa8:	4629      	mov	r1, r5
  401faa:	4b14      	ldr	r3, [pc, #80]	; (401ffc <xTaskRemoveFromEventList+0x94>)
  401fac:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  401fb0:	4b13      	ldr	r3, [pc, #76]	; (402000 <xTaskRemoveFromEventList+0x98>)
  401fb2:	4798      	blx	r3
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  401fb4:	4b13      	ldr	r3, [pc, #76]	; (402004 <xTaskRemoveFromEventList+0x9c>)
  401fb6:	681b      	ldr	r3, [r3, #0]
  401fb8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  401fba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401fbc:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
  401fbe:	bf83      	ittte	hi
  401fc0:	2001      	movhi	r0, #1
  401fc2:	4b11      	ldrhi	r3, [pc, #68]	; (402008 <xTaskRemoveFromEventList+0xa0>)
  401fc4:	6018      	strhi	r0, [r3, #0]
		xReturn = pdFALSE;
  401fc6:	2000      	movls	r0, #0
}
  401fc8:	bd38      	pop	{r3, r4, r5, pc}
  401fca:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  401fce:	f383 8811 	msr	BASEPRI, r3
  401fd2:	f3bf 8f6f 	isb	sy
  401fd6:	f3bf 8f4f 	dsb	sy
  401fda:	e7fe      	b.n	401fda <xTaskRemoveFromEventList+0x72>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  401fdc:	4629      	mov	r1, r5
  401fde:	480b      	ldr	r0, [pc, #44]	; (40200c <xTaskRemoveFromEventList+0xa4>)
  401fe0:	4b07      	ldr	r3, [pc, #28]	; (402000 <xTaskRemoveFromEventList+0x98>)
  401fe2:	4798      	blx	r3
  401fe4:	e7e6      	b.n	401fb4 <xTaskRemoveFromEventList+0x4c>
  401fe6:	bf00      	nop
  401fe8:	004007d9 	.word	0x004007d9
  401fec:	2000a4f8 	.word	0x2000a4f8
  401ff0:	00402825 	.word	0x00402825
  401ff4:	00403485 	.word	0x00403485
  401ff8:	2000a500 	.word	0x2000a500
  401ffc:	2000a488 	.word	0x2000a488
  402000:	0040078d 	.word	0x0040078d
  402004:	2000a47c 	.word	0x2000a47c
  402008:	2000a57c 	.word	0x2000a57c
  40200c:	2000a538 	.word	0x2000a538

00402010 <vTaskSetTimeOutState>:
	configASSERT( pxTimeOut );
  402010:	b130      	cbz	r0, 402020 <vTaskSetTimeOutState+0x10>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  402012:	4a08      	ldr	r2, [pc, #32]	; (402034 <vTaskSetTimeOutState+0x24>)
  402014:	6812      	ldr	r2, [r2, #0]
  402016:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  402018:	4a07      	ldr	r2, [pc, #28]	; (402038 <vTaskSetTimeOutState+0x28>)
  40201a:	6812      	ldr	r2, [r2, #0]
  40201c:	6042      	str	r2, [r0, #4]
  40201e:	4770      	bx	lr
  402020:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  402024:	f383 8811 	msr	BASEPRI, r3
  402028:	f3bf 8f6f 	isb	sy
  40202c:	f3bf 8f4f 	dsb	sy
  402030:	e7fe      	b.n	402030 <vTaskSetTimeOutState+0x20>
  402032:	bf00      	nop
  402034:	2000a534 	.word	0x2000a534
  402038:	2000a578 	.word	0x2000a578

0040203c <xTaskCheckForTimeOut>:
{
  40203c:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxTimeOut );
  40203e:	b1c0      	cbz	r0, 402072 <xTaskCheckForTimeOut+0x36>
  402040:	4604      	mov	r4, r0
	configASSERT( pxTicksToWait );
  402042:	b1f9      	cbz	r1, 402084 <xTaskCheckForTimeOut+0x48>
  402044:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
  402046:	4b1b      	ldr	r3, [pc, #108]	; (4020b4 <xTaskCheckForTimeOut+0x78>)
  402048:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
  40204a:	4b1b      	ldr	r3, [pc, #108]	; (4020b8 <xTaskCheckForTimeOut+0x7c>)
  40204c:	681a      	ldr	r2, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
  40204e:	682b      	ldr	r3, [r5, #0]
  402050:	f1b3 3fff 	cmp.w	r3, #4294967295
  402054:	d02a      	beq.n	4020ac <xTaskCheckForTimeOut+0x70>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  402056:	4919      	ldr	r1, [pc, #100]	; (4020bc <xTaskCheckForTimeOut+0x80>)
  402058:	6809      	ldr	r1, [r1, #0]
  40205a:	6820      	ldr	r0, [r4, #0]
  40205c:	4288      	cmp	r0, r1
  40205e:	d002      	beq.n	402066 <xTaskCheckForTimeOut+0x2a>
  402060:	6861      	ldr	r1, [r4, #4]
  402062:	428a      	cmp	r2, r1
  402064:	d224      	bcs.n	4020b0 <xTaskCheckForTimeOut+0x74>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
  402066:	6861      	ldr	r1, [r4, #4]
  402068:	1a50      	subs	r0, r2, r1
  40206a:	4283      	cmp	r3, r0
  40206c:	d813      	bhi.n	402096 <xTaskCheckForTimeOut+0x5a>
			xReturn = pdTRUE;
  40206e:	2401      	movs	r4, #1
  402070:	e018      	b.n	4020a4 <xTaskCheckForTimeOut+0x68>
  402072:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  402076:	f383 8811 	msr	BASEPRI, r3
  40207a:	f3bf 8f6f 	isb	sy
  40207e:	f3bf 8f4f 	dsb	sy
  402082:	e7fe      	b.n	402082 <xTaskCheckForTimeOut+0x46>
  402084:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  402088:	f383 8811 	msr	BASEPRI, r3
  40208c:	f3bf 8f6f 	isb	sy
  402090:	f3bf 8f4f 	dsb	sy
  402094:	e7fe      	b.n	402094 <xTaskCheckForTimeOut+0x58>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
  402096:	1a9b      	subs	r3, r3, r2
  402098:	440b      	add	r3, r1
  40209a:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
  40209c:	4620      	mov	r0, r4
  40209e:	4b08      	ldr	r3, [pc, #32]	; (4020c0 <xTaskCheckForTimeOut+0x84>)
  4020a0:	4798      	blx	r3
			xReturn = pdFALSE;
  4020a2:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
  4020a4:	4b07      	ldr	r3, [pc, #28]	; (4020c4 <xTaskCheckForTimeOut+0x88>)
  4020a6:	4798      	blx	r3
}
  4020a8:	4620      	mov	r0, r4
  4020aa:	bd38      	pop	{r3, r4, r5, pc}
				xReturn = pdFALSE;
  4020ac:	2400      	movs	r4, #0
  4020ae:	e7f9      	b.n	4020a4 <xTaskCheckForTimeOut+0x68>
			xReturn = pdTRUE;
  4020b0:	2401      	movs	r4, #1
  4020b2:	e7f7      	b.n	4020a4 <xTaskCheckForTimeOut+0x68>
  4020b4:	004008a5 	.word	0x004008a5
  4020b8:	2000a578 	.word	0x2000a578
  4020bc:	2000a534 	.word	0x2000a534
  4020c0:	00402011 	.word	0x00402011
  4020c4:	004008e9 	.word	0x004008e9

004020c8 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
  4020c8:	2201      	movs	r2, #1
  4020ca:	4b01      	ldr	r3, [pc, #4]	; (4020d0 <vTaskMissedYield+0x8>)
  4020cc:	601a      	str	r2, [r3, #0]
  4020ce:	4770      	bx	lr
  4020d0:	2000a57c 	.word	0x2000a57c

004020d4 <uxTaskGetTaskNumber>:
		if( xTask != NULL )
  4020d4:	b108      	cbz	r0, 4020da <uxTaskGetTaskNumber+0x6>
			uxReturn = pxTCB->uxTaskNumber;
  4020d6:	6c40      	ldr	r0, [r0, #68]	; 0x44
  4020d8:	4770      	bx	lr
			uxReturn = 0U;
  4020da:	2000      	movs	r0, #0
	}
  4020dc:	4770      	bx	lr
	...

004020e0 <xTaskGetCurrentTaskHandle>:
		xReturn = pxCurrentTCB;
  4020e0:	4b01      	ldr	r3, [pc, #4]	; (4020e8 <xTaskGetCurrentTaskHandle+0x8>)
  4020e2:	6818      	ldr	r0, [r3, #0]
	}
  4020e4:	4770      	bx	lr
  4020e6:	bf00      	nop
  4020e8:	2000a47c 	.word	0x2000a47c

004020ec <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
  4020ec:	4b05      	ldr	r3, [pc, #20]	; (402104 <xTaskGetSchedulerState+0x18>)
  4020ee:	681b      	ldr	r3, [r3, #0]
  4020f0:	b133      	cbz	r3, 402100 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  4020f2:	4b05      	ldr	r3, [pc, #20]	; (402108 <xTaskGetSchedulerState+0x1c>)
  4020f4:	681b      	ldr	r3, [r3, #0]
				xReturn = taskSCHEDULER_SUSPENDED;
  4020f6:	2b00      	cmp	r3, #0
  4020f8:	bf0c      	ite	eq
  4020fa:	2002      	moveq	r0, #2
  4020fc:	2000      	movne	r0, #0
  4020fe:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
  402100:	2001      	movs	r0, #1
	}
  402102:	4770      	bx	lr
  402104:	2000a54c 	.word	0x2000a54c
  402108:	2000a4f8 	.word	0x2000a4f8

0040210c <vTaskPriorityInherit>:
		if( pxMutexHolder != NULL )
  40210c:	2800      	cmp	r0, #0
  40210e:	d064      	beq.n	4021da <vTaskPriorityInherit+0xce>
	{
  402110:	b570      	push	{r4, r5, r6, lr}
  402112:	4604      	mov	r4, r0
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  402114:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  402116:	4a31      	ldr	r2, [pc, #196]	; (4021dc <vTaskPriorityInherit+0xd0>)
  402118:	6812      	ldr	r2, [r2, #0]
  40211a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  40211c:	4293      	cmp	r3, r2
  40211e:	d22e      	bcs.n	40217e <vTaskPriorityInherit+0x72>
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  402120:	6982      	ldr	r2, [r0, #24]
  402122:	2a00      	cmp	r2, #0
  402124:	db05      	blt.n	402132 <vTaskPriorityInherit+0x26>
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  402126:	4a2d      	ldr	r2, [pc, #180]	; (4021dc <vTaskPriorityInherit+0xd0>)
  402128:	6812      	ldr	r2, [r2, #0]
  40212a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  40212c:	f1c2 0205 	rsb	r2, r2, #5
  402130:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  402132:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  402136:	4a2a      	ldr	r2, [pc, #168]	; (4021e0 <vTaskPriorityInherit+0xd4>)
  402138:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  40213c:	6962      	ldr	r2, [r4, #20]
  40213e:	429a      	cmp	r2, r3
  402140:	d01e      	beq.n	402180 <vTaskPriorityInherit+0x74>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  402142:	4b26      	ldr	r3, [pc, #152]	; (4021dc <vTaskPriorityInherit+0xd0>)
  402144:	681b      	ldr	r3, [r3, #0]
  402146:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402148:	62e3      	str	r3, [r4, #44]	; 0x2c
				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
  40214a:	4620      	mov	r0, r4
  40214c:	4d25      	ldr	r5, [pc, #148]	; (4021e4 <vTaskPriorityInherit+0xd8>)
  40214e:	47a8      	blx	r5
  402150:	4606      	mov	r6, r0
  402152:	4620      	mov	r0, r4
  402154:	47a8      	blx	r5
  402156:	4601      	mov	r1, r0
  402158:	2003      	movs	r0, #3
  40215a:	4b23      	ldr	r3, [pc, #140]	; (4021e8 <vTaskPriorityInherit+0xdc>)
  40215c:	4798      	blx	r3
  40215e:	4603      	mov	r3, r0
  402160:	4632      	mov	r2, r6
  402162:	2103      	movs	r1, #3
  402164:	208e      	movs	r0, #142	; 0x8e
  402166:	4e21      	ldr	r6, [pc, #132]	; (4021ec <vTaskPriorityInherit+0xe0>)
  402168:	47b0      	blx	r6
  40216a:	4620      	mov	r0, r4
  40216c:	47a8      	blx	r5
  40216e:	4b1b      	ldr	r3, [pc, #108]	; (4021dc <vTaskPriorityInherit+0xd0>)
  402170:	681b      	ldr	r3, [r3, #0]
  402172:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
  402176:	4601      	mov	r1, r0
  402178:	2003      	movs	r0, #3
  40217a:	4b1d      	ldr	r3, [pc, #116]	; (4021f0 <vTaskPriorityInherit+0xe4>)
  40217c:	4798      	blx	r3
  40217e:	bd70      	pop	{r4, r5, r6, pc}
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  402180:	1d25      	adds	r5, r4, #4
  402182:	4628      	mov	r0, r5
  402184:	4b1b      	ldr	r3, [pc, #108]	; (4021f4 <vTaskPriorityInherit+0xe8>)
  402186:	4798      	blx	r3
  402188:	b970      	cbnz	r0, 4021a8 <vTaskPriorityInherit+0x9c>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  40218a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  40218c:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  402190:	4a13      	ldr	r2, [pc, #76]	; (4021e0 <vTaskPriorityInherit+0xd4>)
  402192:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  402196:	b93a      	cbnz	r2, 4021a8 <vTaskPriorityInherit+0x9c>
  402198:	4817      	ldr	r0, [pc, #92]	; (4021f8 <vTaskPriorityInherit+0xec>)
  40219a:	6802      	ldr	r2, [r0, #0]
  40219c:	2101      	movs	r1, #1
  40219e:	fa01 f303 	lsl.w	r3, r1, r3
  4021a2:	ea22 0303 	bic.w	r3, r2, r3
  4021a6:	6003      	str	r3, [r0, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4021a8:	4b0c      	ldr	r3, [pc, #48]	; (4021dc <vTaskPriorityInherit+0xd0>)
  4021aa:	681b      	ldr	r3, [r3, #0]
  4021ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4021ae:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
  4021b0:	4620      	mov	r0, r4
  4021b2:	4b0c      	ldr	r3, [pc, #48]	; (4021e4 <vTaskPriorityInherit+0xd8>)
  4021b4:	4798      	blx	r3
  4021b6:	4b11      	ldr	r3, [pc, #68]	; (4021fc <vTaskPriorityInherit+0xf0>)
  4021b8:	4798      	blx	r3
  4021ba:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  4021bc:	4a0e      	ldr	r2, [pc, #56]	; (4021f8 <vTaskPriorityInherit+0xec>)
  4021be:	6811      	ldr	r1, [r2, #0]
  4021c0:	2301      	movs	r3, #1
  4021c2:	4083      	lsls	r3, r0
  4021c4:	430b      	orrs	r3, r1
  4021c6:	6013      	str	r3, [r2, #0]
  4021c8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4021cc:	4629      	mov	r1, r5
  4021ce:	4b04      	ldr	r3, [pc, #16]	; (4021e0 <vTaskPriorityInherit+0xd4>)
  4021d0:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  4021d4:	4b0a      	ldr	r3, [pc, #40]	; (402200 <vTaskPriorityInherit+0xf4>)
  4021d6:	4798      	blx	r3
  4021d8:	e7b7      	b.n	40214a <vTaskPriorityInherit+0x3e>
  4021da:	4770      	bx	lr
  4021dc:	2000a47c 	.word	0x2000a47c
  4021e0:	2000a488 	.word	0x2000a488
  4021e4:	00402825 	.word	0x00402825
  4021e8:	00402f91 	.word	0x00402f91
  4021ec:	0040370d 	.word	0x0040370d
  4021f0:	00402f39 	.word	0x00402f39
  4021f4:	004007d9 	.word	0x004007d9
  4021f8:	2000a500 	.word	0x2000a500
  4021fc:	00403485 	.word	0x00403485
  402200:	0040078d 	.word	0x0040078d

00402204 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
  402204:	2800      	cmp	r0, #0
  402206:	d067      	beq.n	4022d8 <xTaskPriorityDisinherit+0xd4>
	{
  402208:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40220a:	4604      	mov	r4, r0
			configASSERT( pxTCB == pxCurrentTCB );
  40220c:	4b35      	ldr	r3, [pc, #212]	; (4022e4 <xTaskPriorityDisinherit+0xe0>)
  40220e:	681b      	ldr	r3, [r3, #0]
  402210:	4298      	cmp	r0, r3
  402212:	d008      	beq.n	402226 <xTaskPriorityDisinherit+0x22>
  402214:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  402218:	f383 8811 	msr	BASEPRI, r3
  40221c:	f3bf 8f6f 	isb	sy
  402220:	f3bf 8f4f 	dsb	sy
  402224:	e7fe      	b.n	402224 <xTaskPriorityDisinherit+0x20>
			configASSERT( pxTCB->uxMutexesHeld );
  402226:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  402228:	b943      	cbnz	r3, 40223c <xTaskPriorityDisinherit+0x38>
  40222a:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  40222e:	f383 8811 	msr	BASEPRI, r3
  402232:	f3bf 8f6f 	isb	sy
  402236:	f3bf 8f4f 	dsb	sy
  40223a:	e7fe      	b.n	40223a <xTaskPriorityDisinherit+0x36>
			( pxTCB->uxMutexesHeld )--;
  40223c:	3b01      	subs	r3, #1
  40223e:	64c3      	str	r3, [r0, #76]	; 0x4c
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  402240:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  402242:	6c82      	ldr	r2, [r0, #72]	; 0x48
  402244:	4291      	cmp	r1, r2
  402246:	d049      	beq.n	4022dc <xTaskPriorityDisinherit+0xd8>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
  402248:	2b00      	cmp	r3, #0
  40224a:	d149      	bne.n	4022e0 <xTaskPriorityDisinherit+0xdc>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  40224c:	1d06      	adds	r6, r0, #4
  40224e:	4630      	mov	r0, r6
  402250:	4b25      	ldr	r3, [pc, #148]	; (4022e8 <xTaskPriorityDisinherit+0xe4>)
  402252:	4798      	blx	r3
  402254:	b968      	cbnz	r0, 402272 <xTaskPriorityDisinherit+0x6e>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  402256:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  402258:	eb01 0281 	add.w	r2, r1, r1, lsl #2
  40225c:	4b23      	ldr	r3, [pc, #140]	; (4022ec <xTaskPriorityDisinherit+0xe8>)
  40225e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  402262:	b933      	cbnz	r3, 402272 <xTaskPriorityDisinherit+0x6e>
  402264:	4822      	ldr	r0, [pc, #136]	; (4022f0 <xTaskPriorityDisinherit+0xec>)
  402266:	6803      	ldr	r3, [r0, #0]
  402268:	2201      	movs	r2, #1
  40226a:	408a      	lsls	r2, r1
  40226c:	ea23 0302 	bic.w	r3, r3, r2
  402270:	6003      	str	r3, [r0, #0]
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
  402272:	4620      	mov	r0, r4
  402274:	4d1f      	ldr	r5, [pc, #124]	; (4022f4 <xTaskPriorityDisinherit+0xf0>)
  402276:	47a8      	blx	r5
  402278:	4607      	mov	r7, r0
  40227a:	4620      	mov	r0, r4
  40227c:	47a8      	blx	r5
  40227e:	4601      	mov	r1, r0
  402280:	2003      	movs	r0, #3
  402282:	4b1d      	ldr	r3, [pc, #116]	; (4022f8 <xTaskPriorityDisinherit+0xf4>)
  402284:	4798      	blx	r3
  402286:	4603      	mov	r3, r0
  402288:	463a      	mov	r2, r7
  40228a:	2103      	movs	r1, #3
  40228c:	208f      	movs	r0, #143	; 0x8f
  40228e:	4f1b      	ldr	r7, [pc, #108]	; (4022fc <xTaskPriorityDisinherit+0xf8>)
  402290:	47b8      	blx	r7
  402292:	4620      	mov	r0, r4
  402294:	47a8      	blx	r5
  402296:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
  40229a:	4601      	mov	r1, r0
  40229c:	2003      	movs	r0, #3
  40229e:	4b18      	ldr	r3, [pc, #96]	; (402300 <xTaskPriorityDisinherit+0xfc>)
  4022a0:	4798      	blx	r3
					pxTCB->uxPriority = pxTCB->uxBasePriority;
  4022a2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4022a4:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  4022a6:	f1c3 0305 	rsb	r3, r3, #5
  4022aa:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
  4022ac:	4620      	mov	r0, r4
  4022ae:	47a8      	blx	r5
  4022b0:	4b14      	ldr	r3, [pc, #80]	; (402304 <xTaskPriorityDisinherit+0x100>)
  4022b2:	4798      	blx	r3
  4022b4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  4022b6:	4a0e      	ldr	r2, [pc, #56]	; (4022f0 <xTaskPriorityDisinherit+0xec>)
  4022b8:	6811      	ldr	r1, [r2, #0]
  4022ba:	2401      	movs	r4, #1
  4022bc:	fa04 f300 	lsl.w	r3, r4, r0
  4022c0:	430b      	orrs	r3, r1
  4022c2:	6013      	str	r3, [r2, #0]
  4022c4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4022c8:	4631      	mov	r1, r6
  4022ca:	4b08      	ldr	r3, [pc, #32]	; (4022ec <xTaskPriorityDisinherit+0xe8>)
  4022cc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  4022d0:	4b0d      	ldr	r3, [pc, #52]	; (402308 <xTaskPriorityDisinherit+0x104>)
  4022d2:	4798      	blx	r3
					xReturn = pdTRUE;
  4022d4:	4620      	mov	r0, r4
  4022d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	BaseType_t xReturn = pdFALSE;
  4022d8:	2000      	movs	r0, #0
  4022da:	4770      	bx	lr
  4022dc:	2000      	movs	r0, #0
  4022de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4022e0:	2000      	movs	r0, #0
	}
  4022e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4022e4:	2000a47c 	.word	0x2000a47c
  4022e8:	004007d9 	.word	0x004007d9
  4022ec:	2000a488 	.word	0x2000a488
  4022f0:	2000a500 	.word	0x2000a500
  4022f4:	00402825 	.word	0x00402825
  4022f8:	00402f91 	.word	0x00402f91
  4022fc:	0040370d 	.word	0x0040370d
  402300:	00402f39 	.word	0x00402f39
  402304:	00403485 	.word	0x00403485
  402308:	0040078d 	.word	0x0040078d

0040230c <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
  40230c:	4b05      	ldr	r3, [pc, #20]	; (402324 <pvTaskIncrementMutexHeldCount+0x18>)
  40230e:	681b      	ldr	r3, [r3, #0]
  402310:	b123      	cbz	r3, 40231c <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
  402312:	4b04      	ldr	r3, [pc, #16]	; (402324 <pvTaskIncrementMutexHeldCount+0x18>)
  402314:	681a      	ldr	r2, [r3, #0]
  402316:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
  402318:	3301      	adds	r3, #1
  40231a:	64d3      	str	r3, [r2, #76]	; 0x4c
		return pxCurrentTCB;
  40231c:	4b01      	ldr	r3, [pc, #4]	; (402324 <pvTaskIncrementMutexHeldCount+0x18>)
  40231e:	6818      	ldr	r0, [r3, #0]
	}
  402320:	4770      	bx	lr
  402322:	bf00      	nop
  402324:	2000a47c 	.word	0x2000a47c

00402328 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
  402328:	b508      	push	{r3, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  40232a:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  40232c:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
  40232e:	4291      	cmp	r1, r2
  402330:	d80c      	bhi.n	40234c <prvInsertTimerInActiveList+0x24>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  402332:	1ad2      	subs	r2, r2, r3
  402334:	6983      	ldr	r3, [r0, #24]
  402336:	429a      	cmp	r2, r3
  402338:	d301      	bcc.n	40233e <prvInsertTimerInActiveList+0x16>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
  40233a:	2001      	movs	r0, #1
  40233c:	bd08      	pop	{r3, pc}
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  40233e:	1d01      	adds	r1, r0, #4
  402340:	4b09      	ldr	r3, [pc, #36]	; (402368 <prvInsertTimerInActiveList+0x40>)
  402342:	6818      	ldr	r0, [r3, #0]
  402344:	4b09      	ldr	r3, [pc, #36]	; (40236c <prvInsertTimerInActiveList+0x44>)
  402346:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
  402348:	2000      	movs	r0, #0
  40234a:	bd08      	pop	{r3, pc}
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  40234c:	429a      	cmp	r2, r3
  40234e:	d201      	bcs.n	402354 <prvInsertTimerInActiveList+0x2c>
  402350:	4299      	cmp	r1, r3
  402352:	d206      	bcs.n	402362 <prvInsertTimerInActiveList+0x3a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  402354:	1d01      	adds	r1, r0, #4
  402356:	4b06      	ldr	r3, [pc, #24]	; (402370 <prvInsertTimerInActiveList+0x48>)
  402358:	6818      	ldr	r0, [r3, #0]
  40235a:	4b04      	ldr	r3, [pc, #16]	; (40236c <prvInsertTimerInActiveList+0x44>)
  40235c:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
  40235e:	2000      	movs	r0, #0
  402360:	bd08      	pop	{r3, pc}
			xProcessTimerNow = pdTRUE;
  402362:	2001      	movs	r0, #1
		}
	}

	return xProcessTimerNow;
}
  402364:	bd08      	pop	{r3, pc}
  402366:	bf00      	nop
  402368:	2000a584 	.word	0x2000a584
  40236c:	004007a5 	.word	0x004007a5
  402370:	2000a580 	.word	0x2000a580

00402374 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
  402374:	b570      	push	{r4, r5, r6, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
  402376:	4b0d      	ldr	r3, [pc, #52]	; (4023ac <prvCheckForValidListAndQueue+0x38>)
  402378:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
  40237a:	4b0d      	ldr	r3, [pc, #52]	; (4023b0 <prvCheckForValidListAndQueue+0x3c>)
  40237c:	681b      	ldr	r3, [r3, #0]
  40237e:	b113      	cbz	r3, 402386 <prvCheckForValidListAndQueue+0x12>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
  402380:	4b0c      	ldr	r3, [pc, #48]	; (4023b4 <prvCheckForValidListAndQueue+0x40>)
  402382:	4798      	blx	r3
  402384:	bd70      	pop	{r4, r5, r6, pc}
			vListInitialise( &xActiveTimerList1 );
  402386:	4d0c      	ldr	r5, [pc, #48]	; (4023b8 <prvCheckForValidListAndQueue+0x44>)
  402388:	4628      	mov	r0, r5
  40238a:	4e0c      	ldr	r6, [pc, #48]	; (4023bc <prvCheckForValidListAndQueue+0x48>)
  40238c:	47b0      	blx	r6
			vListInitialise( &xActiveTimerList2 );
  40238e:	4c0c      	ldr	r4, [pc, #48]	; (4023c0 <prvCheckForValidListAndQueue+0x4c>)
  402390:	4620      	mov	r0, r4
  402392:	47b0      	blx	r6
			pxCurrentTimerList = &xActiveTimerList1;
  402394:	4b0b      	ldr	r3, [pc, #44]	; (4023c4 <prvCheckForValidListAndQueue+0x50>)
  402396:	601d      	str	r5, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
  402398:	4b0b      	ldr	r3, [pc, #44]	; (4023c8 <prvCheckForValidListAndQueue+0x54>)
  40239a:	601c      	str	r4, [r3, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
  40239c:	2200      	movs	r2, #0
  40239e:	2110      	movs	r1, #16
  4023a0:	2005      	movs	r0, #5
  4023a2:	4b0a      	ldr	r3, [pc, #40]	; (4023cc <prvCheckForValidListAndQueue+0x58>)
  4023a4:	4798      	blx	r3
  4023a6:	4b02      	ldr	r3, [pc, #8]	; (4023b0 <prvCheckForValidListAndQueue+0x3c>)
  4023a8:	6018      	str	r0, [r3, #0]
  4023aa:	e7e9      	b.n	402380 <prvCheckForValidListAndQueue+0xc>
  4023ac:	004008a5 	.word	0x004008a5
  4023b0:	2000a5b4 	.word	0x2000a5b4
  4023b4:	004008e9 	.word	0x004008e9
  4023b8:	2000a588 	.word	0x2000a588
  4023bc:	00400771 	.word	0x00400771
  4023c0:	2000a59c 	.word	0x2000a59c
  4023c4:	2000a580 	.word	0x2000a580
  4023c8:	2000a584 	.word	0x2000a584
  4023cc:	00400da1 	.word	0x00400da1

004023d0 <xTimerCreateTimerTask>:
{
  4023d0:	b510      	push	{r4, lr}
  4023d2:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
  4023d4:	4b0d      	ldr	r3, [pc, #52]	; (40240c <xTimerCreateTimerTask+0x3c>)
  4023d6:	4798      	blx	r3
	if( xTimerQueue != NULL )
  4023d8:	4b0d      	ldr	r3, [pc, #52]	; (402410 <xTimerCreateTimerTask+0x40>)
  4023da:	681b      	ldr	r3, [r3, #0]
  4023dc:	b16b      	cbz	r3, 4023fa <xTimerCreateTimerTask+0x2a>
			xReturn = xTaskCreate(	prvTimerTask,
  4023de:	4b0d      	ldr	r3, [pc, #52]	; (402414 <xTimerCreateTimerTask+0x44>)
  4023e0:	9301      	str	r3, [sp, #4]
  4023e2:	2302      	movs	r3, #2
  4023e4:	9300      	str	r3, [sp, #0]
  4023e6:	2300      	movs	r3, #0
  4023e8:	f44f 7282 	mov.w	r2, #260	; 0x104
  4023ec:	490a      	ldr	r1, [pc, #40]	; (402418 <xTimerCreateTimerTask+0x48>)
  4023ee:	480b      	ldr	r0, [pc, #44]	; (40241c <xTimerCreateTimerTask+0x4c>)
  4023f0:	4c0b      	ldr	r4, [pc, #44]	; (402420 <xTimerCreateTimerTask+0x50>)
  4023f2:	47a0      	blx	r4
	configASSERT( xReturn );
  4023f4:	b108      	cbz	r0, 4023fa <xTimerCreateTimerTask+0x2a>
}
  4023f6:	b002      	add	sp, #8
  4023f8:	bd10      	pop	{r4, pc}
  4023fa:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  4023fe:	f383 8811 	msr	BASEPRI, r3
  402402:	f3bf 8f6f 	isb	sy
  402406:	f3bf 8f4f 	dsb	sy
  40240a:	e7fe      	b.n	40240a <xTimerCreateTimerTask+0x3a>
  40240c:	00402375 	.word	0x00402375
  402410:	2000a5b4 	.word	0x2000a5b4
  402414:	2000a5b8 	.word	0x2000a5b8
  402418:	004040f0 	.word	0x004040f0
  40241c:	00402601 	.word	0x00402601
  402420:	0040171d 	.word	0x0040171d

00402424 <xTimerGenericCommand>:
	configASSERT( xTimer );
  402424:	2800      	cmp	r0, #0
  402426:	d02e      	beq.n	402486 <xTimerGenericCommand+0x62>
{
  402428:	b5f0      	push	{r4, r5, r6, r7, lr}
  40242a:	b085      	sub	sp, #20
  40242c:	4617      	mov	r7, r2
  40242e:	4604      	mov	r4, r0
	if( xTimerQueue != NULL )
  402430:	4a3d      	ldr	r2, [pc, #244]	; (402528 <xTimerGenericCommand+0x104>)
  402432:	6810      	ldr	r0, [r2, #0]
  402434:	2800      	cmp	r0, #0
  402436:	d066      	beq.n	402506 <xTimerGenericCommand+0xe2>
  402438:	461a      	mov	r2, r3
  40243a:	460d      	mov	r5, r1
		xMessage.xMessageID = xCommandID;
  40243c:	9100      	str	r1, [sp, #0]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
  40243e:	9701      	str	r7, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
  402440:	9402      	str	r4, [sp, #8]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
  402442:	2905      	cmp	r1, #5
  402444:	dc28      	bgt.n	402498 <xTimerGenericCommand+0x74>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
  402446:	4b39      	ldr	r3, [pc, #228]	; (40252c <xTimerGenericCommand+0x108>)
  402448:	4798      	blx	r3
  40244a:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
  40244c:	f04f 0300 	mov.w	r3, #0
  402450:	bf0c      	ite	eq
  402452:	9a0a      	ldreq	r2, [sp, #40]	; 0x28
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  402454:	461a      	movne	r2, r3
  402456:	4669      	mov	r1, sp
  402458:	4833      	ldr	r0, [pc, #204]	; (402528 <xTimerGenericCommand+0x104>)
  40245a:	6800      	ldr	r0, [r0, #0]
  40245c:	4e34      	ldr	r6, [pc, #208]	; (402530 <xTimerGenericCommand+0x10c>)
  40245e:	47b0      	blx	r6
  402460:	4606      	mov	r6, r0
		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
  402462:	2d00      	cmp	r5, #0
  402464:	dd4c      	ble.n	402500 <xTimerGenericCommand+0xdc>
  402466:	2d04      	cmp	r5, #4
  402468:	d01c      	beq.n	4024a4 <xTimerGenericCommand+0x80>
  40246a:	2d05      	cmp	r5, #5
  40246c:	d028      	beq.n	4024c0 <xTimerGenericCommand+0x9c>
  40246e:	2e01      	cmp	r6, #1
  402470:	bf0c      	ite	eq
  402472:	2300      	moveq	r3, #0
  402474:	2309      	movne	r3, #9
  402476:	f105 00b0 	add.w	r0, r5, #176	; 0xb0
  40247a:	4418      	add	r0, r3
  40247c:	2c00      	cmp	r4, #0
  40247e:	d03b      	beq.n	4024f8 <xTimerGenericCommand+0xd4>
  402480:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
  402484:	e039      	b.n	4024fa <xTimerGenericCommand+0xd6>
  402486:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  40248a:	f383 8811 	msr	BASEPRI, r3
  40248e:	f3bf 8f6f 	isb	sy
  402492:	f3bf 8f4f 	dsb	sy
  402496:	e7fe      	b.n	402496 <xTimerGenericCommand+0x72>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
  402498:	2300      	movs	r3, #0
  40249a:	4669      	mov	r1, sp
  40249c:	4e25      	ldr	r6, [pc, #148]	; (402534 <xTimerGenericCommand+0x110>)
  40249e:	47b0      	blx	r6
  4024a0:	4606      	mov	r6, r0
  4024a2:	e7de      	b.n	402462 <xTimerGenericCommand+0x3e>
		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
  4024a4:	2e01      	cmp	r6, #1
  4024a6:	bf0c      	ite	eq
  4024a8:	20b4      	moveq	r0, #180	; 0xb4
  4024aa:	20bd      	movne	r0, #189	; 0xbd
  4024ac:	b134      	cbz	r4, 4024bc <xTimerGenericCommand+0x98>
  4024ae:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
  4024b2:	463b      	mov	r3, r7
  4024b4:	2105      	movs	r1, #5
  4024b6:	4c20      	ldr	r4, [pc, #128]	; (402538 <xTimerGenericCommand+0x114>)
  4024b8:	47a0      	blx	r4
  4024ba:	e021      	b.n	402500 <xTimerGenericCommand+0xdc>
  4024bc:	2200      	movs	r2, #0
  4024be:	e7f8      	b.n	4024b2 <xTimerGenericCommand+0x8e>
  4024c0:	2e01      	cmp	r6, #1
  4024c2:	d001      	beq.n	4024c8 <xTimerGenericCommand+0xa4>
  4024c4:	2309      	movs	r3, #9
  4024c6:	e7d6      	b.n	402476 <xTimerGenericCommand+0x52>
  4024c8:	4625      	mov	r5, r4
  4024ca:	b1f4      	cbz	r4, 40250a <xTimerGenericCommand+0xe6>
  4024cc:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
  4024d0:	2105      	movs	r1, #5
  4024d2:	20b5      	movs	r0, #181	; 0xb5
  4024d4:	4b19      	ldr	r3, [pc, #100]	; (40253c <xTimerGenericCommand+0x118>)
  4024d6:	4798      	blx	r3
  4024d8:	2105      	movs	r1, #5
  4024da:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
  4024de:	4b18      	ldr	r3, [pc, #96]	; (402540 <xTimerGenericCommand+0x11c>)
  4024e0:	4798      	blx	r3
  4024e2:	2105      	movs	r1, #5
  4024e4:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
  4024e8:	4b16      	ldr	r3, [pc, #88]	; (402544 <xTimerGenericCommand+0x120>)
  4024ea:	4798      	blx	r3
  4024ec:	6aa5      	ldr	r5, [r4, #40]	; 0x28
  4024ee:	b2e9      	uxtb	r1, r5
  4024f0:	2005      	movs	r0, #5
  4024f2:	4b15      	ldr	r3, [pc, #84]	; (402548 <xTimerGenericCommand+0x124>)
  4024f4:	4798      	blx	r3
  4024f6:	e003      	b.n	402500 <xTimerGenericCommand+0xdc>
  4024f8:	2200      	movs	r2, #0
  4024fa:	2105      	movs	r1, #5
  4024fc:	4b0f      	ldr	r3, [pc, #60]	; (40253c <xTimerGenericCommand+0x118>)
  4024fe:	4798      	blx	r3
}
  402500:	4630      	mov	r0, r6
  402502:	b005      	add	sp, #20
  402504:	bdf0      	pop	{r4, r5, r6, r7, pc}
BaseType_t xReturn = pdFAIL;
  402506:	2600      	movs	r6, #0
	return xReturn;
  402508:	e7fa      	b.n	402500 <xTimerGenericCommand+0xdc>
		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
  40250a:	2200      	movs	r2, #0
  40250c:	2105      	movs	r1, #5
  40250e:	20b5      	movs	r0, #181	; 0xb5
  402510:	4b0a      	ldr	r3, [pc, #40]	; (40253c <xTimerGenericCommand+0x118>)
  402512:	4798      	blx	r3
  402514:	2105      	movs	r1, #5
  402516:	2000      	movs	r0, #0
  402518:	4b09      	ldr	r3, [pc, #36]	; (402540 <xTimerGenericCommand+0x11c>)
  40251a:	4798      	blx	r3
  40251c:	2105      	movs	r1, #5
  40251e:	2000      	movs	r0, #0
  402520:	4b08      	ldr	r3, [pc, #32]	; (402544 <xTimerGenericCommand+0x120>)
  402522:	4798      	blx	r3
  402524:	e7e3      	b.n	4024ee <xTimerGenericCommand+0xca>
  402526:	bf00      	nop
  402528:	2000a5b4 	.word	0x2000a5b4
  40252c:	004020ed 	.word	0x004020ed
  402530:	00400e79 	.word	0x00400e79
  402534:	00401135 	.word	0x00401135
  402538:	0040370d 	.word	0x0040370d
  40253c:	00403615 	.word	0x00403615
  402540:	00402e29 	.word	0x00402e29
  402544:	00402e9d 	.word	0x00402e9d
  402548:	004031b9 	.word	0x004031b9

0040254c <prvSampleTimeNow>:
{
  40254c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  402550:	b082      	sub	sp, #8
  402552:	4680      	mov	r8, r0
	xTimeNow = xTaskGetTickCount();
  402554:	4b23      	ldr	r3, [pc, #140]	; (4025e4 <prvSampleTimeNow+0x98>)
  402556:	4798      	blx	r3
  402558:	4607      	mov	r7, r0
	if( xTimeNow < xLastTime )
  40255a:	4b23      	ldr	r3, [pc, #140]	; (4025e8 <prvSampleTimeNow+0x9c>)
  40255c:	681b      	ldr	r3, [r3, #0]
  40255e:	4298      	cmp	r0, r3
  402560:	d319      	bcc.n	402596 <prvSampleTimeNow+0x4a>
		*pxTimerListsWereSwitched = pdFALSE;
  402562:	2300      	movs	r3, #0
  402564:	f8c8 3000 	str.w	r3, [r8]
	xLastTime = xTimeNow;
  402568:	4b1f      	ldr	r3, [pc, #124]	; (4025e8 <prvSampleTimeNow+0x9c>)
  40256a:	601f      	str	r7, [r3, #0]
}
  40256c:	4638      	mov	r0, r7
  40256e:	b002      	add	sp, #8
  402570:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  402574:	2100      	movs	r1, #0
  402576:	9100      	str	r1, [sp, #0]
  402578:	460b      	mov	r3, r1
  40257a:	4652      	mov	r2, sl
  40257c:	4620      	mov	r0, r4
  40257e:	4c1b      	ldr	r4, [pc, #108]	; (4025ec <prvSampleTimeNow+0xa0>)
  402580:	47a0      	blx	r4
				configASSERT( xResult );
  402582:	b950      	cbnz	r0, 40259a <prvSampleTimeNow+0x4e>
  402584:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  402588:	f383 8811 	msr	BASEPRI, r3
  40258c:	f3bf 8f6f 	isb	sy
  402590:	f3bf 8f4f 	dsb	sy
  402594:	e7fe      	b.n	402594 <prvSampleTimeNow+0x48>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  402596:	4d16      	ldr	r5, [pc, #88]	; (4025f0 <prvSampleTimeNow+0xa4>)
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  402598:	4e16      	ldr	r6, [pc, #88]	; (4025f4 <prvSampleTimeNow+0xa8>)
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  40259a:	682b      	ldr	r3, [r5, #0]
  40259c:	681a      	ldr	r2, [r3, #0]
  40259e:	b1c2      	cbz	r2, 4025d2 <prvSampleTimeNow+0x86>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  4025a0:	68db      	ldr	r3, [r3, #12]
  4025a2:	f8d3 a000 	ldr.w	sl, [r3]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  4025a6:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  4025a8:	f104 0904 	add.w	r9, r4, #4
  4025ac:	4648      	mov	r0, r9
  4025ae:	47b0      	blx	r6
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  4025b0:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4025b2:	4620      	mov	r0, r4
  4025b4:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
  4025b6:	69e3      	ldr	r3, [r4, #28]
  4025b8:	2b01      	cmp	r3, #1
  4025ba:	d1ee      	bne.n	40259a <prvSampleTimeNow+0x4e>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  4025bc:	69a3      	ldr	r3, [r4, #24]
  4025be:	4453      	add	r3, sl
			if( xReloadTime > xNextExpireTime )
  4025c0:	459a      	cmp	sl, r3
  4025c2:	d2d7      	bcs.n	402574 <prvSampleTimeNow+0x28>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
  4025c4:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  4025c6:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  4025c8:	4649      	mov	r1, r9
  4025ca:	6828      	ldr	r0, [r5, #0]
  4025cc:	4b0a      	ldr	r3, [pc, #40]	; (4025f8 <prvSampleTimeNow+0xac>)
  4025ce:	4798      	blx	r3
  4025d0:	e7e3      	b.n	40259a <prvSampleTimeNow+0x4e>
	pxCurrentTimerList = pxOverflowTimerList;
  4025d2:	4a0a      	ldr	r2, [pc, #40]	; (4025fc <prvSampleTimeNow+0xb0>)
  4025d4:	6810      	ldr	r0, [r2, #0]
  4025d6:	4906      	ldr	r1, [pc, #24]	; (4025f0 <prvSampleTimeNow+0xa4>)
  4025d8:	6008      	str	r0, [r1, #0]
	pxOverflowTimerList = pxTemp;
  4025da:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
  4025dc:	2301      	movs	r3, #1
  4025de:	f8c8 3000 	str.w	r3, [r8]
  4025e2:	e7c1      	b.n	402568 <prvSampleTimeNow+0x1c>
  4025e4:	00401a05 	.word	0x00401a05
  4025e8:	2000a5b0 	.word	0x2000a5b0
  4025ec:	00402425 	.word	0x00402425
  4025f0:	2000a580 	.word	0x2000a580
  4025f4:	004007d9 	.word	0x004007d9
  4025f8:	004007a5 	.word	0x004007a5
  4025fc:	2000a584 	.word	0x2000a584

00402600 <prvTimerTask>:
{
  402600:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  402604:	b088      	sub	sp, #32
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  402606:	4e70      	ldr	r6, [pc, #448]	; (4027c8 <prvTimerTask+0x1c8>)
			( void ) xTaskResumeAll();
  402608:	4f70      	ldr	r7, [pc, #448]	; (4027cc <prvTimerTask+0x1cc>)
					portYIELD_WITHIN_API();
  40260a:	f8df 91e8 	ldr.w	r9, [pc, #488]	; 4027f4 <prvTimerTask+0x1f4>
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  40260e:	f8df 81e8 	ldr.w	r8, [pc, #488]	; 4027f8 <prvTimerTask+0x1f8>
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  402612:	6833      	ldr	r3, [r6, #0]
	if( *pxListWasEmpty == pdFALSE )
  402614:	681a      	ldr	r2, [r3, #0]
  402616:	b172      	cbz	r2, 402636 <prvTimerTask+0x36>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  402618:	68db      	ldr	r3, [r3, #12]
  40261a:	681c      	ldr	r4, [r3, #0]
	vTaskSuspendAll();
  40261c:	4b6c      	ldr	r3, [pc, #432]	; (4027d0 <prvTimerTask+0x1d0>)
  40261e:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  402620:	a804      	add	r0, sp, #16
  402622:	4b6c      	ldr	r3, [pc, #432]	; (4027d4 <prvTimerTask+0x1d4>)
  402624:	4798      	blx	r3
  402626:	4605      	mov	r5, r0
		if( xTimerListsWereSwitched == pdFALSE )
  402628:	9b04      	ldr	r3, [sp, #16]
  40262a:	2b00      	cmp	r3, #0
  40262c:	d152      	bne.n	4026d4 <prvTimerTask+0xd4>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
  40262e:	42a0      	cmp	r0, r4
  402630:	d223      	bcs.n	40267a <prvTimerTask+0x7a>
  402632:	2200      	movs	r2, #0
  402634:	e00f      	b.n	402656 <prvTimerTask+0x56>
	vTaskSuspendAll();
  402636:	4b66      	ldr	r3, [pc, #408]	; (4027d0 <prvTimerTask+0x1d0>)
  402638:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  40263a:	a804      	add	r0, sp, #16
  40263c:	4b65      	ldr	r3, [pc, #404]	; (4027d4 <prvTimerTask+0x1d4>)
  40263e:	4798      	blx	r3
  402640:	4605      	mov	r5, r0
		if( xTimerListsWereSwitched == pdFALSE )
  402642:	9b04      	ldr	r3, [sp, #16]
  402644:	2b00      	cmp	r3, #0
  402646:	d145      	bne.n	4026d4 <prvTimerTask+0xd4>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
  402648:	4b63      	ldr	r3, [pc, #396]	; (4027d8 <prvTimerTask+0x1d8>)
  40264a:	681b      	ldr	r3, [r3, #0]
  40264c:	681a      	ldr	r2, [r3, #0]
  40264e:	fab2 f282 	clz	r2, r2
  402652:	0952      	lsrs	r2, r2, #5
  402654:	2400      	movs	r4, #0
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
  402656:	1b61      	subs	r1, r4, r5
  402658:	4b60      	ldr	r3, [pc, #384]	; (4027dc <prvTimerTask+0x1dc>)
  40265a:	6818      	ldr	r0, [r3, #0]
  40265c:	4b60      	ldr	r3, [pc, #384]	; (4027e0 <prvTimerTask+0x1e0>)
  40265e:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  402660:	47b8      	blx	r7
  402662:	b938      	cbnz	r0, 402674 <prvTimerTask+0x74>
					portYIELD_WITHIN_API();
  402664:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  402668:	f8c9 3000 	str.w	r3, [r9]
  40266c:	f3bf 8f4f 	dsb	sy
  402670:	f3bf 8f6f 	isb	sy
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  402674:	4d59      	ldr	r5, [pc, #356]	; (4027dc <prvTimerTask+0x1dc>)
  402676:	4c5b      	ldr	r4, [pc, #364]	; (4027e4 <prvTimerTask+0x1e4>)
  402678:	e035      	b.n	4026e6 <prvTimerTask+0xe6>
				( void ) xTaskResumeAll();
  40267a:	47b8      	blx	r7
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  40267c:	6833      	ldr	r3, [r6, #0]
  40267e:	68db      	ldr	r3, [r3, #12]
  402680:	f8d3 a00c 	ldr.w	sl, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  402684:	f10a 0004 	add.w	r0, sl, #4
  402688:	47c0      	blx	r8
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
  40268a:	f8da 301c 	ldr.w	r3, [sl, #28]
  40268e:	2b01      	cmp	r3, #1
  402690:	d004      	beq.n	40269c <prvTimerTask+0x9c>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  402692:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
  402696:	4650      	mov	r0, sl
  402698:	4798      	blx	r3
  40269a:	e7eb      	b.n	402674 <prvTimerTask+0x74>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
  40269c:	f8da 1018 	ldr.w	r1, [sl, #24]
  4026a0:	4623      	mov	r3, r4
  4026a2:	462a      	mov	r2, r5
  4026a4:	4421      	add	r1, r4
  4026a6:	4650      	mov	r0, sl
  4026a8:	4d4f      	ldr	r5, [pc, #316]	; (4027e8 <prvTimerTask+0x1e8>)
  4026aa:	47a8      	blx	r5
  4026ac:	2800      	cmp	r0, #0
  4026ae:	d0f0      	beq.n	402692 <prvTimerTask+0x92>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  4026b0:	2100      	movs	r1, #0
  4026b2:	9100      	str	r1, [sp, #0]
  4026b4:	460b      	mov	r3, r1
  4026b6:	4622      	mov	r2, r4
  4026b8:	4650      	mov	r0, sl
  4026ba:	4c4c      	ldr	r4, [pc, #304]	; (4027ec <prvTimerTask+0x1ec>)
  4026bc:	47a0      	blx	r4
			configASSERT( xResult );
  4026be:	2800      	cmp	r0, #0
  4026c0:	d1e7      	bne.n	402692 <prvTimerTask+0x92>
  4026c2:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  4026c6:	f383 8811 	msr	BASEPRI, r3
  4026ca:	f3bf 8f6f 	isb	sy
  4026ce:	f3bf 8f4f 	dsb	sy
  4026d2:	e7fe      	b.n	4026d2 <prvTimerTask+0xd2>
			( void ) xTaskResumeAll();
  4026d4:	47b8      	blx	r7
  4026d6:	e7cd      	b.n	402674 <prvTimerTask+0x74>
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
  4026d8:	9907      	ldr	r1, [sp, #28]
  4026da:	9806      	ldr	r0, [sp, #24]
  4026dc:	9b05      	ldr	r3, [sp, #20]
  4026de:	4798      	blx	r3
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
  4026e0:	9b04      	ldr	r3, [sp, #16]
  4026e2:	2b00      	cmp	r3, #0
  4026e4:	da09      	bge.n	4026fa <prvTimerTask+0xfa>
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  4026e6:	2300      	movs	r3, #0
  4026e8:	461a      	mov	r2, r3
  4026ea:	a904      	add	r1, sp, #16
  4026ec:	6828      	ldr	r0, [r5, #0]
  4026ee:	47a0      	blx	r4
  4026f0:	2800      	cmp	r0, #0
  4026f2:	d08e      	beq.n	402612 <prvTimerTask+0x12>
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
  4026f4:	9b04      	ldr	r3, [sp, #16]
  4026f6:	2b00      	cmp	r3, #0
  4026f8:	dbee      	blt.n	4026d8 <prvTimerTask+0xd8>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
  4026fa:	f8dd a018 	ldr.w	sl, [sp, #24]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
  4026fe:	f8da 3014 	ldr.w	r3, [sl, #20]
  402702:	b113      	cbz	r3, 40270a <prvTimerTask+0x10a>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  402704:	f10a 0004 	add.w	r0, sl, #4
  402708:	47c0      	blx	r8
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  40270a:	a803      	add	r0, sp, #12
  40270c:	4b31      	ldr	r3, [pc, #196]	; (4027d4 <prvTimerTask+0x1d4>)
  40270e:	4798      	blx	r3
			switch( xMessage.xMessageID )
  402710:	9b04      	ldr	r3, [sp, #16]
  402712:	2b09      	cmp	r3, #9
  402714:	d8e7      	bhi.n	4026e6 <prvTimerTask+0xe6>
  402716:	a201      	add	r2, pc, #4	; (adr r2, 40271c <prvTimerTask+0x11c>)
  402718:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40271c:	00402745 	.word	0x00402745
  402720:	00402745 	.word	0x00402745
  402724:	00402745 	.word	0x00402745
  402728:	004026e7 	.word	0x004026e7
  40272c:	00402797 	.word	0x00402797
  402730:	004027bf 	.word	0x004027bf
  402734:	00402745 	.word	0x00402745
  402738:	00402745 	.word	0x00402745
  40273c:	004026e7 	.word	0x004026e7
  402740:	00402797 	.word	0x00402797
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
  402744:	9c05      	ldr	r4, [sp, #20]
  402746:	f8da 1018 	ldr.w	r1, [sl, #24]
  40274a:	4623      	mov	r3, r4
  40274c:	4602      	mov	r2, r0
  40274e:	4421      	add	r1, r4
  402750:	4650      	mov	r0, sl
  402752:	4c25      	ldr	r4, [pc, #148]	; (4027e8 <prvTimerTask+0x1e8>)
  402754:	47a0      	blx	r4
  402756:	2800      	cmp	r0, #0
  402758:	d08d      	beq.n	402676 <prvTimerTask+0x76>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  40275a:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
  40275e:	4650      	mov	r0, sl
  402760:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
  402762:	f8da 301c 	ldr.w	r3, [sl, #28]
  402766:	2b01      	cmp	r3, #1
  402768:	d185      	bne.n	402676 <prvTimerTask+0x76>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
  40276a:	f8da 2018 	ldr.w	r2, [sl, #24]
  40276e:	2100      	movs	r1, #0
  402770:	9100      	str	r1, [sp, #0]
  402772:	460b      	mov	r3, r1
  402774:	9805      	ldr	r0, [sp, #20]
  402776:	4402      	add	r2, r0
  402778:	4650      	mov	r0, sl
  40277a:	4c1c      	ldr	r4, [pc, #112]	; (4027ec <prvTimerTask+0x1ec>)
  40277c:	47a0      	blx	r4
							configASSERT( xResult );
  40277e:	2800      	cmp	r0, #0
  402780:	f47f af79 	bne.w	402676 <prvTimerTask+0x76>
  402784:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  402788:	f383 8811 	msr	BASEPRI, r3
  40278c:	f3bf 8f6f 	isb	sy
  402790:	f3bf 8f4f 	dsb	sy
  402794:	e7fe      	b.n	402794 <prvTimerTask+0x194>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
  402796:	9905      	ldr	r1, [sp, #20]
  402798:	f8ca 1018 	str.w	r1, [sl, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  40279c:	b131      	cbz	r1, 4027ac <prvTimerTask+0x1ac>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  40279e:	4603      	mov	r3, r0
  4027a0:	4602      	mov	r2, r0
  4027a2:	4401      	add	r1, r0
  4027a4:	4650      	mov	r0, sl
  4027a6:	4c10      	ldr	r4, [pc, #64]	; (4027e8 <prvTimerTask+0x1e8>)
  4027a8:	47a0      	blx	r4
  4027aa:	e764      	b.n	402676 <prvTimerTask+0x76>
  4027ac:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  4027b0:	f383 8811 	msr	BASEPRI, r3
  4027b4:	f3bf 8f6f 	isb	sy
  4027b8:	f3bf 8f4f 	dsb	sy
  4027bc:	e7fe      	b.n	4027bc <prvTimerTask+0x1bc>
						vPortFree( pxTimer );
  4027be:	4650      	mov	r0, sl
  4027c0:	4b0b      	ldr	r3, [pc, #44]	; (4027f0 <prvTimerTask+0x1f0>)
  4027c2:	4798      	blx	r3
  4027c4:	e757      	b.n	402676 <prvTimerTask+0x76>
  4027c6:	bf00      	nop
  4027c8:	2000a580 	.word	0x2000a580
  4027cc:	00401b8d 	.word	0x00401b8d
  4027d0:	004019f5 	.word	0x004019f5
  4027d4:	0040254d 	.word	0x0040254d
  4027d8:	2000a584 	.word	0x2000a584
  4027dc:	2000a5b4 	.word	0x2000a5b4
  4027e0:	004015ed 	.word	0x004015ed
  4027e4:	004012bd 	.word	0x004012bd
  4027e8:	00402329 	.word	0x00402329
  4027ec:	00402425 	.word	0x00402425
  4027f0:	004006e9 	.word	0x004006e9
  4027f4:	e000ed04 	.word	0xe000ed04
  4027f8:	004007d9 	.word	0x004007d9

004027fc <prvTraceGetCurrentTaskHandle>:
{
	prvTraceSetObjectName(TRACE_GET_OBJECT_TRACE_CLASS(TRC_UNUSED, object), TRACE_GET_OBJECT_NUMBER(TRC_UNUSED, object), name);
}

void* prvTraceGetCurrentTaskHandle()
{
  4027fc:	b508      	push	{r3, lr}
	return xTaskGetCurrentTaskHandle();
  4027fe:	4b01      	ldr	r3, [pc, #4]	; (402804 <prvTraceGetCurrentTaskHandle+0x8>)
  402800:	4798      	blx	r3
}
  402802:	bd08      	pop	{r3, pc}
  402804:	004020e1 	.word	0x004020e1

00402808 <prvTraceGetObjectNumber>:
}
#else /* For FreeRTOS v8 and later */


traceHandle prvTraceGetObjectNumber(void* handle)
{
  402808:	b508      	push	{r3, lr}
	return (traceHandle) uxQueueGetQueueNumber(handle);
  40280a:	4b02      	ldr	r3, [pc, #8]	; (402814 <prvTraceGetObjectNumber+0xc>)
  40280c:	4798      	blx	r3
}
  40280e:	b2c0      	uxtb	r0, r0
  402810:	bd08      	pop	{r3, pc}
  402812:	bf00      	nop
  402814:	004015e1 	.word	0x004015e1

00402818 <prvTraceGetObjectType>:
#endif
extern unsigned char ucQueueGetQueueType( xQueueHandle pxQueue ) ;
uint8_t prvTraceGetObjectType(void* handle)
{
  402818:	b508      	push	{r3, lr}
	return ucQueueGetQueueType(handle);
  40281a:	4b01      	ldr	r3, [pc, #4]	; (402820 <prvTraceGetObjectType+0x8>)
  40281c:	4798      	blx	r3
}
  40281e:	bd08      	pop	{r3, pc}
  402820:	004015e5 	.word	0x004015e5

00402824 <prvTraceGetTaskNumber>:

traceHandle prvTraceGetTaskNumber(void* handle)
{
  402824:	b508      	push	{r3, lr}
	return (traceHandle)uxTaskGetTaskNumber(handle);
  402826:	4b02      	ldr	r3, [pc, #8]	; (402830 <prvTraceGetTaskNumber+0xc>)
  402828:	4798      	blx	r3
}
  40282a:	b2c0      	uxtb	r0, r0
  40282c:	bd08      	pop	{r3, pc}
  40282e:	bf00      	nop
  402830:	004020d5 	.word	0x004020d5

00402834 <vTraceInitObjectPropertyTable>:

/* Initialization of the object property table */
void vTraceInitObjectPropertyTable()
{
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectClasses = TRACE_NCLASSES;
  402834:	4b28      	ldr	r3, [pc, #160]	; (4028d8 <vTraceInitObjectPropertyTable+0xa4>)
  402836:	681b      	ldr	r3, [r3, #0]
  402838:	2207      	movs	r2, #7
  40283a:	65da      	str	r2, [r3, #92]	; 0x5c
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[0] = TRC_CFG_NQUEUE;
  40283c:	220a      	movs	r2, #10
  40283e:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[1] = TRC_CFG_NSEMAPHORE;
  402842:	f883 2065 	strb.w	r2, [r3, #101]	; 0x65
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[2] = TRC_CFG_NMUTEX;
  402846:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[3] = TRC_CFG_NTASK;
  40284a:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[4] = TRC_CFG_NISR;
  40284e:	2205      	movs	r2, #5
  402850:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[5] = TRC_CFG_NTIMER;
  402854:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[6] = TRC_CFG_NEVENTGROUP;	
  402858:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[0] = TRC_CFG_NAME_LEN_QUEUE;
  40285c:	220f      	movs	r2, #15
  40285e:	f883 206c 	strb.w	r2, [r3, #108]	; 0x6c
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[1] = TRC_CFG_NAME_LEN_SEMAPHORE;
  402862:	f883 206d 	strb.w	r2, [r3, #109]	; 0x6d
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[2] = TRC_CFG_NAME_LEN_MUTEX;
  402866:	f883 206e 	strb.w	r2, [r3, #110]	; 0x6e
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[3] = TRC_CFG_NAME_LEN_TASK;
  40286a:	f883 206f 	strb.w	r2, [r3, #111]	; 0x6f
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[4] = TRC_CFG_NAME_LEN_ISR;
  40286e:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[5] = TRC_CFG_NAME_LEN_TIMER;
  402872:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[6] = TRC_CFG_NAME_LEN_EVENTGROUP;	
  402876:	f883 2072 	strb.w	r2, [r3, #114]	; 0x72
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[0] = PropertyTableSizeQueue;
  40287a:	2210      	movs	r2, #16
  40287c:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[1] = PropertyTableSizeSemaphore;
  402880:	f883 2075 	strb.w	r2, [r3, #117]	; 0x75
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[2] = PropertyTableSizeMutex;
  402884:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[3] = PropertyTableSizeTask;
  402888:	2113      	movs	r1, #19
  40288a:	f883 1077 	strb.w	r1, [r3, #119]	; 0x77
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[4] = PropertyTableSizeISR;
  40288e:	2011      	movs	r0, #17
  402890:	f883 0078 	strb.w	r0, [r3, #120]	; 0x78
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[5] = PropertyTableSizeTimer;
  402894:	f883 2079 	strb.w	r2, [r3, #121]	; 0x79
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[6] = PropertyTableSizeEventGroup;
  402898:	f883 107a 	strb.w	r1, [r3, #122]	; 0x7a
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[0] = StartIndexQueue;
  40289c:	2200      	movs	r2, #0
  40289e:	f8a3 207c 	strh.w	r2, [r3, #124]	; 0x7c
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[1] = StartIndexSemaphore;
  4028a2:	22a0      	movs	r2, #160	; 0xa0
  4028a4:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[2] = StartIndexMutex;
  4028a8:	f44f 72a0 	mov.w	r2, #320	; 0x140
  4028ac:	f8a3 2080 	strh.w	r2, [r3, #128]	; 0x80
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[3] = StartIndexTask;
  4028b0:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
  4028b4:	f8a3 2082 	strh.w	r2, [r3, #130]	; 0x82
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[4] = StartIndexISR;
  4028b8:	f240 229e 	movw	r2, #670	; 0x29e
  4028bc:	f8a3 2084 	strh.w	r2, [r3, #132]	; 0x84
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[5] = StartIndexTimer;
  4028c0:	f240 22f3 	movw	r2, #755	; 0x2f3
  4028c4:	f8a3 2086 	strh.w	r2, [r3, #134]	; 0x86
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[6] = StartIndexEventGroup;
  4028c8:	f240 3243 	movw	r2, #835	; 0x343
  4028cc:	f8a3 2088 	strh.w	r2, [r3, #136]	; 0x88
	RecorderDataPtr->ObjectPropertyTable.ObjectPropertyTableSizeInBytes = TRACE_OBJECT_TABLE_SIZE;
  4028d0:	f240 32a2 	movw	r2, #930	; 0x3a2
  4028d4:	661a      	str	r2, [r3, #96]	; 0x60
  4028d6:	4770      	bx	lr
  4028d8:	2000a5bc 	.word	0x2000a5bc

004028dc <vTraceInitObjectHandleStack>:
}

/* Initialization of the handle mechanism, see e.g, prvTraceGetObjectHandle */
void vTraceInitObjectHandleStack()
{
	objectHandleStacks.indexOfNextAvailableHandle[0] = objectHandleStacks.lowestIndexOfClass[0] = 0;
  4028dc:	4b12      	ldr	r3, [pc, #72]	; (402928 <vTraceInitObjectHandleStack+0x4c>)
  4028de:	2200      	movs	r2, #0
  4028e0:	81da      	strh	r2, [r3, #14]
  4028e2:	801a      	strh	r2, [r3, #0]
	objectHandleStacks.indexOfNextAvailableHandle[1] = objectHandleStacks.lowestIndexOfClass[1] = TRC_CFG_NQUEUE;
  4028e4:	220a      	movs	r2, #10
  4028e6:	821a      	strh	r2, [r3, #16]
  4028e8:	805a      	strh	r2, [r3, #2]
	objectHandleStacks.indexOfNextAvailableHandle[2] = objectHandleStacks.lowestIndexOfClass[2] = TRC_CFG_NQUEUE + TRC_CFG_NSEMAPHORE;
  4028ea:	2214      	movs	r2, #20
  4028ec:	825a      	strh	r2, [r3, #18]
  4028ee:	809a      	strh	r2, [r3, #4]
	objectHandleStacks.indexOfNextAvailableHandle[3] = objectHandleStacks.lowestIndexOfClass[3] = TRC_CFG_NQUEUE + TRC_CFG_NSEMAPHORE + TRC_CFG_NMUTEX;
  4028f0:	221e      	movs	r2, #30
  4028f2:	829a      	strh	r2, [r3, #20]
  4028f4:	80da      	strh	r2, [r3, #6]
	objectHandleStacks.indexOfNextAvailableHandle[4] = objectHandleStacks.lowestIndexOfClass[4] = TRC_CFG_NQUEUE + TRC_CFG_NSEMAPHORE + TRC_CFG_NMUTEX + TRC_CFG_NTASK;
  4028f6:	2228      	movs	r2, #40	; 0x28
  4028f8:	82da      	strh	r2, [r3, #22]
  4028fa:	811a      	strh	r2, [r3, #8]
	objectHandleStacks.indexOfNextAvailableHandle[5] = objectHandleStacks.lowestIndexOfClass[5] = TRC_CFG_NQUEUE + TRC_CFG_NSEMAPHORE + TRC_CFG_NMUTEX + TRC_CFG_NTASK + TRC_CFG_NISR;
  4028fc:	222d      	movs	r2, #45	; 0x2d
  4028fe:	831a      	strh	r2, [r3, #24]
  402900:	815a      	strh	r2, [r3, #10]
	objectHandleStacks.indexOfNextAvailableHandle[6] = objectHandleStacks.lowestIndexOfClass[6] = TRC_CFG_NQUEUE + TRC_CFG_NSEMAPHORE + TRC_CFG_NMUTEX + TRC_CFG_NTASK + TRC_CFG_NISR + TRC_CFG_NTIMER;
  402902:	2232      	movs	r2, #50	; 0x32
  402904:	835a      	strh	r2, [r3, #26]
  402906:	819a      	strh	r2, [r3, #12]

	objectHandleStacks.highestIndexOfClass[0] = TRC_CFG_NQUEUE - 1;
  402908:	2209      	movs	r2, #9
  40290a:	839a      	strh	r2, [r3, #28]
	objectHandleStacks.highestIndexOfClass[1] = TRC_CFG_NQUEUE + TRC_CFG_NSEMAPHORE - 1;
  40290c:	2213      	movs	r2, #19
  40290e:	83da      	strh	r2, [r3, #30]
	objectHandleStacks.highestIndexOfClass[2] = TRC_CFG_NQUEUE + TRC_CFG_NSEMAPHORE + TRC_CFG_NMUTEX - 1;
  402910:	221d      	movs	r2, #29
  402912:	841a      	strh	r2, [r3, #32]
	objectHandleStacks.highestIndexOfClass[3] = TRC_CFG_NQUEUE + TRC_CFG_NSEMAPHORE + TRC_CFG_NMUTEX + TRC_CFG_NTASK - 1;
  402914:	2227      	movs	r2, #39	; 0x27
  402916:	845a      	strh	r2, [r3, #34]	; 0x22
	objectHandleStacks.highestIndexOfClass[4] = TRC_CFG_NQUEUE + TRC_CFG_NSEMAPHORE + TRC_CFG_NMUTEX + TRC_CFG_NTASK + TRC_CFG_NISR - 1;
  402918:	222c      	movs	r2, #44	; 0x2c
  40291a:	849a      	strh	r2, [r3, #36]	; 0x24
	objectHandleStacks.highestIndexOfClass[5] = TRC_CFG_NQUEUE + TRC_CFG_NSEMAPHORE + TRC_CFG_NMUTEX + TRC_CFG_NTASK + TRC_CFG_NISR + TRC_CFG_NTIMER - 1;
  40291c:	2231      	movs	r2, #49	; 0x31
  40291e:	84da      	strh	r2, [r3, #38]	; 0x26
	objectHandleStacks.highestIndexOfClass[6] = TRC_CFG_NQUEUE + TRC_CFG_NSEMAPHORE + TRC_CFG_NMUTEX + TRC_CFG_NTASK + TRC_CFG_NISR + TRC_CFG_NTIMER + TRC_CFG_NEVENTGROUP - 1;
  402920:	2236      	movs	r2, #54	; 0x36
  402922:	851a      	strh	r2, [r3, #40]	; 0x28
  402924:	4770      	bx	lr
  402926:	bf00      	nop
  402928:	2000a5e0 	.word	0x2000a5e0

0040292c <pszTraceGetErrorNotEnoughHandles>:
}

/* Returns the "Not enough handles" error message for this object class */
const char* pszTraceGetErrorNotEnoughHandles(traceObjectClass objectclass)
{
	switch(objectclass)
  40292c:	2806      	cmp	r0, #6
  40292e:	d811      	bhi.n	402954 <pszTraceGetErrorNotEnoughHandles+0x28>
  402930:	e8df f000 	tbb	[pc, r0]
  402934:	1208060a 	.word	0x1208060a
  402938:	0c04      	.short	0x0c04
  40293a:	0e          	.byte	0x0e
  40293b:	00          	.byte	0x00
	{
	case TRACE_CLASS_TASK:
		return "Not enough TASK handles - increase TRC_CFG_NTASK in trcSnapshotConfig.h";
	case TRACE_CLASS_ISR:
		return "Not enough ISR handles - increase TRC_CFG_NISR in trcSnapshotConfig.h";
  40293c:	4807      	ldr	r0, [pc, #28]	; (40295c <pszTraceGetErrorNotEnoughHandles+0x30>)
  40293e:	4770      	bx	lr
	case TRACE_CLASS_SEMAPHORE:
		return "Not enough SEMAPHORE handles - increase TRC_CFG_NSEMAPHORE in trcSnapshotConfig.h";
  402940:	4807      	ldr	r0, [pc, #28]	; (402960 <pszTraceGetErrorNotEnoughHandles+0x34>)
  402942:	4770      	bx	lr
	case TRACE_CLASS_MUTEX:
		return "Not enough MUTEX handles - increase TRC_CFG_NMUTEX in trcSnapshotConfig.h";
  402944:	4807      	ldr	r0, [pc, #28]	; (402964 <pszTraceGetErrorNotEnoughHandles+0x38>)
  402946:	4770      	bx	lr
	case TRACE_CLASS_QUEUE:
		return "Not enough QUEUE handles - increase TRC_CFG_NQUEUE in trcSnapshotConfig.h";
  402948:	4807      	ldr	r0, [pc, #28]	; (402968 <pszTraceGetErrorNotEnoughHandles+0x3c>)
  40294a:	4770      	bx	lr
	case TRACE_CLASS_TIMER:
		return "Not enough TIMER handles - increase TRC_CFG_NTIMER in trcSnapshotConfig.h";
  40294c:	4807      	ldr	r0, [pc, #28]	; (40296c <pszTraceGetErrorNotEnoughHandles+0x40>)
  40294e:	4770      	bx	lr
	case TRACE_CLASS_EVENTGROUP:
		return "Not enough EVENTGROUP handles - increase TRC_CFG_NEVENTGROUP in trcSnapshotConfig.h";		
  402950:	4807      	ldr	r0, [pc, #28]	; (402970 <pszTraceGetErrorNotEnoughHandles+0x44>)
  402952:	4770      	bx	lr
	default:
		return "pszTraceGetErrorHandles: Invalid objectclass!";
  402954:	4807      	ldr	r0, [pc, #28]	; (402974 <pszTraceGetErrorNotEnoughHandles+0x48>)
  402956:	4770      	bx	lr
		return "Not enough TASK handles - increase TRC_CFG_NTASK in trcSnapshotConfig.h";
  402958:	4807      	ldr	r0, [pc, #28]	; (402978 <pszTraceGetErrorNotEnoughHandles+0x4c>)
	}
}
  40295a:	4770      	bx	lr
  40295c:	00404140 	.word	0x00404140
  402960:	00404188 	.word	0x00404188
  402964:	004041dc 	.word	0x004041dc
  402968:	00404228 	.word	0x00404228
  40296c:	00404274 	.word	0x00404274
  402970:	004042c0 	.word	0x004042c0
  402974:	00404314 	.word	0x00404314
  402978:	004040f8 	.word	0x004040f8

0040297c <uiTraceIsObjectExcluded>:

/* Returns the exclude state of the object */
uint8_t uiTraceIsObjectExcluded(traceObjectClass objectclass, traceHandle handle)
{
  40297c:	b508      	push	{r3, lr}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, "prvIsObjectExcluded: objectclass >= TRACE_NCLASSES", 1);
  40297e:	2806      	cmp	r0, #6
  402980:	d80e      	bhi.n	4029a0 <uiTraceIsObjectExcluded+0x24>
	TRACE_ASSERT(handle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], "prvIsObjectExcluded: Invalid value for handle", 1);
  402982:	4b2c      	ldr	r3, [pc, #176]	; (402a34 <uiTraceIsObjectExcluded+0xb8>)
  402984:	681b      	ldr	r3, [r3, #0]
  402986:	4403      	add	r3, r0
  402988:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
  40298c:	428b      	cmp	r3, r1
  40298e:	d30c      	bcc.n	4029aa <uiTraceIsObjectExcluded+0x2e>
	
	switch(objectclass)
  402990:	2806      	cmp	r0, #6
  402992:	d84a      	bhi.n	402a2a <uiTraceIsObjectExcluded+0xae>
  402994:	e8df f000 	tbb	[pc, r0]
  402998:	0e22182c 	.word	0x0e22182c
  40299c:	3549      	.short	0x3549
  40299e:	3f          	.byte	0x3f
  40299f:	00          	.byte	0x00
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, "prvIsObjectExcluded: objectclass >= TRACE_NCLASSES", 1);
  4029a0:	4825      	ldr	r0, [pc, #148]	; (402a38 <uiTraceIsObjectExcluded+0xbc>)
  4029a2:	4b26      	ldr	r3, [pc, #152]	; (402a3c <uiTraceIsObjectExcluded+0xc0>)
  4029a4:	4798      	blx	r3
  4029a6:	2001      	movs	r0, #1
  4029a8:	bd08      	pop	{r3, pc}
	TRACE_ASSERT(handle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], "prvIsObjectExcluded: Invalid value for handle", 1);
  4029aa:	4825      	ldr	r0, [pc, #148]	; (402a40 <uiTraceIsObjectExcluded+0xc4>)
  4029ac:	4b23      	ldr	r3, [pc, #140]	; (402a3c <uiTraceIsObjectExcluded+0xc0>)
  4029ae:	4798      	blx	r3
  4029b0:	2001      	movs	r0, #1
  4029b2:	bd08      	pop	{r3, pc}
	{
	case TRACE_CLASS_TASK:
		return (uint8_t) TRACE_GET_TASK_FLAG_ISEXCLUDED(handle);
  4029b4:	3121      	adds	r1, #33	; 0x21
  4029b6:	10cb      	asrs	r3, r1, #3
  4029b8:	f001 0107 	and.w	r1, r1, #7
  4029bc:	2001      	movs	r0, #1
  4029be:	4088      	lsls	r0, r1
  4029c0:	4a20      	ldr	r2, [pc, #128]	; (402a44 <uiTraceIsObjectExcluded+0xc8>)
  4029c2:	5cd1      	ldrb	r1, [r2, r3]
  4029c4:	4008      	ands	r0, r1
  4029c6:	bd08      	pop	{r3, pc}
	case TRACE_CLASS_SEMAPHORE:
		return (uint8_t) TRACE_GET_SEMAPHORE_FLAG_ISEXCLUDED(handle);
  4029c8:	310b      	adds	r1, #11
  4029ca:	10cb      	asrs	r3, r1, #3
  4029cc:	f001 0107 	and.w	r1, r1, #7
  4029d0:	2001      	movs	r0, #1
  4029d2:	4088      	lsls	r0, r1
  4029d4:	4a1b      	ldr	r2, [pc, #108]	; (402a44 <uiTraceIsObjectExcluded+0xc8>)
  4029d6:	5cd1      	ldrb	r1, [r2, r3]
  4029d8:	4008      	ands	r0, r1
  4029da:	bd08      	pop	{r3, pc}
	case TRACE_CLASS_MUTEX:
		return (uint8_t) TRACE_GET_MUTEX_FLAG_ISEXCLUDED(handle);
  4029dc:	3116      	adds	r1, #22
  4029de:	10cb      	asrs	r3, r1, #3
  4029e0:	f001 0107 	and.w	r1, r1, #7
  4029e4:	2001      	movs	r0, #1
  4029e6:	4088      	lsls	r0, r1
  4029e8:	4a16      	ldr	r2, [pc, #88]	; (402a44 <uiTraceIsObjectExcluded+0xc8>)
  4029ea:	5cd1      	ldrb	r1, [r2, r3]
  4029ec:	4008      	ands	r0, r1
  4029ee:	bd08      	pop	{r3, pc}
	case TRACE_CLASS_QUEUE:
		return (uint8_t) TRACE_GET_QUEUE_FLAG_ISEXCLUDED(handle);
  4029f0:	08cb      	lsrs	r3, r1, #3
  4029f2:	f001 0107 	and.w	r1, r1, #7
  4029f6:	2001      	movs	r0, #1
  4029f8:	4088      	lsls	r0, r1
  4029fa:	4a12      	ldr	r2, [pc, #72]	; (402a44 <uiTraceIsObjectExcluded+0xc8>)
  4029fc:	5cd1      	ldrb	r1, [r2, r3]
  4029fe:	4008      	ands	r0, r1
  402a00:	bd08      	pop	{r3, pc}
	case TRACE_CLASS_TIMER:
		return (uint8_t) TRACE_GET_TIMER_FLAG_ISEXCLUDED(handle);
  402a02:	312c      	adds	r1, #44	; 0x2c
  402a04:	10cb      	asrs	r3, r1, #3
  402a06:	f001 0107 	and.w	r1, r1, #7
  402a0a:	2001      	movs	r0, #1
  402a0c:	4088      	lsls	r0, r1
  402a0e:	4a0d      	ldr	r2, [pc, #52]	; (402a44 <uiTraceIsObjectExcluded+0xc8>)
  402a10:	5cd1      	ldrb	r1, [r2, r3]
  402a12:	4008      	ands	r0, r1
  402a14:	bd08      	pop	{r3, pc}
	case TRACE_CLASS_EVENTGROUP:
		return (uint8_t) TRACE_GET_EVENTGROUP_FLAG_ISEXCLUDED(handle);
  402a16:	3132      	adds	r1, #50	; 0x32
  402a18:	10cb      	asrs	r3, r1, #3
  402a1a:	f001 0107 	and.w	r1, r1, #7
  402a1e:	2001      	movs	r0, #1
  402a20:	4088      	lsls	r0, r1
  402a22:	4a08      	ldr	r2, [pc, #32]	; (402a44 <uiTraceIsObjectExcluded+0xc8>)
  402a24:	5cd1      	ldrb	r1, [r2, r3]
  402a26:	4008      	ands	r0, r1
  402a28:	bd08      	pop	{r3, pc}
	}
	
	prvTraceError("Invalid object class ID in prvIsObjectExcluded!");
  402a2a:	4807      	ldr	r0, [pc, #28]	; (402a48 <uiTraceIsObjectExcluded+0xcc>)
  402a2c:	4b03      	ldr	r3, [pc, #12]	; (402a3c <uiTraceIsObjectExcluded+0xc0>)
  402a2e:	4798      	blx	r3
	
	/* Must never reach */
	return 1;
  402a30:	2001      	movs	r0, #1
}
  402a32:	bd08      	pop	{r3, pc}
  402a34:	2000a5bc 	.word	0x2000a5bc
  402a38:	00404344 	.word	0x00404344
  402a3c:	00402a91 	.word	0x00402a91
  402a40:	00404388 	.word	0x00404388
  402a44:	2000a688 	.word	0x2000a688
  402a48:	004043c4 	.word	0x004043c4

00402a4c <prvStrncpy>:
 * Private string copy function, to improve portability between compilers.
 ******************************************************************************/
static void prvStrncpy(char* dst, const char* src, uint32_t maxLength)
{
	uint32_t i;
	for (i = 0; i < maxLength; i++)
  402a4c:	b18a      	cbz	r2, 402a72 <prvStrncpy+0x26>
{
  402a4e:	b430      	push	{r4, r5}
	{
		dst[i] = src[i];
  402a50:	780b      	ldrb	r3, [r1, #0]
  402a52:	7003      	strb	r3, [r0, #0]
		if (src[i] == 0)
  402a54:	780b      	ldrb	r3, [r1, #0]
  402a56:	b15b      	cbz	r3, 402a70 <prvStrncpy+0x24>
  402a58:	1c4b      	adds	r3, r1, #1
  402a5a:	4411      	add	r1, r2
	for (i = 0; i < maxLength; i++)
  402a5c:	428b      	cmp	r3, r1
  402a5e:	d007      	beq.n	402a70 <prvStrncpy+0x24>
  402a60:	461c      	mov	r4, r3
		dst[i] = src[i];
  402a62:	f813 5b01 	ldrb.w	r5, [r3], #1
  402a66:	f800 5f01 	strb.w	r5, [r0, #1]!
		if (src[i] == 0)
  402a6a:	7824      	ldrb	r4, [r4, #0]
  402a6c:	2c00      	cmp	r4, #0
  402a6e:	d1f5      	bne.n	402a5c <prvStrncpy+0x10>
			break;
	}
}
  402a70:	bc30      	pop	{r4, r5}
  402a72:	4770      	bx	lr

00402a74 <vTraceStop>:
{
  402a74:	b508      	push	{r3, lr}
	RecorderDataPtr->recorderActive = 0;
  402a76:	4b04      	ldr	r3, [pc, #16]	; (402a88 <vTraceStop+0x14>)
  402a78:	681b      	ldr	r3, [r3, #0]
  402a7a:	2200      	movs	r2, #0
  402a7c:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
  402a7e:	4b03      	ldr	r3, [pc, #12]	; (402a8c <vTraceStop+0x18>)
  402a80:	681b      	ldr	r3, [r3, #0]
  402a82:	b103      	cbz	r3, 402a86 <vTraceStop+0x12>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
  402a84:	4798      	blx	r3
  402a86:	bd08      	pop	{r3, pc}
  402a88:	2000a5bc 	.word	0x2000a5bc
  402a8c:	2000a694 	.word	0x2000a694

00402a90 <prvTraceError>:
 * Note: If a recorder error is registered before vTraceStart is called, the
 * trace start will be aborted. This can occur if any of the Nxxxx constants
 * (e.g., TRC_CFG_NTASK) in trcConfig.h is too small.
 ******************************************************************************/
void prvTraceError(const char* msg)
{
  402a90:	b510      	push	{r4, lr}
  402a92:	4604      	mov	r4, r0
	/* Stop the recorder */
	vTraceStop();
  402a94:	4b0b      	ldr	r3, [pc, #44]	; (402ac4 <prvTraceError+0x34>)
  402a96:	4798      	blx	r3
	
	/* If first error only... */
	if (traceErrorMessage == NULL)
  402a98:	4b0b      	ldr	r3, [pc, #44]	; (402ac8 <prvTraceError+0x38>)
  402a9a:	681b      	ldr	r3, [r3, #0]
  402a9c:	b103      	cbz	r3, 402aa0 <prvTraceError+0x10>
  402a9e:	bd10      	pop	{r4, pc}
	{
		traceErrorMessage = (char*)(intptr_t) msg;
  402aa0:	4b09      	ldr	r3, [pc, #36]	; (402ac8 <prvTraceError+0x38>)
  402aa2:	601c      	str	r4, [r3, #0]
		if (RecorderDataPtr != NULL)
  402aa4:	4b09      	ldr	r3, [pc, #36]	; (402acc <prvTraceError+0x3c>)
  402aa6:	6818      	ldr	r0, [r3, #0]
  402aa8:	2800      	cmp	r0, #0
  402aaa:	d0f8      	beq.n	402a9e <prvTraceError+0xe>
		{
			prvStrncpy(RecorderDataPtr->systemInfo, traceErrorMessage, 80);
  402aac:	2250      	movs	r2, #80	; 0x50
  402aae:	4621      	mov	r1, r4
  402ab0:	f500 60fd 	add.w	r0, r0, #2024	; 0x7e8
  402ab4:	4b06      	ldr	r3, [pc, #24]	; (402ad0 <prvTraceError+0x40>)
  402ab6:	4798      	blx	r3
			RecorderDataPtr->internalErrorOccured = 1;
  402ab8:	4b04      	ldr	r3, [pc, #16]	; (402acc <prvTraceError+0x3c>)
  402aba:	681b      	ldr	r3, [r3, #0]
  402abc:	2201      	movs	r2, #1
  402abe:	f8c3 27e0 	str.w	r2, [r3, #2016]	; 0x7e0
		}
	}
}
  402ac2:	e7ec      	b.n	402a9e <prvTraceError+0xe>
  402ac4:	00402a75 	.word	0x00402a75
  402ac8:	2000a65c 	.word	0x2000a65c
  402acc:	2000a5bc 	.word	0x2000a5bc
  402ad0:	00402a4d 	.word	0x00402a4d

00402ad4 <prvTraceNextFreeEventBufferSlot>:
{
  402ad4:	b508      	push	{r3, lr}
	if (! RecorderDataPtr->recorderActive)
  402ad6:	4b0a      	ldr	r3, [pc, #40]	; (402b00 <prvTraceNextFreeEventBufferSlot+0x2c>)
  402ad8:	6818      	ldr	r0, [r3, #0]
  402ada:	6b03      	ldr	r3, [r0, #48]	; 0x30
  402adc:	b16b      	cbz	r3, 402afa <prvTraceNextFreeEventBufferSlot+0x26>
	if (RecorderDataPtr->nextFreeIndex >= TRC_CFG_EVENT_BUFFER_SIZE)
  402ade:	69c3      	ldr	r3, [r0, #28]
  402ae0:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  402ae4:	d204      	bcs.n	402af0 <prvTraceNextFreeEventBufferSlot+0x1c>
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
  402ae6:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  402aea:	f600 003c 	addw	r0, r0, #2108	; 0x83c
  402aee:	bd08      	pop	{r3, pc}
		prvTraceError("Attempt to index outside event buffer!");
  402af0:	4804      	ldr	r0, [pc, #16]	; (402b04 <prvTraceNextFreeEventBufferSlot+0x30>)
  402af2:	4b05      	ldr	r3, [pc, #20]	; (402b08 <prvTraceNextFreeEventBufferSlot+0x34>)
  402af4:	4798      	blx	r3
		return NULL;
  402af6:	2000      	movs	r0, #0
  402af8:	bd08      	pop	{r3, pc}
		return NULL;
  402afa:	2000      	movs	r0, #0
}
  402afc:	bd08      	pop	{r3, pc}
  402afe:	bf00      	nop
  402b00:	2000a5bc 	.word	0x2000a5bc
  402b04:	004046d4 	.word	0x004046d4
  402b08:	00402a91 	.word	0x00402a91

00402b0c <prvCheckDataToBeOverwrittenForMultiEntryEvents>:
 * This is assumed to execute within a critical section...
 *****************************************************************************/

#if (TRC_CFG_SNAPSHOT_MODE == TRC_SNAPSHOT_MODE_RING_BUFFER)
void prvCheckDataToBeOverwrittenForMultiEntryEvents(uint8_t nofEntriesToCheck)
{
  402b0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* Generic "int" type is desired - should be 16 bit variable on 16 bit HW */
	unsigned int i = 0;
	unsigned int e = 0;

	TRACE_ASSERT(nofEntriesToCheck != 0, 
  402b10:	b148      	cbz	r0, 402b26 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x1a>
		"prvCheckDataToBeOverwrittenForMultiEntryEvents: nofEntriesToCheck == 0", TRC_UNUSED);

	while (i < nofEntriesToCheck)
  402b12:	4605      	mov	r5, r0
  402b14:	b128      	cbz	r0, 402b22 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x16>
  402b16:	2400      	movs	r4, #0
	{
		e = RecorderDataPtr->nextFreeIndex + i;
  402b18:	4e20      	ldr	r6, [pc, #128]	; (402b9c <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x90>)
				(void)memset(& RecorderDataPtr->eventData[e*4], 0, 4 + 4);
			}
			else
			{
				/* Clear 8 bytes, 4 first and 4 last */
				(void)memset(& RecorderDataPtr->eventData[0], 0, 4);
  402b1a:	4627      	mov	r7, r4
				(void)memset(& RecorderDataPtr->eventData[e*4], 0, (size_t) (4 + 4 * nDataEvents));
  402b1c:	f8df 8088 	ldr.w	r8, [pc, #136]	; 402ba8 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x9c>
  402b20:	e00b      	b.n	402b3a <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x2e>
  402b22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	TRACE_ASSERT(nofEntriesToCheck != 0, 
  402b26:	481e      	ldr	r0, [pc, #120]	; (402ba0 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x94>)
  402b28:	4b1e      	ldr	r3, [pc, #120]	; (402ba4 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x98>)
  402b2a:	4798      	blx	r3
  402b2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		else if (RecorderDataPtr->eventData[e*4] == DIV_XPS)
  402b30:	2a01      	cmp	r2, #1
  402b32:	d01e      	beq.n	402b72 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x66>
				(void)memset(& RecorderDataPtr->eventData[e*4], 0, 4);
			}
		}
		i++;
  402b34:	3401      	adds	r4, #1
	while (i < nofEntriesToCheck)
  402b36:	42ac      	cmp	r4, r5
  402b38:	d02e      	beq.n	402b98 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x8c>
		e = RecorderDataPtr->nextFreeIndex + i;
  402b3a:	6830      	ldr	r0, [r6, #0]
  402b3c:	69c3      	ldr	r3, [r0, #28]
  402b3e:	4423      	add	r3, r4
		if ((RecorderDataPtr->eventData[e*4] > USER_EVENT) &&
  402b40:	ea4f 0e83 	mov.w	lr, r3, lsl #2
  402b44:	eb00 020e 	add.w	r2, r0, lr
  402b48:	f892 283c 	ldrb.w	r2, [r2, #2108]	; 0x83c
  402b4c:	f102 0167 	add.w	r1, r2, #103	; 0x67
  402b50:	b2c9      	uxtb	r1, r1
  402b52:	290e      	cmp	r1, #14
  402b54:	d8ec      	bhi.n	402b30 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x24>
			uint8_t nDataEvents = (uint8_t)(RecorderDataPtr->eventData[e*4] - USER_EVENT);
  402b56:	3268      	adds	r2, #104	; 0x68
  402b58:	b2d2      	uxtb	r2, r2
			if ((e + nDataEvents) < RecorderDataPtr->maxEvents)
  402b5a:	4413      	add	r3, r2
  402b5c:	6981      	ldr	r1, [r0, #24]
  402b5e:	428b      	cmp	r3, r1
  402b60:	d2e8      	bcs.n	402b34 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x28>
				(void)memset(& RecorderDataPtr->eventData[e*4], 0, (size_t) (4 + 4 * nDataEvents));
  402b62:	3201      	adds	r2, #1
  402b64:	f60e 0e3c 	addw	lr, lr, #2108	; 0x83c
  402b68:	0092      	lsls	r2, r2, #2
  402b6a:	4639      	mov	r1, r7
  402b6c:	4470      	add	r0, lr
  402b6e:	47c0      	blx	r8
  402b70:	e7e0      	b.n	402b34 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x28>
			if ((e + 1) < RecorderDataPtr->maxEvents)
  402b72:	3301      	adds	r3, #1
  402b74:	6982      	ldr	r2, [r0, #24]
  402b76:	4293      	cmp	r3, r2
  402b78:	d207      	bcs.n	402b8a <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x7e>
				(void)memset(& RecorderDataPtr->eventData[e*4], 0, 4 + 4);
  402b7a:	f60e 0e3c 	addw	lr, lr, #2108	; 0x83c
  402b7e:	eb00 030e 	add.w	r3, r0, lr
  402b82:	f840 700e 	str.w	r7, [r0, lr]
  402b86:	605f      	str	r7, [r3, #4]
  402b88:	e7d4      	b.n	402b34 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x28>
				(void)memset(& RecorderDataPtr->eventData[0], 0, 4);
  402b8a:	f8c0 783c 	str.w	r7, [r0, #2108]	; 0x83c
				(void)memset(& RecorderDataPtr->eventData[e*4], 0, 4);
  402b8e:	f60e 0e3c 	addw	lr, lr, #2108	; 0x83c
  402b92:	f840 700e 	str.w	r7, [r0, lr]
  402b96:	e7cd      	b.n	402b34 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x28>
  402b98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402b9c:	2000a5bc 	.word	0x2000a5bc
  402ba0:	004043f4 	.word	0x004043f4
  402ba4:	00402a91 	.word	0x00402a91
  402ba8:	00403eb1 	.word	0x00403eb1

00402bac <prvTraceUpdateCounters>:
 * prvTraceUpdateCounters
 *
 * Updates the index of the event buffer.
 ******************************************************************************/
void prvTraceUpdateCounters(void)
{	
  402bac:	b508      	push	{r3, lr}
	if (RecorderDataPtr->recorderActive == 0)
  402bae:	4b0a      	ldr	r3, [pc, #40]	; (402bd8 <prvTraceUpdateCounters+0x2c>)
  402bb0:	681b      	ldr	r3, [r3, #0]
  402bb2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  402bb4:	b17a      	cbz	r2, 402bd6 <prvTraceUpdateCounters+0x2a>
	{
		return;
	}
	
	RecorderDataPtr->numEvents++;
  402bb6:	695a      	ldr	r2, [r3, #20]
  402bb8:	3201      	adds	r2, #1
  402bba:	615a      	str	r2, [r3, #20]

	RecorderDataPtr->nextFreeIndex++;
  402bbc:	69da      	ldr	r2, [r3, #28]
  402bbe:	3201      	adds	r2, #1
  402bc0:	61da      	str	r2, [r3, #28]

	if (RecorderDataPtr->nextFreeIndex >= TRC_CFG_EVENT_BUFFER_SIZE)
  402bc2:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
  402bc6:	d303      	bcc.n	402bd0 <prvTraceUpdateCounters+0x24>
	{
#if (TRC_CFG_SNAPSHOT_MODE == TRC_SNAPSHOT_MODE_RING_BUFFER)
		RecorderDataPtr->bufferIsFull = 1;
  402bc8:	2201      	movs	r2, #1
  402bca:	621a      	str	r2, [r3, #32]
		RecorderDataPtr->nextFreeIndex = 0;
  402bcc:	2200      	movs	r2, #0
  402bce:	61da      	str	r2, [r3, #28]
		vTraceStop();
#endif
	}

#if (TRC_CFG_SNAPSHOT_MODE == TRC_SNAPSHOT_MODE_RING_BUFFER)
	prvCheckDataToBeOverwrittenForMultiEntryEvents(1);
  402bd0:	2001      	movs	r0, #1
  402bd2:	4b02      	ldr	r3, [pc, #8]	; (402bdc <prvTraceUpdateCounters+0x30>)
  402bd4:	4798      	blx	r3
  402bd6:	bd08      	pop	{r3, pc}
  402bd8:	2000a5bc 	.word	0x2000a5bc
  402bdc:	00402b0d 	.word	0x00402b0d

00402be0 <prvTraceOpenSymbol>:
{
  402be0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402be4:	b087      	sub	sp, #28
  402be6:	9102      	str	r1, [sp, #8]
	TRACE_ASSERT(name != NULL, "prvTraceOpenSymbol: name == NULL", (traceString)0);
  402be8:	2800      	cmp	r0, #0
  402bea:	d032      	beq.n	402c52 <prvTraceOpenSymbol+0x72>
  402bec:	4682      	mov	sl, r0
	TRACE_ASSERT(pcrc != NULL, "prvTraceGetChecksum: pcrc == NULL", TRC_UNUSED);
	TRACE_ASSERT(plength != NULL, "prvTraceGetChecksum: plength == NULL", TRC_UNUSED);

	if (pname != (const char *) 0)
	{
		for (; (c = (unsigned char) *pname++) != '\0';)
  402bee:	1c41      	adds	r1, r0, #1
  402bf0:	7803      	ldrb	r3, [r0, #0]
  402bf2:	b35b      	cbz	r3, 402c4c <prvTraceOpenSymbol+0x6c>
  402bf4:	2701      	movs	r7, #1
  402bf6:	2200      	movs	r2, #0
		{
			crc += c;
  402bf8:	441a      	add	r2, r3
			length++;
  402bfa:	3701      	adds	r7, #1
		for (; (c = (unsigned char) *pname++) != '\0';)
  402bfc:	f811 3b01 	ldrb.w	r3, [r1], #1
  402c00:	2b00      	cmp	r3, #0
  402c02:	d1f9      	bne.n	402bf8 <prvTraceOpenSymbol+0x18>
		}
	}
	*pcrc = (uint8_t)(crc & 0x3F);
	*plength = (uint8_t)length;
  402c04:	b2fb      	uxtb	r3, r7
  402c06:	4618      	mov	r0, r3
  402c08:	9305      	str	r3, [sp, #20]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  402c0a:	f3ef 8310 	mrs	r3, PRIMASK
  402c0e:	9301      	str	r3, [sp, #4]

    \param [in]    priMask  Priority Mask
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  402c10:	2301      	movs	r3, #1
  402c12:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
  402c16:	4949      	ldr	r1, [pc, #292]	; (402d3c <prvTraceOpenSymbol+0x15c>)
  402c18:	680b      	ldr	r3, [r1, #0]
  402c1a:	3301      	adds	r3, #1
  402c1c:	600b      	str	r3, [r1, #0]
	uint16_t i = RecorderDataPtr->SymbolTable.latestEntryOfChecksum[ crc6 ];
  402c1e:	f002 033f 	and.w	r3, r2, #63	; 0x3f
  402c22:	461a      	mov	r2, r3
  402c24:	9304      	str	r3, [sp, #16]
	TRACE_ASSERT(len != 0, "prvTraceLookupSymbolTableEntry: len == 0", (traceString)0);
  402c26:	b1c8      	cbz	r0, 402c5c <prvTraceOpenSymbol+0x7c>
	uint16_t i = RecorderDataPtr->SymbolTable.latestEntryOfChecksum[ crc6 ];
  402c28:	4b45      	ldr	r3, [pc, #276]	; (402d40 <prvTraceOpenSymbol+0x160>)
  402c2a:	681e      	ldr	r6, [r3, #0]
  402c2c:	eb06 0342 	add.w	r3, r6, r2, lsl #1
  402c30:	f8b3 375c 	ldrh.w	r3, [r3, #1884]	; 0x75c
  402c34:	9303      	str	r3, [sp, #12]
	while (i != 0)
  402c36:	2b00      	cmp	r3, #0
  402c38:	d047      	beq.n	402cca <prvTraceOpenSymbol+0xea>
			if (RecorderDataPtr->SymbolTable.symbytes[i + 3] == (chn / 0x100))
  402c3a:	9a02      	ldr	r2, [sp, #8]
  402c3c:	ea4f 2912 	mov.w	r9, r2, lsr #8
  402c40:	9c03      	ldr	r4, [sp, #12]
		if (RecorderDataPtr->SymbolTable.symbytes[i + 2] == (chn & 0x00FF))
  402c42:	fa5f f882 	uxtb.w	r8, r2
  402c46:	fa5f fb87 	uxtb.w	fp, r7
  402c4a:	e021      	b.n	402c90 <prvTraceOpenSymbol+0xb0>
		for (; (c = (unsigned char) *pname++) != '\0';)
  402c4c:	2701      	movs	r7, #1
  402c4e:	2200      	movs	r2, #0
  402c50:	e7d8      	b.n	402c04 <prvTraceOpenSymbol+0x24>
	TRACE_ASSERT(name != NULL, "prvTraceOpenSymbol: name == NULL", (traceString)0);
  402c52:	483c      	ldr	r0, [pc, #240]	; (402d44 <prvTraceOpenSymbol+0x164>)
  402c54:	4b3c      	ldr	r3, [pc, #240]	; (402d48 <prvTraceOpenSymbol+0x168>)
  402c56:	4798      	blx	r3
  402c58:	2400      	movs	r4, #0
  402c5a:	e00c      	b.n	402c76 <prvTraceOpenSymbol+0x96>
	TRACE_ASSERT(len != 0, "prvTraceLookupSymbolTableEntry: len == 0", (traceString)0);
  402c5c:	483b      	ldr	r0, [pc, #236]	; (402d4c <prvTraceOpenSymbol+0x16c>)
  402c5e:	4c3a      	ldr	r4, [pc, #232]	; (402d48 <prvTraceOpenSymbol+0x168>)
  402c60:	47a0      	blx	r4
	TRACE_ASSERT(len != 0, "prvTraceCreateSymbolTableEntry: len == 0", 0);
  402c62:	483b      	ldr	r0, [pc, #236]	; (402d50 <prvTraceOpenSymbol+0x170>)
  402c64:	47a0      	blx	r4
  402c66:	2400      	movs	r4, #0
	trcCRITICAL_SECTION_END();
  402c68:	4a34      	ldr	r2, [pc, #208]	; (402d3c <prvTraceOpenSymbol+0x15c>)
  402c6a:	6813      	ldr	r3, [r2, #0]
  402c6c:	3b01      	subs	r3, #1
  402c6e:	6013      	str	r3, [r2, #0]
  402c70:	9b01      	ldr	r3, [sp, #4]
  402c72:	f383 8810 	msr	PRIMASK, r3
}
  402c76:	4620      	mov	r0, r4
  402c78:	b007      	add	sp, #28
  402c7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		i = (uint16_t)(RecorderDataPtr->SymbolTable.symbytes[i] + (RecorderDataPtr->SymbolTable.symbytes[i + 1] * 0x100));
  402c7e:	1973      	adds	r3, r6, r5
  402c80:	f893 243d 	ldrb.w	r2, [r3, #1085]	; 0x43d
  402c84:	f893 443c 	ldrb.w	r4, [r3, #1084]	; 0x43c
  402c88:	eb04 2402 	add.w	r4, r4, r2, lsl #8
  402c8c:	b2a4      	uxth	r4, r4
	while (i != 0)
  402c8e:	b1e4      	cbz	r4, 402cca <prvTraceOpenSymbol+0xea>
		if (RecorderDataPtr->SymbolTable.symbytes[i + 2] == (chn & 0x00FF))
  402c90:	4625      	mov	r5, r4
  402c92:	1933      	adds	r3, r6, r4
  402c94:	f893 343e 	ldrb.w	r3, [r3, #1086]	; 0x43e
  402c98:	4543      	cmp	r3, r8
  402c9a:	d1f0      	bne.n	402c7e <prvTraceOpenSymbol+0x9e>
			if (RecorderDataPtr->SymbolTable.symbytes[i + 3] == (chn / 0x100))
  402c9c:	1933      	adds	r3, r6, r4
  402c9e:	f893 343f 	ldrb.w	r3, [r3, #1087]	; 0x43f
  402ca2:	454b      	cmp	r3, r9
  402ca4:	d1eb      	bne.n	402c7e <prvTraceOpenSymbol+0x9e>
				if (RecorderDataPtr->SymbolTable.symbytes[i + 4 + len] == '\0')
  402ca6:	1d20      	adds	r0, r4, #4
  402ca8:	1833      	adds	r3, r6, r0
  402caa:	445b      	add	r3, fp
  402cac:	f893 343c 	ldrb.w	r3, [r3, #1084]	; 0x43c
  402cb0:	2b00      	cmp	r3, #0
  402cb2:	d1e4      	bne.n	402c7e <prvTraceOpenSymbol+0x9e>
					if (strncmp((char*)(& RecorderDataPtr->SymbolTable.symbytes[i + 4]), name, len) == 0)
  402cb4:	f504 6088 	add.w	r0, r4, #1088	; 0x440
  402cb8:	465a      	mov	r2, fp
  402cba:	4651      	mov	r1, sl
  402cbc:	4430      	add	r0, r6
  402cbe:	4b25      	ldr	r3, [pc, #148]	; (402d54 <prvTraceOpenSymbol+0x174>)
  402cc0:	4798      	blx	r3
  402cc2:	2800      	cmp	r0, #0
  402cc4:	d1db      	bne.n	402c7e <prvTraceOpenSymbol+0x9e>
	if (!result)
  402cc6:	2c00      	cmp	r4, #0
  402cc8:	d1ce      	bne.n	402c68 <prvTraceOpenSymbol+0x88>
	if (RecorderDataPtr->SymbolTable.nextFreeSymbolIndex + len + 4 >= TRC_CFG_SYMBOL_TABLE_SIZE)
  402cca:	f8d6 3438 	ldr.w	r3, [r6, #1080]	; 0x438
  402cce:	b2ff      	uxtb	r7, r7
  402cd0:	1d1a      	adds	r2, r3, #4
  402cd2:	443a      	add	r2, r7
  402cd4:	f5b2 7f48 	cmp.w	r2, #800	; 0x320
  402cd8:	d22a      	bcs.n	402d30 <prvTraceOpenSymbol+0x150>
			[ RecorderDataPtr->SymbolTable.nextFreeSymbolIndex] =
  402cda:	18f2      	adds	r2, r6, r3
			(uint8_t)(RecorderDataPtr->SymbolTable.latestEntryOfChecksum[ crc6 ] & 0x00FF);
  402cdc:	9903      	ldr	r1, [sp, #12]
  402cde:	f882 143c 	strb.w	r1, [r2, #1084]	; 0x43c
			(uint8_t)(RecorderDataPtr->SymbolTable.latestEntryOfChecksum[ crc6 ] / 0x100);
  402ce2:	0a09      	lsrs	r1, r1, #8
  402ce4:	f882 143d 	strb.w	r1, [r2, #1085]	; 0x43d
			(uint8_t)(channel & 0x00FF);
  402ce8:	9902      	ldr	r1, [sp, #8]
  402cea:	f882 143e 	strb.w	r1, [r2, #1086]	; 0x43e
			(uint8_t)(channel / 0x100);
  402cee:	0a09      	lsrs	r1, r1, #8
  402cf0:	f882 143f 	strb.w	r1, [r2, #1087]	; 0x43f
		prvStrncpy((char*)&(RecorderDataPtr->SymbolTable.symbytes
  402cf4:	f503 6388 	add.w	r3, r3, #1088	; 0x440
  402cf8:	463a      	mov	r2, r7
  402cfa:	4651      	mov	r1, sl
  402cfc:	18f0      	adds	r0, r6, r3
  402cfe:	4b16      	ldr	r3, [pc, #88]	; (402d58 <prvTraceOpenSymbol+0x178>)
  402d00:	4798      	blx	r3
		RecorderDataPtr->SymbolTable.symbytes
  402d02:	4b0f      	ldr	r3, [pc, #60]	; (402d40 <prvTraceOpenSymbol+0x160>)
  402d04:	681a      	ldr	r2, [r3, #0]
			[RecorderDataPtr->SymbolTable.nextFreeSymbolIndex + 4 + len] = '\0';
  402d06:	f8d2 3438 	ldr.w	r3, [r2, #1080]	; 0x438
  402d0a:	441f      	add	r7, r3
  402d0c:	19d1      	adds	r1, r2, r7
  402d0e:	2000      	movs	r0, #0
  402d10:	f881 0440 	strb.w	r0, [r1, #1088]	; 0x440
			[ crc6 ] = (uint16_t)RecorderDataPtr->SymbolTable.nextFreeSymbolIndex;
  402d14:	9904      	ldr	r1, [sp, #16]
  402d16:	eb02 0141 	add.w	r1, r2, r1, lsl #1
  402d1a:	f8a1 375c 	strh.w	r3, [r1, #1884]	; 0x75c
		RecorderDataPtr->SymbolTable.nextFreeSymbolIndex += (uint32_t) (len + 5);
  402d1e:	1d7b      	adds	r3, r7, #5
  402d20:	f8c2 3438 	str.w	r3, [r2, #1080]	; 0x438
		ret = (uint16_t)(RecorderDataPtr->SymbolTable.nextFreeSymbolIndex - (uint8_t)(len + 5));
  402d24:	9c05      	ldr	r4, [sp, #20]
  402d26:	3405      	adds	r4, #5
  402d28:	b2e4      	uxtb	r4, r4
  402d2a:	1b1b      	subs	r3, r3, r4
  402d2c:	b29c      	uxth	r4, r3
  402d2e:	e79b      	b.n	402c68 <prvTraceOpenSymbol+0x88>
		prvTraceError("Symbol table full. Increase TRC_CFG_SYMBOL_TABLE_SIZE in trcConfig.h");
  402d30:	480a      	ldr	r0, [pc, #40]	; (402d5c <prvTraceOpenSymbol+0x17c>)
  402d32:	4b05      	ldr	r3, [pc, #20]	; (402d48 <prvTraceOpenSymbol+0x168>)
  402d34:	4798      	blx	r3
		ret = 0;
  402d36:	2400      	movs	r4, #0
  402d38:	e796      	b.n	402c68 <prvTraceOpenSymbol+0x88>
  402d3a:	bf00      	nop
  402d3c:	2000a654 	.word	0x2000a654
  402d40:	2000a5bc 	.word	0x2000a5bc
  402d44:	004046fc 	.word	0x004046fc
  402d48:	00402a91 	.word	0x00402a91
  402d4c:	0040472c 	.word	0x0040472c
  402d50:	00404764 	.word	0x00404764
  402d54:	00403f4d 	.word	0x00403f4d
  402d58:	00402a4d 	.word	0x00402a4d
  402d5c:	0040479c 	.word	0x0040479c

00402d60 <prvTraceGetParam>:
{
  402d60:	b538      	push	{r3, r4, r5, lr}
  402d62:	4604      	mov	r4, r0
  402d64:	460d      	mov	r5, r1
	TRACE_ASSERT(param_max == 0xFF || param_max == 0xFFFF,
  402d66:	28ff      	cmp	r0, #255	; 0xff
  402d68:	d003      	beq.n	402d72 <prvTraceGetParam+0x12>
  402d6a:	f64f 73ff 	movw	r3, #65535	; 0xffff
  402d6e:	4298      	cmp	r0, r3
  402d70:	d103      	bne.n	402d7a <prvTraceGetParam+0x1a>
	if (param <= param_max)
  402d72:	42ac      	cmp	r4, r5
  402d74:	d305      	bcc.n	402d82 <prvTraceGetParam+0x22>
}
  402d76:	4628      	mov	r0, r5
  402d78:	bd38      	pop	{r3, r4, r5, pc}
	TRACE_ASSERT(param_max == 0xFF || param_max == 0xFFFF,
  402d7a:	4809      	ldr	r0, [pc, #36]	; (402da0 <prvTraceGetParam+0x40>)
  402d7c:	4b09      	ldr	r3, [pc, #36]	; (402da4 <prvTraceGetParam+0x44>)
  402d7e:	4798      	blx	r3
  402d80:	e7f9      	b.n	402d76 <prvTraceGetParam+0x16>
		xps = (XPSEvent*) prvTraceNextFreeEventBufferSlot();
  402d82:	4b09      	ldr	r3, [pc, #36]	; (402da8 <prvTraceGetParam+0x48>)
  402d84:	4798      	blx	r3
		if (xps != NULL)
  402d86:	b148      	cbz	r0, 402d9c <prvTraceGetParam+0x3c>
			xps->type = DIV_XPS;
  402d88:	2301      	movs	r3, #1
  402d8a:	7003      	strb	r3, [r0, #0]
			xps->xps_8 = (uint8_t)((param & (0xFF00 & ~param_max)) >> 8);
  402d8c:	ea25 0304 	bic.w	r3, r5, r4
  402d90:	0a19      	lsrs	r1, r3, #8
  402d92:	7041      	strb	r1, [r0, #1]
			xps->xps_16 = (uint16_t)((param & (0xFFFF0000 & ~param_max)) >> 16);
  402d94:	0c1b      	lsrs	r3, r3, #16
  402d96:	8043      	strh	r3, [r0, #2]
			prvTraceUpdateCounters();
  402d98:	4b04      	ldr	r3, [pc, #16]	; (402dac <prvTraceGetParam+0x4c>)
  402d9a:	4798      	blx	r3
		return param & param_max;
  402d9c:	4025      	ands	r5, r4
  402d9e:	e7ea      	b.n	402d76 <prvTraceGetParam+0x16>
  402da0:	004045b4 	.word	0x004045b4
  402da4:	00402a91 	.word	0x00402a91
  402da8:	00402ad5 	.word	0x00402ad5
  402dac:	00402bad 	.word	0x00402bad

00402db0 <uiIndexOfObject>:
{
  402db0:	b508      	push	{r3, lr}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
  402db2:	2906      	cmp	r1, #6
  402db4:	d813      	bhi.n	402dde <uiIndexOfObject+0x2e>
	TRACE_ASSERT(objecthandle > 0 && objecthandle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], 
  402db6:	b1b8      	cbz	r0, 402de8 <uiIndexOfObject+0x38>
  402db8:	4b0e      	ldr	r3, [pc, #56]	; (402df4 <uiIndexOfObject+0x44>)
  402dba:	681b      	ldr	r3, [r3, #0]
  402dbc:	185a      	adds	r2, r3, r1
  402dbe:	f892 2064 	ldrb.w	r2, [r2, #100]	; 0x64
  402dc2:	4282      	cmp	r2, r0
  402dc4:	d310      	bcc.n	402de8 <uiIndexOfObject+0x38>
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
  402dc6:	185a      	adds	r2, r3, r1
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
  402dc8:	f892 2074 	ldrb.w	r2, [r2, #116]	; 0x74
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
  402dcc:	3801      	subs	r0, #1
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
  402dce:	eb03 0141 	add.w	r1, r3, r1, lsl #1
  402dd2:	f8b1 307c 	ldrh.w	r3, [r1, #124]	; 0x7c
  402dd6:	fb02 3000 	mla	r0, r2, r0, r3
  402dda:	b280      	uxth	r0, r0
}
  402ddc:	bd08      	pop	{r3, pc}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
  402dde:	4806      	ldr	r0, [pc, #24]	; (402df8 <uiIndexOfObject+0x48>)
  402de0:	4b06      	ldr	r3, [pc, #24]	; (402dfc <uiIndexOfObject+0x4c>)
  402de2:	4798      	blx	r3
  402de4:	2000      	movs	r0, #0
  402de6:	bd08      	pop	{r3, pc}
	TRACE_ASSERT(objecthandle > 0 && objecthandle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], 
  402de8:	4805      	ldr	r0, [pc, #20]	; (402e00 <uiIndexOfObject+0x50>)
  402dea:	4b04      	ldr	r3, [pc, #16]	; (402dfc <uiIndexOfObject+0x4c>)
  402dec:	4798      	blx	r3
  402dee:	2000      	movs	r0, #0
  402df0:	bd08      	pop	{r3, pc}
  402df2:	bf00      	nop
  402df4:	2000a5bc 	.word	0x2000a5bc
  402df8:	00404ebc 	.word	0x00404ebc
  402dfc:	00402a91 	.word	0x00402a91
  402e00:	00404efc 	.word	0x00404efc

00402e04 <prvMarkObjectAsUsed>:
{
  402e04:	b508      	push	{r3, lr}
  402e06:	460b      	mov	r3, r1
	uint16_t idx = uiIndexOfObject(handle, objectclass);
  402e08:	4601      	mov	r1, r0
  402e0a:	4618      	mov	r0, r3
  402e0c:	4b04      	ldr	r3, [pc, #16]	; (402e20 <prvMarkObjectAsUsed+0x1c>)
  402e0e:	4798      	blx	r3
	RecorderDataPtr->ObjectPropertyTable.objbytes[idx] = 1;
  402e10:	4b04      	ldr	r3, [pc, #16]	; (402e24 <prvMarkObjectAsUsed+0x20>)
  402e12:	681b      	ldr	r3, [r3, #0]
  402e14:	4418      	add	r0, r3
  402e16:	2301      	movs	r3, #1
  402e18:	f880 308c 	strb.w	r3, [r0, #140]	; 0x8c
  402e1c:	bd08      	pop	{r3, pc}
  402e1e:	bf00      	nop
  402e20:	00402db1 	.word	0x00402db1
  402e24:	2000a5bc 	.word	0x2000a5bc

00402e28 <prvTraceStoreObjectNameOnCloseEvent>:
{
  402e28:	b570      	push	{r4, r5, r6, lr}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
  402e2a:	2906      	cmp	r1, #6
  402e2c:	d80b      	bhi.n	402e46 <prvTraceStoreObjectNameOnCloseEvent+0x1e>
  402e2e:	4606      	mov	r6, r0
  402e30:	460c      	mov	r4, r1
	TRACE_ASSERT(handle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
  402e32:	4b12      	ldr	r3, [pc, #72]	; (402e7c <prvTraceStoreObjectNameOnCloseEvent+0x54>)
  402e34:	681d      	ldr	r5, [r3, #0]
  402e36:	186b      	adds	r3, r5, r1
  402e38:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
  402e3c:	4283      	cmp	r3, r0
  402e3e:	d306      	bcc.n	402e4e <prvTraceStoreObjectNameOnCloseEvent+0x26>
	if (RecorderDataPtr->recorderActive)
  402e40:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  402e42:	b943      	cbnz	r3, 402e56 <prvTraceStoreObjectNameOnCloseEvent+0x2e>
  402e44:	bd70      	pop	{r4, r5, r6, pc}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
  402e46:	480e      	ldr	r0, [pc, #56]	; (402e80 <prvTraceStoreObjectNameOnCloseEvent+0x58>)
  402e48:	4b0e      	ldr	r3, [pc, #56]	; (402e84 <prvTraceStoreObjectNameOnCloseEvent+0x5c>)
  402e4a:	4798      	blx	r3
  402e4c:	bd70      	pop	{r4, r5, r6, pc}
	TRACE_ASSERT(handle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
  402e4e:	480e      	ldr	r0, [pc, #56]	; (402e88 <prvTraceStoreObjectNameOnCloseEvent+0x60>)
  402e50:	4b0c      	ldr	r3, [pc, #48]	; (402e84 <prvTraceStoreObjectNameOnCloseEvent+0x5c>)
  402e52:	4798      	blx	r3
  402e54:	bd70      	pop	{r4, r5, r6, pc}
		name = TRACE_PROPERTY_NAME_GET(objectclass, handle);
  402e56:	4b0d      	ldr	r3, [pc, #52]	; (402e8c <prvTraceStoreObjectNameOnCloseEvent+0x64>)
  402e58:	4798      	blx	r3
  402e5a:	308c      	adds	r0, #140	; 0x8c
		idx = prvTraceOpenSymbol(name, 0);
  402e5c:	2100      	movs	r1, #0
  402e5e:	4428      	add	r0, r5
  402e60:	4b0b      	ldr	r3, [pc, #44]	; (402e90 <prvTraceStoreObjectNameOnCloseEvent+0x68>)
  402e62:	4798      	blx	r3
  402e64:	4605      	mov	r5, r0
		ce = (ObjCloseNameEvent*) prvTraceNextFreeEventBufferSlot();
  402e66:	4b0b      	ldr	r3, [pc, #44]	; (402e94 <prvTraceStoreObjectNameOnCloseEvent+0x6c>)
  402e68:	4798      	blx	r3
		if (ce != NULL)
  402e6a:	2800      	cmp	r0, #0
  402e6c:	d0ea      	beq.n	402e44 <prvTraceStoreObjectNameOnCloseEvent+0x1c>
			ce->type = (uint8_t) (EVENTGROUP_OBJCLOSE_NAME + objectclass);
  402e6e:	3408      	adds	r4, #8
  402e70:	7004      	strb	r4, [r0, #0]
			ce->objHandle = hnd8;
  402e72:	7046      	strb	r6, [r0, #1]
			ce->symbolIndex = idx;
  402e74:	8045      	strh	r5, [r0, #2]
			prvTraceUpdateCounters();
  402e76:	4b08      	ldr	r3, [pc, #32]	; (402e98 <prvTraceStoreObjectNameOnCloseEvent+0x70>)
  402e78:	4798      	blx	r3
  402e7a:	e7e3      	b.n	402e44 <prvTraceStoreObjectNameOnCloseEvent+0x1c>
  402e7c:	2000a5bc 	.word	0x2000a5bc
  402e80:	00404c74 	.word	0x00404c74
  402e84:	00402a91 	.word	0x00402a91
  402e88:	00404cc8 	.word	0x00404cc8
  402e8c:	00402db1 	.word	0x00402db1
  402e90:	00402be1 	.word	0x00402be1
  402e94:	00402ad5 	.word	0x00402ad5
  402e98:	00402bad 	.word	0x00402bad

00402e9c <prvTraceStoreObjectPropertiesOnCloseEvent>:
{
  402e9c:	b570      	push	{r4, r5, r6, lr}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
  402e9e:	2906      	cmp	r1, #6
  402ea0:	d80b      	bhi.n	402eba <prvTraceStoreObjectPropertiesOnCloseEvent+0x1e>
  402ea2:	4605      	mov	r5, r0
  402ea4:	460c      	mov	r4, r1
	TRACE_ASSERT(handle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
  402ea6:	4b1d      	ldr	r3, [pc, #116]	; (402f1c <prvTraceStoreObjectPropertiesOnCloseEvent+0x80>)
  402ea8:	681b      	ldr	r3, [r3, #0]
  402eaa:	185a      	adds	r2, r3, r1
  402eac:	f892 2064 	ldrb.w	r2, [r2, #100]	; 0x64
  402eb0:	4282      	cmp	r2, r0
  402eb2:	d306      	bcc.n	402ec2 <prvTraceStoreObjectPropertiesOnCloseEvent+0x26>
	if (RecorderDataPtr->recorderActive)
  402eb4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402eb6:	b943      	cbnz	r3, 402eca <prvTraceStoreObjectPropertiesOnCloseEvent+0x2e>
  402eb8:	bd70      	pop	{r4, r5, r6, pc}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
  402eba:	4819      	ldr	r0, [pc, #100]	; (402f20 <prvTraceStoreObjectPropertiesOnCloseEvent+0x84>)
  402ebc:	4b19      	ldr	r3, [pc, #100]	; (402f24 <prvTraceStoreObjectPropertiesOnCloseEvent+0x88>)
  402ebe:	4798      	blx	r3
  402ec0:	bd70      	pop	{r4, r5, r6, pc}
	TRACE_ASSERT(handle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
  402ec2:	4819      	ldr	r0, [pc, #100]	; (402f28 <prvTraceStoreObjectPropertiesOnCloseEvent+0x8c>)
  402ec4:	4b17      	ldr	r3, [pc, #92]	; (402f24 <prvTraceStoreObjectPropertiesOnCloseEvent+0x88>)
  402ec6:	4798      	blx	r3
  402ec8:	bd70      	pop	{r4, r5, r6, pc}
		pe = (ObjClosePropEvent*) prvTraceNextFreeEventBufferSlot();
  402eca:	4b18      	ldr	r3, [pc, #96]	; (402f2c <prvTraceStoreObjectPropertiesOnCloseEvent+0x90>)
  402ecc:	4798      	blx	r3
		if (pe != NULL)
  402ece:	4606      	mov	r6, r0
  402ed0:	2800      	cmp	r0, #0
  402ed2:	d0f1      	beq.n	402eb8 <prvTraceStoreObjectPropertiesOnCloseEvent+0x1c>
			if (objectclass == TRACE_CLASS_TASK)
  402ed4:	2c03      	cmp	r4, #3
  402ed6:	d012      	beq.n	402efe <prvTraceStoreObjectPropertiesOnCloseEvent+0x62>
				pe->arg1 = TRACE_PROPERTY_OBJECT_STATE(objectclass, handle);
  402ed8:	4621      	mov	r1, r4
  402eda:	4628      	mov	r0, r5
  402edc:	4b14      	ldr	r3, [pc, #80]	; (402f30 <prvTraceStoreObjectPropertiesOnCloseEvent+0x94>)
  402ede:	4798      	blx	r3
  402ee0:	4b0e      	ldr	r3, [pc, #56]	; (402f1c <prvTraceStoreObjectPropertiesOnCloseEvent+0x80>)
  402ee2:	681b      	ldr	r3, [r3, #0]
  402ee4:	191a      	adds	r2, r3, r4
  402ee6:	f892 206c 	ldrb.w	r2, [r2, #108]	; 0x6c
  402eea:	4418      	add	r0, r3
  402eec:	4410      	add	r0, r2
  402eee:	f890 308c 	ldrb.w	r3, [r0, #140]	; 0x8c
  402ef2:	7073      	strb	r3, [r6, #1]
			pe->type = (uint8_t) (EVENTGROUP_OBJCLOSE_PROP + objectclass);
  402ef4:	3410      	adds	r4, #16
  402ef6:	7034      	strb	r4, [r6, #0]
			prvTraceUpdateCounters();
  402ef8:	4b0e      	ldr	r3, [pc, #56]	; (402f34 <prvTraceStoreObjectPropertiesOnCloseEvent+0x98>)
  402efa:	4798      	blx	r3
  402efc:	e7dc      	b.n	402eb8 <prvTraceStoreObjectPropertiesOnCloseEvent+0x1c>
				pe->arg1 = TRACE_PROPERTY_ACTOR_PRIORITY(objectclass, handle);
  402efe:	2103      	movs	r1, #3
  402f00:	4628      	mov	r0, r5
  402f02:	4b0b      	ldr	r3, [pc, #44]	; (402f30 <prvTraceStoreObjectPropertiesOnCloseEvent+0x94>)
  402f04:	4798      	blx	r3
  402f06:	4b05      	ldr	r3, [pc, #20]	; (402f1c <prvTraceStoreObjectPropertiesOnCloseEvent+0x80>)
  402f08:	681b      	ldr	r3, [r3, #0]
  402f0a:	f893 206f 	ldrb.w	r2, [r3, #111]	; 0x6f
  402f0e:	4403      	add	r3, r0
  402f10:	4413      	add	r3, r2
  402f12:	f893 308d 	ldrb.w	r3, [r3, #141]	; 0x8d
  402f16:	7073      	strb	r3, [r6, #1]
  402f18:	e7ec      	b.n	402ef4 <prvTraceStoreObjectPropertiesOnCloseEvent+0x58>
  402f1a:	bf00      	nop
  402f1c:	2000a5bc 	.word	0x2000a5bc
  402f20:	00404d14 	.word	0x00404d14
  402f24:	00402a91 	.word	0x00402a91
  402f28:	00404d6c 	.word	0x00404d6c
  402f2c:	00402ad5 	.word	0x00402ad5
  402f30:	00402db1 	.word	0x00402db1
  402f34:	00402bad 	.word	0x00402bad

00402f38 <prvTraceSetPriorityProperty>:
{
  402f38:	b538      	push	{r3, r4, r5, lr}
  402f3a:	4604      	mov	r4, r0
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
  402f3c:	2806      	cmp	r0, #6
  402f3e:	d815      	bhi.n	402f6c <prvTraceSetPriorityProperty+0x34>
  402f40:	4608      	mov	r0, r1
  402f42:	4615      	mov	r5, r2
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
  402f44:	4b0d      	ldr	r3, [pc, #52]	; (402f7c <prvTraceSetPriorityProperty+0x44>)
  402f46:	681b      	ldr	r3, [r3, #0]
  402f48:	4423      	add	r3, r4
  402f4a:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
  402f4e:	428b      	cmp	r3, r1
  402f50:	d310      	bcc.n	402f74 <prvTraceSetPriorityProperty+0x3c>
	TRACE_PROPERTY_ACTOR_PRIORITY(objectclass, id) = value;
  402f52:	4621      	mov	r1, r4
  402f54:	4b0a      	ldr	r3, [pc, #40]	; (402f80 <prvTraceSetPriorityProperty+0x48>)
  402f56:	4798      	blx	r3
  402f58:	4b08      	ldr	r3, [pc, #32]	; (402f7c <prvTraceSetPriorityProperty+0x44>)
  402f5a:	681b      	ldr	r3, [r3, #0]
  402f5c:	441c      	add	r4, r3
  402f5e:	f894 206c 	ldrb.w	r2, [r4, #108]	; 0x6c
  402f62:	4418      	add	r0, r3
  402f64:	4410      	add	r0, r2
  402f66:	f880 508d 	strb.w	r5, [r0, #141]	; 0x8d
  402f6a:	bd38      	pop	{r3, r4, r5, pc}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
  402f6c:	4805      	ldr	r0, [pc, #20]	; (402f84 <prvTraceSetPriorityProperty+0x4c>)
  402f6e:	4b06      	ldr	r3, [pc, #24]	; (402f88 <prvTraceSetPriorityProperty+0x50>)
  402f70:	4798      	blx	r3
  402f72:	bd38      	pop	{r3, r4, r5, pc}
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
  402f74:	4805      	ldr	r0, [pc, #20]	; (402f8c <prvTraceSetPriorityProperty+0x54>)
  402f76:	4b04      	ldr	r3, [pc, #16]	; (402f88 <prvTraceSetPriorityProperty+0x50>)
  402f78:	4798      	blx	r3
  402f7a:	bd38      	pop	{r3, r4, r5, pc}
  402f7c:	2000a5bc 	.word	0x2000a5bc
  402f80:	00402db1 	.word	0x00402db1
  402f84:	004048f8 	.word	0x004048f8
  402f88:	00402a91 	.word	0x00402a91
  402f8c:	00404944 	.word	0x00404944

00402f90 <prvTraceGetPriorityProperty>:
{
  402f90:	b510      	push	{r4, lr}
  402f92:	4604      	mov	r4, r0
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
  402f94:	2806      	cmp	r0, #6
  402f96:	d814      	bhi.n	402fc2 <prvTraceGetPriorityProperty+0x32>
  402f98:	4608      	mov	r0, r1
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
  402f9a:	4b0f      	ldr	r3, [pc, #60]	; (402fd8 <prvTraceGetPriorityProperty+0x48>)
  402f9c:	681b      	ldr	r3, [r3, #0]
  402f9e:	4423      	add	r3, r4
  402fa0:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
  402fa4:	428b      	cmp	r3, r1
  402fa6:	d311      	bcc.n	402fcc <prvTraceGetPriorityProperty+0x3c>
	return TRACE_PROPERTY_ACTOR_PRIORITY(objectclass, id);
  402fa8:	4621      	mov	r1, r4
  402faa:	4b0c      	ldr	r3, [pc, #48]	; (402fdc <prvTraceGetPriorityProperty+0x4c>)
  402fac:	4798      	blx	r3
  402fae:	4b0a      	ldr	r3, [pc, #40]	; (402fd8 <prvTraceGetPriorityProperty+0x48>)
  402fb0:	681b      	ldr	r3, [r3, #0]
  402fb2:	441c      	add	r4, r3
  402fb4:	f894 206c 	ldrb.w	r2, [r4, #108]	; 0x6c
  402fb8:	4418      	add	r0, r3
  402fba:	4410      	add	r0, r2
  402fbc:	f890 008d 	ldrb.w	r0, [r0, #141]	; 0x8d
}
  402fc0:	bd10      	pop	{r4, pc}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
  402fc2:	4807      	ldr	r0, [pc, #28]	; (402fe0 <prvTraceGetPriorityProperty+0x50>)
  402fc4:	4b07      	ldr	r3, [pc, #28]	; (402fe4 <prvTraceGetPriorityProperty+0x54>)
  402fc6:	4798      	blx	r3
  402fc8:	2000      	movs	r0, #0
  402fca:	bd10      	pop	{r4, pc}
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
  402fcc:	4806      	ldr	r0, [pc, #24]	; (402fe8 <prvTraceGetPriorityProperty+0x58>)
  402fce:	4b05      	ldr	r3, [pc, #20]	; (402fe4 <prvTraceGetPriorityProperty+0x54>)
  402fd0:	4798      	blx	r3
  402fd2:	2000      	movs	r0, #0
  402fd4:	bd10      	pop	{r4, pc}
  402fd6:	bf00      	nop
  402fd8:	2000a5bc 	.word	0x2000a5bc
  402fdc:	00402db1 	.word	0x00402db1
  402fe0:	004045f0 	.word	0x004045f0
  402fe4:	00402a91 	.word	0x00402a91
  402fe8:	0040463c 	.word	0x0040463c

00402fec <prvTraceSetObjectState>:
{
  402fec:	b538      	push	{r3, r4, r5, lr}
  402fee:	4604      	mov	r4, r0
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
  402ff0:	2806      	cmp	r0, #6
  402ff2:	d815      	bhi.n	403020 <prvTraceSetObjectState+0x34>
  402ff4:	4608      	mov	r0, r1
  402ff6:	4615      	mov	r5, r2
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
  402ff8:	4b0d      	ldr	r3, [pc, #52]	; (403030 <prvTraceSetObjectState+0x44>)
  402ffa:	681b      	ldr	r3, [r3, #0]
  402ffc:	4423      	add	r3, r4
  402ffe:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
  403002:	428b      	cmp	r3, r1
  403004:	d310      	bcc.n	403028 <prvTraceSetObjectState+0x3c>
	TRACE_PROPERTY_OBJECT_STATE(objectclass, id) = value;
  403006:	4621      	mov	r1, r4
  403008:	4b0a      	ldr	r3, [pc, #40]	; (403034 <prvTraceSetObjectState+0x48>)
  40300a:	4798      	blx	r3
  40300c:	4b08      	ldr	r3, [pc, #32]	; (403030 <prvTraceSetObjectState+0x44>)
  40300e:	681b      	ldr	r3, [r3, #0]
  403010:	441c      	add	r4, r3
  403012:	f894 206c 	ldrb.w	r2, [r4, #108]	; 0x6c
  403016:	4418      	add	r0, r3
  403018:	4410      	add	r0, r2
  40301a:	f880 508c 	strb.w	r5, [r0, #140]	; 0x8c
  40301e:	bd38      	pop	{r3, r4, r5, pc}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
  403020:	4805      	ldr	r0, [pc, #20]	; (403038 <prvTraceSetObjectState+0x4c>)
  403022:	4b06      	ldr	r3, [pc, #24]	; (40303c <prvTraceSetObjectState+0x50>)
  403024:	4798      	blx	r3
  403026:	bd38      	pop	{r3, r4, r5, pc}
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
  403028:	4805      	ldr	r0, [pc, #20]	; (403040 <prvTraceSetObjectState+0x54>)
  40302a:	4b04      	ldr	r3, [pc, #16]	; (40303c <prvTraceSetObjectState+0x50>)
  40302c:	4798      	blx	r3
  40302e:	bd38      	pop	{r3, r4, r5, pc}
  403030:	2000a5bc 	.word	0x2000a5bc
  403034:	00402db1 	.word	0x00402db1
  403038:	00404878 	.word	0x00404878
  40303c:	00402a91 	.word	0x00402a91
  403040:	004048bc 	.word	0x004048bc

00403044 <prvTraceSetTaskInstanceFinished>:
{
  403044:	b508      	push	{r3, lr}
	TRACE_ASSERT(handle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[TRACE_CLASS_TASK],
  403046:	4b0b      	ldr	r3, [pc, #44]	; (403074 <prvTraceSetTaskInstanceFinished+0x30>)
  403048:	681b      	ldr	r3, [r3, #0]
  40304a:	f893 3067 	ldrb.w	r3, [r3, #103]	; 0x67
  40304e:	4283      	cmp	r3, r0
  403050:	d30c      	bcc.n	40306c <prvTraceSetTaskInstanceFinished+0x28>
	TRACE_PROPERTY_OBJECT_STATE(TRACE_CLASS_TASK, handle) = 0;
  403052:	2103      	movs	r1, #3
  403054:	4b08      	ldr	r3, [pc, #32]	; (403078 <prvTraceSetTaskInstanceFinished+0x34>)
  403056:	4798      	blx	r3
  403058:	4b06      	ldr	r3, [pc, #24]	; (403074 <prvTraceSetTaskInstanceFinished+0x30>)
  40305a:	681b      	ldr	r3, [r3, #0]
  40305c:	f893 206f 	ldrb.w	r2, [r3, #111]	; 0x6f
  403060:	4418      	add	r0, r3
  403062:	4410      	add	r0, r2
  403064:	2300      	movs	r3, #0
  403066:	f880 308c 	strb.w	r3, [r0, #140]	; 0x8c
  40306a:	bd08      	pop	{r3, pc}
	TRACE_ASSERT(handle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[TRACE_CLASS_TASK],
  40306c:	4803      	ldr	r0, [pc, #12]	; (40307c <prvTraceSetTaskInstanceFinished+0x38>)
  40306e:	4b04      	ldr	r3, [pc, #16]	; (403080 <prvTraceSetTaskInstanceFinished+0x3c>)
  403070:	4798      	blx	r3
  403072:	bd08      	pop	{r3, pc}
  403074:	2000a5bc 	.word	0x2000a5bc
  403078:	00402db1 	.word	0x00402db1
  40307c:	00404984 	.word	0x00404984
  403080:	00402a91 	.word	0x00402a91

00403084 <prvTraceGetObjectHandle>:
{
  403084:	b510      	push	{r4, lr}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
  403086:	2806      	cmp	r0, #6
  403088:	d833      	bhi.n	4030f2 <prvTraceGetObjectHandle+0x6e>
	indexOfHandle = objectHandleStacks.indexOfNextAvailableHandle[objectclass];
  40308a:	4a46      	ldr	r2, [pc, #280]	; (4031a4 <prvTraceGetObjectHandle+0x120>)
  40308c:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
	if (objectHandleStacks.objectHandles[indexOfHandle] == 0)
  403090:	441a      	add	r2, r3
  403092:	f892 2038 	ldrb.w	r2, [r2, #56]	; 0x38
  403096:	b942      	cbnz	r2, 4030aa <prvTraceGetObjectHandle+0x26>
		objectHandleStacks.objectHandles[indexOfHandle] =
  403098:	4942      	ldr	r1, [pc, #264]	; (4031a4 <prvTraceGetObjectHandle+0x120>)
  40309a:	18cc      	adds	r4, r1, r3
			(traceHandle)(1 + indexOfHandle -
  40309c:	1c5a      	adds	r2, r3, #1
			objectHandleStacks.lowestIndexOfClass[objectclass]);
  40309e:	eb01 0140 	add.w	r1, r1, r0, lsl #1
			(traceHandle)(1 + indexOfHandle -
  4030a2:	7b89      	ldrb	r1, [r1, #14]
  4030a4:	1a52      	subs	r2, r2, r1
		objectHandleStacks.objectHandles[indexOfHandle] =
  4030a6:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38
		> objectHandleStacks.highestIndexOfClass[objectclass])
  4030aa:	4a3e      	ldr	r2, [pc, #248]	; (4031a4 <prvTraceGetObjectHandle+0x120>)
  4030ac:	eb02 0240 	add.w	r2, r2, r0, lsl #1
	if (objectHandleStacks.indexOfNextAvailableHandle[objectclass]
  4030b0:	8b92      	ldrh	r2, [r2, #28]
  4030b2:	429a      	cmp	r2, r3
  4030b4:	d323      	bcc.n	4030fe <prvTraceGetObjectHandle+0x7a>
	handle = objectHandleStacks.objectHandles[indexOfHandle];
  4030b6:	4a3b      	ldr	r2, [pc, #236]	; (4031a4 <prvTraceGetObjectHandle+0x120>)
  4030b8:	18d1      	adds	r1, r2, r3
  4030ba:	f891 1038 	ldrb.w	r1, [r1, #56]	; 0x38
		objectHandleStacks.indexOfNextAvailableHandle[objectclass]++;
  4030be:	3301      	adds	r3, #1
  4030c0:	b29b      	uxth	r3, r3
  4030c2:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
			objectHandleStacks.lowestIndexOfClass[objectclass];
  4030c6:	eb02 0440 	add.w	r4, r2, r0, lsl #1
  4030ca:	89e4      	ldrh	r4, [r4, #14]
		hndCount = objectHandleStacks.indexOfNextAvailableHandle[objectclass] -
  4030cc:	1b1b      	subs	r3, r3, r4
			objectHandleStacks.handleCountWaterMarksOfClass[objectclass])
  4030ce:	eb02 0240 	add.w	r2, r2, r0, lsl #1
  4030d2:	8d52      	ldrh	r2, [r2, #42]	; 0x2a
		if (hndCount >
  4030d4:	4293      	cmp	r3, r2
  4030d6:	dd04      	ble.n	4030e2 <prvTraceGetObjectHandle+0x5e>
			objectHandleStacks.handleCountWaterMarksOfClass[objectclass] =
  4030d8:	4a32      	ldr	r2, [pc, #200]	; (4031a4 <prvTraceGetObjectHandle+0x120>)
  4030da:	eb02 0240 	add.w	r2, r2, r0, lsl #1
				(traceHandle)hndCount;
  4030de:	b2db      	uxtb	r3, r3
  4030e0:	8553      	strh	r3, [r2, #42]	; 0x2a
		TRACE_CLEAR_OBJECT_FLAG_ISEXCLUDED(objectclass, handle);
  4030e2:	2806      	cmp	r0, #6
  4030e4:	d809      	bhi.n	4030fa <prvTraceGetObjectHandle+0x76>
  4030e6:	e8df f000 	tbb	[pc, r0]
  4030ea:	1c10      	.short	0x1c10
  4030ec:	43083629 	.word	0x43083629
  4030f0:	50          	.byte	0x50
  4030f1:	00          	.byte	0x00
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
  4030f2:	482d      	ldr	r0, [pc, #180]	; (4031a8 <prvTraceGetObjectHandle+0x124>)
  4030f4:	4b2d      	ldr	r3, [pc, #180]	; (4031ac <prvTraceGetObjectHandle+0x128>)
  4030f6:	4798      	blx	r3
  4030f8:	2100      	movs	r1, #0
}
  4030fa:	4608      	mov	r0, r1
  4030fc:	bd10      	pop	{r4, pc}
		prvTraceError(pszTraceGetErrorNotEnoughHandles(objectclass));
  4030fe:	4b2c      	ldr	r3, [pc, #176]	; (4031b0 <prvTraceGetObjectHandle+0x12c>)
  403100:	4798      	blx	r3
  403102:	4b2a      	ldr	r3, [pc, #168]	; (4031ac <prvTraceGetObjectHandle+0x128>)
  403104:	4798      	blx	r3
		handle = 0;
  403106:	2100      	movs	r1, #0
  403108:	e7f7      	b.n	4030fa <prvTraceGetObjectHandle+0x76>
		TRACE_CLEAR_OBJECT_FLAG_ISEXCLUDED(objectclass, handle);
  40310a:	08cb      	lsrs	r3, r1, #3
  40310c:	4c29      	ldr	r4, [pc, #164]	; (4031b4 <prvTraceGetObjectHandle+0x130>)
  40310e:	f001 0007 	and.w	r0, r1, #7
  403112:	2201      	movs	r2, #1
  403114:	fa02 f000 	lsl.w	r0, r2, r0
  403118:	5ce2      	ldrb	r2, [r4, r3]
  40311a:	ea22 0200 	bic.w	r2, r2, r0
  40311e:	54e2      	strb	r2, [r4, r3]
  403120:	e7eb      	b.n	4030fa <prvTraceGetObjectHandle+0x76>
  403122:	f101 030b 	add.w	r3, r1, #11
  403126:	10d8      	asrs	r0, r3, #3
  403128:	4c22      	ldr	r4, [pc, #136]	; (4031b4 <prvTraceGetObjectHandle+0x130>)
  40312a:	f003 0307 	and.w	r3, r3, #7
  40312e:	2201      	movs	r2, #1
  403130:	409a      	lsls	r2, r3
  403132:	5c23      	ldrb	r3, [r4, r0]
  403134:	ea23 0302 	bic.w	r3, r3, r2
  403138:	5423      	strb	r3, [r4, r0]
  40313a:	e7de      	b.n	4030fa <prvTraceGetObjectHandle+0x76>
  40313c:	f101 0316 	add.w	r3, r1, #22
  403140:	10d8      	asrs	r0, r3, #3
  403142:	4c1c      	ldr	r4, [pc, #112]	; (4031b4 <prvTraceGetObjectHandle+0x130>)
  403144:	f003 0307 	and.w	r3, r3, #7
  403148:	2201      	movs	r2, #1
  40314a:	409a      	lsls	r2, r3
  40314c:	5c23      	ldrb	r3, [r4, r0]
  40314e:	ea23 0302 	bic.w	r3, r3, r2
  403152:	5423      	strb	r3, [r4, r0]
  403154:	e7d1      	b.n	4030fa <prvTraceGetObjectHandle+0x76>
  403156:	f101 0321 	add.w	r3, r1, #33	; 0x21
  40315a:	10d8      	asrs	r0, r3, #3
  40315c:	4c15      	ldr	r4, [pc, #84]	; (4031b4 <prvTraceGetObjectHandle+0x130>)
  40315e:	f003 0307 	and.w	r3, r3, #7
  403162:	2201      	movs	r2, #1
  403164:	409a      	lsls	r2, r3
  403166:	5c23      	ldrb	r3, [r4, r0]
  403168:	ea23 0302 	bic.w	r3, r3, r2
  40316c:	5423      	strb	r3, [r4, r0]
  40316e:	e7c4      	b.n	4030fa <prvTraceGetObjectHandle+0x76>
  403170:	f101 032c 	add.w	r3, r1, #44	; 0x2c
  403174:	10d8      	asrs	r0, r3, #3
  403176:	4c0f      	ldr	r4, [pc, #60]	; (4031b4 <prvTraceGetObjectHandle+0x130>)
  403178:	f003 0307 	and.w	r3, r3, #7
  40317c:	2201      	movs	r2, #1
  40317e:	409a      	lsls	r2, r3
  403180:	5c23      	ldrb	r3, [r4, r0]
  403182:	ea23 0302 	bic.w	r3, r3, r2
  403186:	5423      	strb	r3, [r4, r0]
  403188:	e7b7      	b.n	4030fa <prvTraceGetObjectHandle+0x76>
  40318a:	f101 0332 	add.w	r3, r1, #50	; 0x32
  40318e:	10d8      	asrs	r0, r3, #3
  403190:	4c08      	ldr	r4, [pc, #32]	; (4031b4 <prvTraceGetObjectHandle+0x130>)
  403192:	f003 0307 	and.w	r3, r3, #7
  403196:	2201      	movs	r2, #1
  403198:	409a      	lsls	r2, r3
  40319a:	5c23      	ldrb	r3, [r4, r0]
  40319c:	ea23 0302 	bic.w	r3, r3, r2
  4031a0:	5423      	strb	r3, [r4, r0]
  4031a2:	e7aa      	b.n	4030fa <prvTraceGetObjectHandle+0x76>
  4031a4:	2000a5e0 	.word	0x2000a5e0
  4031a8:	0040456c 	.word	0x0040456c
  4031ac:	00402a91 	.word	0x00402a91
  4031b0:	0040292d 	.word	0x0040292d
  4031b4:	2000a688 	.word	0x2000a688

004031b8 <prvTraceFreeObjectHandle>:
{
  4031b8:	b510      	push	{r4, lr}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
  4031ba:	2806      	cmp	r0, #6
  4031bc:	d819      	bhi.n	4031f2 <prvTraceFreeObjectHandle+0x3a>
	TRACE_ASSERT(handle > 0 && handle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], 
  4031be:	b1e1      	cbz	r1, 4031fa <prvTraceFreeObjectHandle+0x42>
  4031c0:	4b12      	ldr	r3, [pc, #72]	; (40320c <prvTraceFreeObjectHandle+0x54>)
  4031c2:	681b      	ldr	r3, [r3, #0]
  4031c4:	4403      	add	r3, r0
  4031c6:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
  4031ca:	428b      	cmp	r3, r1
  4031cc:	d315      	bcc.n	4031fa <prvTraceFreeObjectHandle+0x42>
	if ((objectHandleStacks.indexOfNextAvailableHandle[objectclass] - 1) <
  4031ce:	4a10      	ldr	r2, [pc, #64]	; (403210 <prvTraceFreeObjectHandle+0x58>)
  4031d0:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
  4031d4:	1e5c      	subs	r4, r3, #1
		objectHandleStacks.lowestIndexOfClass[objectclass])
  4031d6:	eb02 0240 	add.w	r2, r2, r0, lsl #1
  4031da:	89d2      	ldrh	r2, [r2, #14]
	if ((objectHandleStacks.indexOfNextAvailableHandle[objectclass] - 1) <
  4031dc:	4294      	cmp	r4, r2
  4031de:	db10      	blt.n	403202 <prvTraceFreeObjectHandle+0x4a>
		objectHandleStacks.indexOfNextAvailableHandle[objectclass]--;
  4031e0:	3b01      	subs	r3, #1
  4031e2:	b29b      	uxth	r3, r3
  4031e4:	4a0a      	ldr	r2, [pc, #40]	; (403210 <prvTraceFreeObjectHandle+0x58>)
  4031e6:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
		objectHandleStacks.objectHandles[indexOfHandle] = handle;
  4031ea:	4413      	add	r3, r2
  4031ec:	f883 1038 	strb.w	r1, [r3, #56]	; 0x38
  4031f0:	bd10      	pop	{r4, pc}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
  4031f2:	4808      	ldr	r0, [pc, #32]	; (403214 <prvTraceFreeObjectHandle+0x5c>)
  4031f4:	4b08      	ldr	r3, [pc, #32]	; (403218 <prvTraceFreeObjectHandle+0x60>)
  4031f6:	4798      	blx	r3
  4031f8:	bd10      	pop	{r4, pc}
	TRACE_ASSERT(handle > 0 && handle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], 
  4031fa:	4808      	ldr	r0, [pc, #32]	; (40321c <prvTraceFreeObjectHandle+0x64>)
  4031fc:	4b06      	ldr	r3, [pc, #24]	; (403218 <prvTraceFreeObjectHandle+0x60>)
  4031fe:	4798      	blx	r3
  403200:	bd10      	pop	{r4, pc}
		prvTraceError("Attempt to free more handles than allocated!");
  403202:	4807      	ldr	r0, [pc, #28]	; (403220 <prvTraceFreeObjectHandle+0x68>)
  403204:	4b04      	ldr	r3, [pc, #16]	; (403218 <prvTraceFreeObjectHandle+0x60>)
  403206:	4798      	blx	r3
  403208:	bd10      	pop	{r4, pc}
  40320a:	bf00      	nop
  40320c:	2000a5bc 	.word	0x2000a5bc
  403210:	2000a5e0 	.word	0x2000a5e0
  403214:	0040444c 	.word	0x0040444c
  403218:	00402a91 	.word	0x00402a91
  40321c:	00404494 	.word	0x00404494
  403220:	004044d8 	.word	0x004044d8

00403224 <prvTraceSetObjectName>:
{
  403224:	b538      	push	{r3, r4, r5, lr}
	TRACE_ASSERT(name != NULL, "prvTraceSetObjectName: name == NULL", TRC_UNUSED);
  403226:	b19a      	cbz	r2, 403250 <prvTraceSetObjectName+0x2c>
  403228:	4604      	mov	r4, r0
  40322a:	4608      	mov	r0, r1
  40322c:	4615      	mov	r5, r2
	if (objectclass >= TRACE_NCLASSES)
  40322e:	2c06      	cmp	r4, #6
  403230:	d812      	bhi.n	403258 <prvTraceSetObjectName+0x34>
	if (handle == 0)
  403232:	b1a9      	cbz	r1, 403260 <prvTraceSetObjectName+0x3c>
	if (handle > RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass])
  403234:	4b15      	ldr	r3, [pc, #84]	; (40328c <prvTraceSetObjectName+0x68>)
  403236:	681b      	ldr	r3, [r3, #0]
  403238:	4423      	add	r3, r4
  40323a:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
  40323e:	428b      	cmp	r3, r1
  403240:	d312      	bcc.n	403268 <prvTraceSetObjectName+0x44>
		idx = uiIndexOfObject(handle, objectclass);
  403242:	4621      	mov	r1, r4
  403244:	4b12      	ldr	r3, [pc, #72]	; (403290 <prvTraceSetObjectName+0x6c>)
  403246:	4798      	blx	r3
		if (traceErrorMessage == NULL)
  403248:	4b12      	ldr	r3, [pc, #72]	; (403294 <prvTraceSetObjectName+0x70>)
  40324a:	681b      	ldr	r3, [r3, #0]
  40324c:	b193      	cbz	r3, 403274 <prvTraceSetObjectName+0x50>
  40324e:	bd38      	pop	{r3, r4, r5, pc}
	TRACE_ASSERT(name != NULL, "prvTraceSetObjectName: name == NULL", TRC_UNUSED);
  403250:	4811      	ldr	r0, [pc, #68]	; (403298 <prvTraceSetObjectName+0x74>)
  403252:	4b12      	ldr	r3, [pc, #72]	; (40329c <prvTraceSetObjectName+0x78>)
  403254:	4798      	blx	r3
  403256:	bd38      	pop	{r3, r4, r5, pc}
		prvTraceError("Illegal object class in prvTraceSetObjectName");
  403258:	4811      	ldr	r0, [pc, #68]	; (4032a0 <prvTraceSetObjectName+0x7c>)
  40325a:	4b10      	ldr	r3, [pc, #64]	; (40329c <prvTraceSetObjectName+0x78>)
  40325c:	4798      	blx	r3
		return;
  40325e:	bd38      	pop	{r3, r4, r5, pc}
		prvTraceError("Illegal handle (0) in prvTraceSetObjectName.");
  403260:	4810      	ldr	r0, [pc, #64]	; (4032a4 <prvTraceSetObjectName+0x80>)
  403262:	4b0e      	ldr	r3, [pc, #56]	; (40329c <prvTraceSetObjectName+0x78>)
  403264:	4798      	blx	r3
		return;
  403266:	bd38      	pop	{r3, r4, r5, pc}
		prvTraceError(pszTraceGetErrorNotEnoughHandles(objectclass));
  403268:	4620      	mov	r0, r4
  40326a:	4b0f      	ldr	r3, [pc, #60]	; (4032a8 <prvTraceSetObjectName+0x84>)
  40326c:	4798      	blx	r3
  40326e:	4b0b      	ldr	r3, [pc, #44]	; (40329c <prvTraceSetObjectName+0x78>)
  403270:	4798      	blx	r3
  403272:	bd38      	pop	{r3, r4, r5, pc}
			prvStrncpy((char*)&(RecorderDataPtr->ObjectPropertyTable.objbytes[idx]),
  403274:	4b05      	ldr	r3, [pc, #20]	; (40328c <prvTraceSetObjectName+0x68>)
  403276:	681b      	ldr	r3, [r3, #0]
				RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[ objectclass ]);
  403278:	441c      	add	r4, r3
			prvStrncpy((char*)&(RecorderDataPtr->ObjectPropertyTable.objbytes[idx]),
  40327a:	308c      	adds	r0, #140	; 0x8c
  40327c:	f894 206c 	ldrb.w	r2, [r4, #108]	; 0x6c
  403280:	4629      	mov	r1, r5
  403282:	4418      	add	r0, r3
  403284:	4b09      	ldr	r3, [pc, #36]	; (4032ac <prvTraceSetObjectName+0x88>)
  403286:	4798      	blx	r3
  403288:	e7e1      	b.n	40324e <prvTraceSetObjectName+0x2a>
  40328a:	bf00      	nop
  40328c:	2000a5bc 	.word	0x2000a5bc
  403290:	00402db1 	.word	0x00402db1
  403294:	2000a65c 	.word	0x2000a65c
  403298:	004047e4 	.word	0x004047e4
  40329c:	00402a91 	.word	0x00402a91
  4032a0:	00404818 	.word	0x00404818
  4032a4:	00404848 	.word	0x00404848
  4032a8:	0040292d 	.word	0x0040292d
  4032ac:	00402a4d 	.word	0x00402a4d

004032b0 <prvTraceInitCortexM>:

/* If using DWT timestamping (default on ARM Cortex-M3, M4 and M7), make sure the DWT unit is initialized. */
#ifndef TRC_CFG_ARM_CM_USE_SYSTICK
#if ((TRC_CFG_HARDWARE_PORT == TRC_HARDWARE_PORT_ARM_Cortex_M) && (defined (__CORTEX_M) && (__CORTEX_M >= 0x03)))
void prvTraceInitCortexM()
{
  4032b0:	b508      	push	{r3, lr}
	/* Ensure that the DWT registers are unlocked and can be modified. */
	TRC_REG_ITM_LOCKACCESS = TRC_ITM_LOCKACCESS_UNLOCK;
  4032b2:	4a11      	ldr	r2, [pc, #68]	; (4032f8 <prvTraceInitCortexM+0x48>)
  4032b4:	4b11      	ldr	r3, [pc, #68]	; (4032fc <prvTraceInitCortexM+0x4c>)
  4032b6:	601a      	str	r2, [r3, #0]

	/* Make sure DWT is enabled, if supported */
	TRC_REG_DEMCR |= TRC_DEMCR_TRCENA;
  4032b8:	f503 434e 	add.w	r3, r3, #52736	; 0xce00
  4032bc:	334c      	adds	r3, #76	; 0x4c
  4032be:	681a      	ldr	r2, [r3, #0]
  4032c0:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
  4032c4:	601a      	str	r2, [r3, #0]

	do{
		/* Verify that DWT is supported */
		if (TRC_REG_DEMCR == 0)
  4032c6:	681b      	ldr	r3, [r3, #0]
  4032c8:	b16b      	cbz	r3, 4032e6 <prvTraceInitCortexM+0x36>
			prvTraceError("DWT unit not available, see code comment.");
			break;
		}

		/* Verify that DWT_CYCCNT is supported */
		if (TRC_REG_DWT_CTRL & TRC_DWT_CTRL_NOCYCCNT)
  4032ca:	4b0d      	ldr	r3, [pc, #52]	; (403300 <prvTraceInitCortexM+0x50>)
  4032cc:	681b      	ldr	r3, [r3, #0]
  4032ce:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
  4032d2:	d10c      	bne.n	4032ee <prvTraceInitCortexM+0x3e>
			prvTraceError("DWT_CYCCNT not available, see code comment.");
			break;
		}

		/* Reset the cycle counter */
		TRC_REG_DWT_CYCCNT = 0;
  4032d4:	2200      	movs	r2, #0
  4032d6:	4b0b      	ldr	r3, [pc, #44]	; (403304 <prvTraceInitCortexM+0x54>)
  4032d8:	601a      	str	r2, [r3, #0]

		/* Enable the cycle counter */
		TRC_REG_DWT_CTRL |= TRC_DWT_CTRL_CYCCNTENA;
  4032da:	4a09      	ldr	r2, [pc, #36]	; (403300 <prvTraceInitCortexM+0x50>)
  4032dc:	6813      	ldr	r3, [r2, #0]
  4032de:	f043 0301 	orr.w	r3, r3, #1
  4032e2:	6013      	str	r3, [r2, #0]
  4032e4:	bd08      	pop	{r3, pc}
			prvTraceError("DWT unit not available, see code comment.");
  4032e6:	4808      	ldr	r0, [pc, #32]	; (403308 <prvTraceInitCortexM+0x58>)
  4032e8:	4b08      	ldr	r3, [pc, #32]	; (40330c <prvTraceInitCortexM+0x5c>)
  4032ea:	4798      	blx	r3
			break;
  4032ec:	bd08      	pop	{r3, pc}
			prvTraceError("DWT_CYCCNT not available, see code comment.");
  4032ee:	4808      	ldr	r0, [pc, #32]	; (403310 <prvTraceInitCortexM+0x60>)
  4032f0:	4b06      	ldr	r3, [pc, #24]	; (40330c <prvTraceInitCortexM+0x5c>)
  4032f2:	4798      	blx	r3
			break;
  4032f4:	bd08      	pop	{r3, pc}
  4032f6:	bf00      	nop
  4032f8:	c5acce55 	.word	0xc5acce55
  4032fc:	e0001fb0 	.word	0xe0001fb0
  403300:	e0001000 	.word	0xe0001000
  403304:	e0001004 	.word	0xe0001004
  403308:	0040467c 	.word	0x0040467c
  40330c:	00402a91 	.word	0x00402a91
  403310:	004046a8 	.word	0x004046a8

00403314 <prvTracePortGetTimeStamp>:
	static uint32_t last_hwtc_rest = 0;
	uint32_t diff = 0;
	uint32_t diff_scaled = 0;
#endif /*TRC_HWTC_TYPE == TRC_OS_TIMER_INCR || TRC_HWTC_TYPE == TRC_OS_TIMER_DECR*/

	if (trace_disable_timestamp == 1)
  403314:	4b10      	ldr	r3, [pc, #64]	; (403358 <prvTracePortGetTimeStamp+0x44>)
  403316:	681b      	ldr	r3, [r3, #0]
  403318:	2b01      	cmp	r3, #1
  40331a:	d016      	beq.n	40334a <prvTracePortGetTimeStamp+0x36>
{
  40331c:	b410      	push	{r4}
	}

	/* Retrieve TRC_HWTC_COUNT only once since the same value should be used all throughout this function. */
#if (TRC_HWTC_TYPE == TRC_OS_TIMER_INCR || TRC_HWTC_TYPE == TRC_FREE_RUNNING_32BIT_INCR)
	/* Get the increasing tick count */
	hwtc_count = TRC_HWTC_COUNT;
  40331e:	4b0f      	ldr	r3, [pc, #60]	; (40335c <prvTracePortGetTimeStamp+0x48>)
  403320:	6819      	ldr	r1, [r3, #0]
	/* This part handles free running clocks that can be scaled down to avoid too large DTS values.
	Without this, the scaled timestamp will incorrectly wrap at (2^32 / TRC_HWTC_DIVISOR) ticks.
	The scaled timestamp returned from this function is supposed to go from 0 -> 2^32, which in real time would represent (0 -> 2^32 * TRC_HWTC_DIVISOR) ticks. */
	
	/* First we see how long time has passed since the last timestamp call, and we also add the ticks that was lost when we scaled down the last time. */
	diff = (hwtc_count - last_hwtc_count) + last_hwtc_rest;
  403322:	4a0f      	ldr	r2, [pc, #60]	; (403360 <prvTracePortGetTimeStamp+0x4c>)
  403324:	6813      	ldr	r3, [r2, #0]
  403326:	440b      	add	r3, r1
  403328:	4c0e      	ldr	r4, [pc, #56]	; (403364 <prvTracePortGetTimeStamp+0x50>)
  40332a:	6824      	ldr	r4, [r4, #0]
  40332c:	1b1b      	subs	r3, r3, r4
	
	/* Scale down the diff */
	diff_scaled = diff / TRC_HWTC_DIVISOR;
	
	/* Find out how many ticks were lost when scaling down, so we can add them the next time */
	last_hwtc_rest = diff % TRC_HWTC_DIVISOR;
  40332e:	f003 0403 	and.w	r4, r3, #3
  403332:	6014      	str	r4, [r2, #0]

	/* We increase the scaled timestamp by the scaled amount */
	last_timestamp += diff_scaled;
  403334:	4c0c      	ldr	r4, [pc, #48]	; (403368 <prvTracePortGetTimeStamp+0x54>)
  403336:	6822      	ldr	r2, [r4, #0]
  403338:	eb02 0393 	add.w	r3, r2, r3, lsr #2
  40333c:	6023      	str	r3, [r4, #0]
#endif /*(TRC_HWTC_TYPE == TRC_OS_TIMER_INCR || TRC_HWTC_TYPE == TRC_OS_TIMER_DECR)*/

	/* Is anyone interested in the results? */
	if (pTimestamp)
  40333e:	b100      	cbz	r0, 403342 <prvTracePortGetTimeStamp+0x2e>
		*pTimestamp = last_timestamp;
  403340:	6003      	str	r3, [r0, #0]

	/* Store the previous value */
	last_hwtc_count = hwtc_count;
  403342:	4b08      	ldr	r3, [pc, #32]	; (403364 <prvTracePortGetTimeStamp+0x50>)
  403344:	6019      	str	r1, [r3, #0]
}
  403346:	bc10      	pop	{r4}
  403348:	4770      	bx	lr
		if (pTimestamp)
  40334a:	2800      	cmp	r0, #0
  40334c:	d0fc      	beq.n	403348 <prvTracePortGetTimeStamp+0x34>
			*pTimestamp = last_timestamp;
  40334e:	4b06      	ldr	r3, [pc, #24]	; (403368 <prvTracePortGetTimeStamp+0x54>)
  403350:	681b      	ldr	r3, [r3, #0]
  403352:	6003      	str	r3, [r0, #0]
  403354:	4770      	bx	lr
  403356:	bf00      	nop
  403358:	2000a660 	.word	0x2000a660
  40335c:	e0001004 	.word	0xe0001004
  403360:	2000a5d4 	.word	0x2000a5d4
  403364:	2000a5d0 	.word	0x2000a5d0
  403368:	2000a5d8 	.word	0x2000a5d8

0040336c <prvTraceGetDTS>:
{
  40336c:	b530      	push	{r4, r5, lr}
  40336e:	b083      	sub	sp, #12
  403370:	4604      	mov	r4, r0
	uint32_t timestamp = 0;
  403372:	2300      	movs	r3, #0
  403374:	9301      	str	r3, [sp, #4]
	TRACE_ASSERT(param_maxDTS == 0xFF || param_maxDTS == 0xFFFF, "prvTraceGetDTS: Invalid value for param_maxDTS", 0);
  403376:	28ff      	cmp	r0, #255	; 0xff
  403378:	d003      	beq.n	403382 <prvTraceGetDTS+0x16>
  40337a:	f64f 73ff 	movw	r3, #65535	; 0xffff
  40337e:	4298      	cmp	r0, r3
  403380:	d12e      	bne.n	4033e0 <prvTraceGetDTS+0x74>
	if (RecorderDataPtr->frequency == 0)
  403382:	4b34      	ldr	r3, [pc, #208]	; (403454 <prvTraceGetDTS+0xe8>)
  403384:	681b      	ldr	r3, [r3, #0]
  403386:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  403388:	b92a      	cbnz	r2, 403396 <prvTraceGetDTS+0x2a>
		if (timestampFrequency != 0)
  40338a:	4a33      	ldr	r2, [pc, #204]	; (403458 <prvTraceGetDTS+0xec>)
  40338c:	6812      	ldr	r2, [r2, #0]
  40338e:	2a00      	cmp	r2, #0
  403390:	d02b      	beq.n	4033ea <prvTraceGetDTS+0x7e>
			RecorderDataPtr->frequency = timestampFrequency / TRC_HWTC_DIVISOR;
  403392:	0892      	lsrs	r2, r2, #2
  403394:	625a      	str	r2, [r3, #36]	; 0x24
	prvTracePortGetTimeStamp(&timestamp);	
  403396:	a801      	add	r0, sp, #4
  403398:	4b30      	ldr	r3, [pc, #192]	; (40345c <prvTraceGetDTS+0xf0>)
  40339a:	4798      	blx	r3
	dts = timestamp - old_timestamp;
  40339c:	9a01      	ldr	r2, [sp, #4]
  40339e:	4b30      	ldr	r3, [pc, #192]	; (403460 <prvTraceGetDTS+0xf4>)
  4033a0:	6818      	ldr	r0, [r3, #0]
  4033a2:	1a15      	subs	r5, r2, r0
	old_timestamp = timestamp;
  4033a4:	601a      	str	r2, [r3, #0]
	if (RecorderDataPtr->frequency > 0)
  4033a6:	4b2b      	ldr	r3, [pc, #172]	; (403454 <prvTraceGetDTS+0xe8>)
  4033a8:	681b      	ldr	r3, [r3, #0]
  4033aa:	6a59      	ldr	r1, [r3, #36]	; 0x24
  4033ac:	2900      	cmp	r1, #0
  4033ae:	d02b      	beq.n	403408 <prvTraceGetDTS+0x9c>
		if (dts > RecorderDataPtr->frequency)
  4033b0:	428d      	cmp	r5, r1
  4033b2:	d925      	bls.n	403400 <prvTraceGetDTS+0x94>
			RecorderDataPtr->absTimeLastEventSecond += dts / RecorderDataPtr->frequency;
  4033b4:	fbb5 f2f1 	udiv	r2, r5, r1
  4033b8:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  4033ba:	4410      	add	r0, r2
  4033bc:	62d8      	str	r0, [r3, #44]	; 0x2c
			RecorderDataPtr->absTimeLastEvent += dts % RecorderDataPtr->frequency;
  4033be:	fb01 5112 	mls	r1, r1, r2, r5
  4033c2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  4033c4:	4411      	add	r1, r2
  4033c6:	6299      	str	r1, [r3, #40]	; 0x28
		if (RecorderDataPtr->absTimeLastEvent >= RecorderDataPtr->frequency)
  4033c8:	4b22      	ldr	r3, [pc, #136]	; (403454 <prvTraceGetDTS+0xe8>)
  4033ca:	681b      	ldr	r3, [r3, #0]
  4033cc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  4033ce:	6a59      	ldr	r1, [r3, #36]	; 0x24
  4033d0:	428a      	cmp	r2, r1
  4033d2:	d31a      	bcc.n	40340a <prvTraceGetDTS+0x9e>
			RecorderDataPtr->absTimeLastEventSecond++;
  4033d4:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  4033d6:	3001      	adds	r0, #1
  4033d8:	62d8      	str	r0, [r3, #44]	; 0x2c
			RecorderDataPtr->absTimeLastEvent -= RecorderDataPtr->frequency;
  4033da:	1a52      	subs	r2, r2, r1
  4033dc:	629a      	str	r2, [r3, #40]	; 0x28
  4033de:	e014      	b.n	40340a <prvTraceGetDTS+0x9e>
	TRACE_ASSERT(param_maxDTS == 0xFF || param_maxDTS == 0xFFFF, "prvTraceGetDTS: Invalid value for param_maxDTS", 0);
  4033e0:	4820      	ldr	r0, [pc, #128]	; (403464 <prvTraceGetDTS+0xf8>)
  4033e2:	4b21      	ldr	r3, [pc, #132]	; (403468 <prvTraceGetDTS+0xfc>)
  4033e4:	4798      	blx	r3
  4033e6:	2000      	movs	r0, #0
  4033e8:	e013      	b.n	403412 <prvTraceGetDTS+0xa6>
		else if (init_hwtc_count != TRC_HWTC_COUNT)
  4033ea:	4a20      	ldr	r2, [pc, #128]	; (40346c <prvTraceGetDTS+0x100>)
  4033ec:	6811      	ldr	r1, [r2, #0]
  4033ee:	4a20      	ldr	r2, [pc, #128]	; (403470 <prvTraceGetDTS+0x104>)
  4033f0:	6812      	ldr	r2, [r2, #0]
  4033f2:	4291      	cmp	r1, r2
  4033f4:	d0cf      	beq.n	403396 <prvTraceGetDTS+0x2a>
			RecorderDataPtr->frequency = TRC_HWTC_FREQ_HZ / TRC_HWTC_DIVISOR;		
  4033f6:	4a1f      	ldr	r2, [pc, #124]	; (403474 <prvTraceGetDTS+0x108>)
  4033f8:	6812      	ldr	r2, [r2, #0]
  4033fa:	0892      	lsrs	r2, r2, #2
  4033fc:	625a      	str	r2, [r3, #36]	; 0x24
  4033fe:	e7ca      	b.n	403396 <prvTraceGetDTS+0x2a>
			RecorderDataPtr->absTimeLastEvent += dts;
  403400:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  403402:	442a      	add	r2, r5
  403404:	629a      	str	r2, [r3, #40]	; 0x28
  403406:	e7df      	b.n	4033c8 <prvTraceGetDTS+0x5c>
		RecorderDataPtr->absTimeLastEvent = timestamp;
  403408:	629a      	str	r2, [r3, #40]	; 0x28
	if (dts > param_maxDTS)
  40340a:	42a5      	cmp	r5, r4
  40340c:	d803      	bhi.n	403416 <prvTraceGetDTS+0xaa>
	return (uint16_t)dts & param_maxDTS;
  40340e:	ea04 0005 	and.w	r0, r4, r5
}
  403412:	b003      	add	sp, #12
  403414:	bd30      	pop	{r4, r5, pc}
		xts = (XTSEvent*) prvTraceNextFreeEventBufferSlot();
  403416:	4b18      	ldr	r3, [pc, #96]	; (403478 <prvTraceGetDTS+0x10c>)
  403418:	4798      	blx	r3
		if (xts != NULL)
  40341a:	2800      	cmp	r0, #0
  40341c:	d0f7      	beq.n	40340e <prvTraceGetDTS+0xa2>
			if (param_maxDTS == 0xFFFF)
  40341e:	f64f 72ff 	movw	r2, #65535	; 0xffff
  403422:	4294      	cmp	r4, r2
  403424:	d007      	beq.n	403436 <prvTraceGetDTS+0xca>
			else if (param_maxDTS == 0xFF)
  403426:	2cff      	cmp	r4, #255	; 0xff
  403428:	d00c      	beq.n	403444 <prvTraceGetDTS+0xd8>
				prvTraceError("Bad param_maxDTS in prvTraceGetDTS");
  40342a:	4814      	ldr	r0, [pc, #80]	; (40347c <prvTraceGetDTS+0x110>)
  40342c:	4b0e      	ldr	r3, [pc, #56]	; (403468 <prvTraceGetDTS+0xfc>)
  40342e:	4798      	blx	r3
			prvTraceUpdateCounters();
  403430:	4b13      	ldr	r3, [pc, #76]	; (403480 <prvTraceGetDTS+0x114>)
  403432:	4798      	blx	r3
  403434:	e7eb      	b.n	40340e <prvTraceGetDTS+0xa2>
				xts->type = XTS16;
  403436:	22a9      	movs	r2, #169	; 0xa9
  403438:	7002      	strb	r2, [r0, #0]
				xts->xts_16 = (uint16_t)((dts / 0x10000) & 0xFFFF);
  40343a:	0c2a      	lsrs	r2, r5, #16
  40343c:	8042      	strh	r2, [r0, #2]
				xts->xts_8 = 0;
  40343e:	2200      	movs	r2, #0
  403440:	7042      	strb	r2, [r0, #1]
  403442:	e7f5      	b.n	403430 <prvTraceGetDTS+0xc4>
				xts->type = XTS8;
  403444:	22a8      	movs	r2, #168	; 0xa8
  403446:	7002      	strb	r2, [r0, #0]
				xts->xts_16 = (uint16_t)((dts / 0x100) & 0xFFFF);
  403448:	0a2a      	lsrs	r2, r5, #8
  40344a:	8042      	strh	r2, [r0, #2]
				xts->xts_8 = (uint8_t)((dts / 0x1000000) & 0xFF);
  40344c:	0e2a      	lsrs	r2, r5, #24
  40344e:	7042      	strb	r2, [r0, #1]
  403450:	e7ee      	b.n	403430 <prvTraceGetDTS+0xc4>
  403452:	bf00      	nop
  403454:	2000a5bc 	.word	0x2000a5bc
  403458:	2000a658 	.word	0x2000a658
  40345c:	00403315 	.word	0x00403315
  403460:	2000a650 	.word	0x2000a650
  403464:	00404508 	.word	0x00404508
  403468:	00402a91 	.word	0x00402a91
  40346c:	e0001004 	.word	0xe0001004
  403470:	2000be84 	.word	0x2000be84
  403474:	20000000 	.word	0x20000000
  403478:	00402ad5 	.word	0x00402ad5
  40347c:	00404548 	.word	0x00404548
  403480:	00402bad 	.word	0x00402bad

00403484 <prvTraceStoreTaskReady>:
	if (handle == 0)
  403484:	2800      	cmp	r0, #0
  403486:	d041      	beq.n	40350c <prvTraceStoreTaskReady+0x88>
{
  403488:	b570      	push	{r4, r5, r6, lr}
  40348a:	4604      	mov	r4, r0
	if (! readyEventsEnabled)
  40348c:	4a20      	ldr	r2, [pc, #128]	; (403510 <prvTraceStoreTaskReady+0x8c>)
  40348e:	6812      	ldr	r2, [r2, #0]
  403490:	b31a      	cbz	r2, 4034da <prvTraceStoreTaskReady+0x56>
	TRACE_ASSERT(handle <= TRC_CFG_NTASK, "prvTraceStoreTaskReady: Invalid value for handle", TRC_UNUSED);
  403492:	280a      	cmp	r0, #10
  403494:	d822      	bhi.n	4034dc <prvTraceStoreTaskReady+0x58>
	if (recorder_busy)
  403496:	4b1f      	ldr	r3, [pc, #124]	; (403514 <prvTraceStoreTaskReady+0x90>)
  403498:	681b      	ldr	r3, [r3, #0]
  40349a:	bb1b      	cbnz	r3, 4034e4 <prvTraceStoreTaskReady+0x60>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  40349c:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  4034a0:	2301      	movs	r3, #1
  4034a2:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
  4034a6:	4a1b      	ldr	r2, [pc, #108]	; (403514 <prvTraceStoreTaskReady+0x90>)
  4034a8:	6813      	ldr	r3, [r2, #0]
  4034aa:	3301      	adds	r3, #1
  4034ac:	6013      	str	r3, [r2, #0]
	if (RecorderDataPtr->recorderActive) /* Need to repeat this check! */
  4034ae:	4b1a      	ldr	r3, [pc, #104]	; (403518 <prvTraceStoreTaskReady+0x94>)
  4034b0:	681b      	ldr	r3, [r3, #0]
  4034b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4034b4:	b15b      	cbz	r3, 4034ce <prvTraceStoreTaskReady+0x4a>
		if (!TRACE_GET_TASK_FLAG_ISEXCLUDED(handle))
  4034b6:	f100 0321 	add.w	r3, r0, #33	; 0x21
  4034ba:	10da      	asrs	r2, r3, #3
  4034bc:	4917      	ldr	r1, [pc, #92]	; (40351c <prvTraceStoreTaskReady+0x98>)
  4034be:	5c8a      	ldrb	r2, [r1, r2]
  4034c0:	f003 0307 	and.w	r3, r3, #7
  4034c4:	fa42 f303 	asr.w	r3, r2, r3
  4034c8:	f013 0f01 	tst.w	r3, #1
  4034cc:	d00e      	beq.n	4034ec <prvTraceStoreTaskReady+0x68>
	trcCRITICAL_SECTION_END();
  4034ce:	4a11      	ldr	r2, [pc, #68]	; (403514 <prvTraceStoreTaskReady+0x90>)
  4034d0:	6813      	ldr	r3, [r2, #0]
  4034d2:	3b01      	subs	r3, #1
  4034d4:	6013      	str	r3, [r2, #0]
  4034d6:	f385 8810 	msr	PRIMASK, r5
  4034da:	bd70      	pop	{r4, r5, r6, pc}
	TRACE_ASSERT(handle <= TRC_CFG_NTASK, "prvTraceStoreTaskReady: Invalid value for handle", TRC_UNUSED);
  4034dc:	4810      	ldr	r0, [pc, #64]	; (403520 <prvTraceStoreTaskReady+0x9c>)
  4034de:	4b11      	ldr	r3, [pc, #68]	; (403524 <prvTraceStoreTaskReady+0xa0>)
  4034e0:	4798      	blx	r3
  4034e2:	bd70      	pop	{r4, r5, r6, pc}
		prvTraceError("Recorder busy - high priority ISR using syscall? (1)");
  4034e4:	4810      	ldr	r0, [pc, #64]	; (403528 <prvTraceStoreTaskReady+0xa4>)
  4034e6:	4b0f      	ldr	r3, [pc, #60]	; (403524 <prvTraceStoreTaskReady+0xa0>)
  4034e8:	4798      	blx	r3
		return;
  4034ea:	bd70      	pop	{r4, r5, r6, pc}
			dts3 = (uint16_t)prvTraceGetDTS(0xFFFF);
  4034ec:	f64f 70ff 	movw	r0, #65535	; 0xffff
  4034f0:	4b0e      	ldr	r3, [pc, #56]	; (40352c <prvTraceStoreTaskReady+0xa8>)
  4034f2:	4798      	blx	r3
  4034f4:	4606      	mov	r6, r0
			tr = (TREvent*)prvTraceNextFreeEventBufferSlot();
  4034f6:	4b0e      	ldr	r3, [pc, #56]	; (403530 <prvTraceStoreTaskReady+0xac>)
  4034f8:	4798      	blx	r3
			if (tr != NULL)
  4034fa:	2800      	cmp	r0, #0
  4034fc:	d0e7      	beq.n	4034ce <prvTraceStoreTaskReady+0x4a>
				tr->type = DIV_TASK_READY;
  4034fe:	2202      	movs	r2, #2
  403500:	7002      	strb	r2, [r0, #0]
				tr->dts = dts3;
  403502:	8046      	strh	r6, [r0, #2]
				tr->objHandle = hnd8;
  403504:	7044      	strb	r4, [r0, #1]
				prvTraceUpdateCounters();
  403506:	4b0b      	ldr	r3, [pc, #44]	; (403534 <prvTraceStoreTaskReady+0xb0>)
  403508:	4798      	blx	r3
  40350a:	e7e0      	b.n	4034ce <prvTraceStoreTaskReady+0x4a>
  40350c:	4770      	bx	lr
  40350e:	bf00      	nop
  403510:	20000010 	.word	0x20000010
  403514:	2000a654 	.word	0x2000a654
  403518:	2000a5bc 	.word	0x2000a5bc
  40351c:	2000a688 	.word	0x2000a688
  403520:	00404dc0 	.word	0x00404dc0
  403524:	00402a91 	.word	0x00402a91
  403528:	00404e00 	.word	0x00404e00
  40352c:	0040336d 	.word	0x0040336d
  403530:	00402ad5 	.word	0x00402ad5
  403534:	00402bad 	.word	0x00402bad

00403538 <vTraceStoreMemMangEvent>:
{
  403538:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (RecorderDataPtr == NULL)
  40353c:	4b2c      	ldr	r3, [pc, #176]	; (4035f0 <vTraceStoreMemMangEvent+0xb8>)
  40353e:	681b      	ldr	r3, [r3, #0]
  403540:	2b00      	cmp	r3, #0
  403542:	d052      	beq.n	4035ea <vTraceStoreMemMangEvent+0xb2>
		size = (uint32_t)(- signed_size);
  403544:	ea82 76e2 	eor.w	r6, r2, r2, asr #31
  403548:	eba6 76e2 	sub.w	r6, r6, r2, asr #31
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  40354c:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  403550:	2301      	movs	r3, #1
  403552:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
  403556:	4b27      	ldr	r3, [pc, #156]	; (4035f4 <vTraceStoreMemMangEvent+0xbc>)
  403558:	681c      	ldr	r4, [r3, #0]
  40355a:	3401      	adds	r4, #1
  40355c:	601c      	str	r4, [r3, #0]
	heapMemUsage = heapMemUsage + (uint32_t)signed_size;
  40355e:	4c26      	ldr	r4, [pc, #152]	; (4035f8 <vTraceStoreMemMangEvent+0xc0>)
  403560:	6823      	ldr	r3, [r4, #0]
  403562:	4413      	add	r3, r2
  403564:	6023      	str	r3, [r4, #0]
	if (RecorderDataPtr->recorderActive)
  403566:	4b22      	ldr	r3, [pc, #136]	; (4035f0 <vTraceStoreMemMangEvent+0xb8>)
  403568:	681b      	ldr	r3, [r3, #0]
  40356a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40356c:	2b00      	cmp	r3, #0
  40356e:	d036      	beq.n	4035de <vTraceStoreMemMangEvent+0xa6>
		if (nISRactive || !inExcludedTask)
  403570:	4b22      	ldr	r3, [pc, #136]	; (4035fc <vTraceStoreMemMangEvent+0xc4>)
  403572:	f993 3000 	ldrsb.w	r3, [r3]
  403576:	b91b      	cbnz	r3, 403580 <vTraceStoreMemMangEvent+0x48>
  403578:	4b21      	ldr	r3, [pc, #132]	; (403600 <vTraceStoreMemMangEvent+0xc8>)
  40357a:	781b      	ldrb	r3, [r3, #0]
  40357c:	2b00      	cmp	r3, #0
  40357e:	d12e      	bne.n	4035de <vTraceStoreMemMangEvent+0xa6>
  403580:	4688      	mov	r8, r1
  403582:	4607      	mov	r7, r0
			dts1 = (uint8_t)prvTraceGetDTS(0xFF);
  403584:	20ff      	movs	r0, #255	; 0xff
  403586:	4b1f      	ldr	r3, [pc, #124]	; (403604 <vTraceStoreMemMangEvent+0xcc>)
  403588:	4798      	blx	r3
  40358a:	4681      	mov	r9, r0
			size_low = (uint16_t)prvTraceGetParam(0xFFFF, size);
  40358c:	4631      	mov	r1, r6
  40358e:	f64f 70ff 	movw	r0, #65535	; 0xffff
  403592:	4b1d      	ldr	r3, [pc, #116]	; (403608 <vTraceStoreMemMangEvent+0xd0>)
  403594:	4798      	blx	r3
  403596:	4606      	mov	r6, r0
			ms = (MemEventSize *)prvTraceNextFreeEventBufferSlot();
  403598:	4b1c      	ldr	r3, [pc, #112]	; (40360c <vTraceStoreMemMangEvent+0xd4>)
  40359a:	4798      	blx	r3
			if (ms != NULL)
  40359c:	4604      	mov	r4, r0
  40359e:	b1f0      	cbz	r0, 4035de <vTraceStoreMemMangEvent+0xa6>
			dts1 = (uint8_t)prvTraceGetDTS(0xFF);
  4035a0:	f880 9001 	strb.w	r9, [r0, #1]
				ms->type = NULL_EVENT; /* Updated when all events are written */
  4035a4:	2300      	movs	r3, #0
  4035a6:	7003      	strb	r3, [r0, #0]
			size_low = (uint16_t)prvTraceGetParam(0xFFFF, size);
  4035a8:	8046      	strh	r6, [r0, #2]
				prvTraceUpdateCounters();
  4035aa:	4b19      	ldr	r3, [pc, #100]	; (403610 <vTraceStoreMemMangEvent+0xd8>)
  4035ac:	4798      	blx	r3
					addr_low = (uint16_t)prvTraceGetParam(0xFFFF, address);
  4035ae:	4641      	mov	r1, r8
  4035b0:	f64f 70ff 	movw	r0, #65535	; 0xffff
  4035b4:	4b14      	ldr	r3, [pc, #80]	; (403608 <vTraceStoreMemMangEvent+0xd0>)
  4035b6:	4798      	blx	r3
  4035b8:	4606      	mov	r6, r0
				ma = (MemEventAddr *) prvTraceNextFreeEventBufferSlot();
  4035ba:	4b14      	ldr	r3, [pc, #80]	; (40360c <vTraceStoreMemMangEvent+0xd4>)
  4035bc:	4798      	blx	r3
				if (ma != NULL)
  4035be:	4603      	mov	r3, r0
  4035c0:	b168      	cbz	r0, 4035de <vTraceStoreMemMangEvent+0xa6>
					addr_low = (uint16_t)prvTraceGetParam(0xFFFF, address);
  4035c2:	8046      	strh	r6, [r0, #2]
					ma->addr_high = addr_high;
  4035c4:	2200      	movs	r2, #0
  4035c6:	7042      	strb	r2, [r0, #1]
					ma->type = (uint8_t) (ecode  + 1); /* Note this! */
  4035c8:	b2f8      	uxtb	r0, r7
  4035ca:	1c42      	adds	r2, r0, #1
  4035cc:	701a      	strb	r2, [r3, #0]
					ms->type = (uint8_t) ecode;
  4035ce:	7020      	strb	r0, [r4, #0]
					prvTraceUpdateCounters();					
  4035d0:	4b0f      	ldr	r3, [pc, #60]	; (403610 <vTraceStoreMemMangEvent+0xd8>)
  4035d2:	4798      	blx	r3
					RecorderDataPtr->heapMemUsage = heapMemUsage;
  4035d4:	4b06      	ldr	r3, [pc, #24]	; (4035f0 <vTraceStoreMemMangEvent+0xb8>)
  4035d6:	681b      	ldr	r3, [r3, #0]
  4035d8:	4a07      	ldr	r2, [pc, #28]	; (4035f8 <vTraceStoreMemMangEvent+0xc0>)
  4035da:	6812      	ldr	r2, [r2, #0]
  4035dc:	651a      	str	r2, [r3, #80]	; 0x50
	trcCRITICAL_SECTION_END();
  4035de:	4a05      	ldr	r2, [pc, #20]	; (4035f4 <vTraceStoreMemMangEvent+0xbc>)
  4035e0:	6813      	ldr	r3, [r2, #0]
  4035e2:	3b01      	subs	r3, #1
  4035e4:	6013      	str	r3, [r2, #0]
  4035e6:	f385 8810 	msr	PRIMASK, r5
  4035ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4035ee:	bf00      	nop
  4035f0:	2000a5bc 	.word	0x2000a5bc
  4035f4:	2000a654 	.word	0x2000a654
  4035f8:	2000a5c4 	.word	0x2000a5c4
  4035fc:	2000a5dc 	.word	0x2000a5dc
  403600:	2000a5c8 	.word	0x2000a5c8
  403604:	0040336d 	.word	0x0040336d
  403608:	00402d61 	.word	0x00402d61
  40360c:	00402ad5 	.word	0x00402ad5
  403610:	00402bad 	.word	0x00402bad

00403614 <prvTraceStoreKernelCall>:
{
  403614:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  403616:	4604      	mov	r4, r0
	TRACE_ASSERT(ecode < 0xFF, "prvTraceStoreKernelCall: ecode >= 0xFF", TRC_UNUSED);
  403618:	28fe      	cmp	r0, #254	; 0xfe
  40361a:	d839      	bhi.n	403690 <prvTraceStoreKernelCall+0x7c>
  40361c:	4608      	mov	r0, r1
	TRACE_ASSERT(objectClass < TRACE_NCLASSES, "prvTraceStoreKernelCall: objectClass >= TRACE_NCLASSES", TRC_UNUSED);
  40361e:	2906      	cmp	r1, #6
  403620:	d83a      	bhi.n	403698 <prvTraceStoreKernelCall+0x84>
	TRACE_ASSERT(objectNumber <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectClass], "prvTraceStoreKernelCall: Invalid value for objectNumber", TRC_UNUSED);
  403622:	4b2b      	ldr	r3, [pc, #172]	; (4036d0 <prvTraceStoreKernelCall+0xbc>)
  403624:	681b      	ldr	r3, [r3, #0]
  403626:	440b      	add	r3, r1
  403628:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
  40362c:	4293      	cmp	r3, r2
  40362e:	d337      	bcc.n	4036a0 <prvTraceStoreKernelCall+0x8c>
	if (recorder_busy)
  403630:	4b28      	ldr	r3, [pc, #160]	; (4036d4 <prvTraceStoreKernelCall+0xc0>)
  403632:	681b      	ldr	r3, [r3, #0]
  403634:	2b00      	cmp	r3, #0
  403636:	d137      	bne.n	4036a8 <prvTraceStoreKernelCall+0x94>
	if (handle_of_last_logged_task == 0)
  403638:	4b27      	ldr	r3, [pc, #156]	; (4036d8 <prvTraceStoreKernelCall+0xc4>)
  40363a:	781b      	ldrb	r3, [r3, #0]
  40363c:	b33b      	cbz	r3, 40368e <prvTraceStoreKernelCall+0x7a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  40363e:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  403642:	2301      	movs	r3, #1
  403644:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
  403648:	4922      	ldr	r1, [pc, #136]	; (4036d4 <prvTraceStoreKernelCall+0xc0>)
  40364a:	680b      	ldr	r3, [r1, #0]
  40364c:	3301      	adds	r3, #1
  40364e:	600b      	str	r3, [r1, #0]
	if (RecorderDataPtr->recorderActive)
  403650:	4b1f      	ldr	r3, [pc, #124]	; (4036d0 <prvTraceStoreKernelCall+0xbc>)
  403652:	681b      	ldr	r3, [r3, #0]
  403654:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  403656:	b1a3      	cbz	r3, 403682 <prvTraceStoreKernelCall+0x6e>
		if (nISRactive || !inExcludedTask)
  403658:	4b20      	ldr	r3, [pc, #128]	; (4036dc <prvTraceStoreKernelCall+0xc8>)
  40365a:	f993 3000 	ldrsb.w	r3, [r3]
  40365e:	b913      	cbnz	r3, 403666 <prvTraceStoreKernelCall+0x52>
  403660:	4b1f      	ldr	r3, [pc, #124]	; (4036e0 <prvTraceStoreKernelCall+0xcc>)
  403662:	781b      	ldrb	r3, [r3, #0]
  403664:	b96b      	cbnz	r3, 403682 <prvTraceStoreKernelCall+0x6e>
			if (!uiTraceIsObjectExcluded(objectClass, (traceHandle)objectNumber) && !TRACE_GET_EVENT_CODE_FLAG_ISEXCLUDED(ecode))
  403666:	b2d6      	uxtb	r6, r2
  403668:	4631      	mov	r1, r6
  40366a:	4b1e      	ldr	r3, [pc, #120]	; (4036e4 <prvTraceStoreKernelCall+0xd0>)
  40366c:	4798      	blx	r3
  40366e:	b940      	cbnz	r0, 403682 <prvTraceStoreKernelCall+0x6e>
  403670:	08e3      	lsrs	r3, r4, #3
  403672:	4a1d      	ldr	r2, [pc, #116]	; (4036e8 <prvTraceStoreKernelCall+0xd4>)
  403674:	5cd3      	ldrb	r3, [r2, r3]
  403676:	f004 0207 	and.w	r2, r4, #7
  40367a:	4113      	asrs	r3, r2
  40367c:	f013 0f01 	tst.w	r3, #1
  403680:	d016      	beq.n	4036b0 <prvTraceStoreKernelCall+0x9c>
	trcCRITICAL_SECTION_END();
  403682:	4a14      	ldr	r2, [pc, #80]	; (4036d4 <prvTraceStoreKernelCall+0xc0>)
  403684:	6813      	ldr	r3, [r2, #0]
  403686:	3b01      	subs	r3, #1
  403688:	6013      	str	r3, [r2, #0]
  40368a:	f385 8810 	msr	PRIMASK, r5
  40368e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	TRACE_ASSERT(ecode < 0xFF, "prvTraceStoreKernelCall: ecode >= 0xFF", TRC_UNUSED);
  403690:	4816      	ldr	r0, [pc, #88]	; (4036ec <prvTraceStoreKernelCall+0xd8>)
  403692:	4b17      	ldr	r3, [pc, #92]	; (4036f0 <prvTraceStoreKernelCall+0xdc>)
  403694:	4798      	blx	r3
  403696:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	TRACE_ASSERT(objectClass < TRACE_NCLASSES, "prvTraceStoreKernelCall: objectClass >= TRACE_NCLASSES", TRC_UNUSED);
  403698:	4816      	ldr	r0, [pc, #88]	; (4036f4 <prvTraceStoreKernelCall+0xe0>)
  40369a:	4b15      	ldr	r3, [pc, #84]	; (4036f0 <prvTraceStoreKernelCall+0xdc>)
  40369c:	4798      	blx	r3
  40369e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	TRACE_ASSERT(objectNumber <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectClass], "prvTraceStoreKernelCall: Invalid value for objectNumber", TRC_UNUSED);
  4036a0:	4815      	ldr	r0, [pc, #84]	; (4036f8 <prvTraceStoreKernelCall+0xe4>)
  4036a2:	4b13      	ldr	r3, [pc, #76]	; (4036f0 <prvTraceStoreKernelCall+0xdc>)
  4036a4:	4798      	blx	r3
  4036a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		prvTraceError("Recorder busy - high priority ISR using syscall? (2)");
  4036a8:	4814      	ldr	r0, [pc, #80]	; (4036fc <prvTraceStoreKernelCall+0xe8>)
  4036aa:	4b11      	ldr	r3, [pc, #68]	; (4036f0 <prvTraceStoreKernelCall+0xdc>)
  4036ac:	4798      	blx	r3
		return;
  4036ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				dts1 = (uint16_t)prvTraceGetDTS(0xFFFF);
  4036b0:	f64f 70ff 	movw	r0, #65535	; 0xffff
  4036b4:	4b12      	ldr	r3, [pc, #72]	; (403700 <prvTraceStoreKernelCall+0xec>)
  4036b6:	4798      	blx	r3
  4036b8:	4607      	mov	r7, r0
				kse = (KernelCall*) prvTraceNextFreeEventBufferSlot();
  4036ba:	4b12      	ldr	r3, [pc, #72]	; (403704 <prvTraceStoreKernelCall+0xf0>)
  4036bc:	4798      	blx	r3
				if (kse != NULL)
  4036be:	2800      	cmp	r0, #0
  4036c0:	d0df      	beq.n	403682 <prvTraceStoreKernelCall+0x6e>
					kse->dts = dts1;
  4036c2:	8047      	strh	r7, [r0, #2]
					kse->type = (uint8_t)ecode;
  4036c4:	7004      	strb	r4, [r0, #0]
					kse->objHandle = hnd8;
  4036c6:	7046      	strb	r6, [r0, #1]
					prvTraceUpdateCounters();
  4036c8:	4b0f      	ldr	r3, [pc, #60]	; (403708 <prvTraceStoreKernelCall+0xf4>)
  4036ca:	4798      	blx	r3
  4036cc:	e7d9      	b.n	403682 <prvTraceStoreKernelCall+0x6e>
  4036ce:	bf00      	nop
  4036d0:	2000a5bc 	.word	0x2000a5bc
  4036d4:	2000a654 	.word	0x2000a654
  4036d8:	2000a5c0 	.word	0x2000a5c0
  4036dc:	2000a5dc 	.word	0x2000a5dc
  4036e0:	2000a5c8 	.word	0x2000a5c8
  4036e4:	0040297d 	.word	0x0040297d
  4036e8:	2000a664 	.word	0x2000a664
  4036ec:	004049cc 	.word	0x004049cc
  4036f0:	00402a91 	.word	0x00402a91
  4036f4:	00404a04 	.word	0x00404a04
  4036f8:	00404a4c 	.word	0x00404a4c
  4036fc:	00404a94 	.word	0x00404a94
  403700:	0040336d 	.word	0x0040336d
  403704:	00402ad5 	.word	0x00402ad5
  403708:	00402bad 	.word	0x00402bad

0040370c <prvTraceStoreKernelCallWithParam>:
{
  40370c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  403710:	4604      	mov	r4, r0
	TRACE_ASSERT(evtcode < 0xFF, "prvTraceStoreKernelCallWithParam: evtcode >= 0xFF", TRC_UNUSED);
  403712:	28fe      	cmp	r0, #254	; 0xfe
  403714:	d83b      	bhi.n	40378e <prvTraceStoreKernelCallWithParam+0x82>
  403716:	4608      	mov	r0, r1
  403718:	461d      	mov	r5, r3
	TRACE_ASSERT(objectClass < TRACE_NCLASSES, "prvTraceStoreKernelCallWithParam: objectClass >= TRACE_NCLASSES", TRC_UNUSED);
  40371a:	2906      	cmp	r1, #6
  40371c:	d83c      	bhi.n	403798 <prvTraceStoreKernelCallWithParam+0x8c>
	TRACE_ASSERT(objectNumber <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectClass], "prvTraceStoreKernelCallWithParam: Invalid value for objectNumber", TRC_UNUSED);
  40371e:	4b30      	ldr	r3, [pc, #192]	; (4037e0 <prvTraceStoreKernelCallWithParam+0xd4>)
  403720:	681b      	ldr	r3, [r3, #0]
  403722:	440b      	add	r3, r1
  403724:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
  403728:	4293      	cmp	r3, r2
  40372a:	d33a      	bcc.n	4037a2 <prvTraceStoreKernelCallWithParam+0x96>
	if (recorder_busy)
  40372c:	4b2d      	ldr	r3, [pc, #180]	; (4037e4 <prvTraceStoreKernelCallWithParam+0xd8>)
  40372e:	681b      	ldr	r3, [r3, #0]
  403730:	2b00      	cmp	r3, #0
  403732:	d13b      	bne.n	4037ac <prvTraceStoreKernelCallWithParam+0xa0>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  403734:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  403738:	2301      	movs	r3, #1
  40373a:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
  40373e:	4929      	ldr	r1, [pc, #164]	; (4037e4 <prvTraceStoreKernelCallWithParam+0xd8>)
  403740:	680b      	ldr	r3, [r1, #0]
  403742:	3301      	adds	r3, #1
  403744:	600b      	str	r3, [r1, #0]
	if (RecorderDataPtr->recorderActive && handle_of_last_logged_task && (! inExcludedTask || nISRactive))
  403746:	4b26      	ldr	r3, [pc, #152]	; (4037e0 <prvTraceStoreKernelCallWithParam+0xd4>)
  403748:	681b      	ldr	r3, [r3, #0]
  40374a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40374c:	b1bb      	cbz	r3, 40377e <prvTraceStoreKernelCallWithParam+0x72>
  40374e:	4b26      	ldr	r3, [pc, #152]	; (4037e8 <prvTraceStoreKernelCallWithParam+0xdc>)
  403750:	781b      	ldrb	r3, [r3, #0]
  403752:	b1a3      	cbz	r3, 40377e <prvTraceStoreKernelCallWithParam+0x72>
  403754:	4b25      	ldr	r3, [pc, #148]	; (4037ec <prvTraceStoreKernelCallWithParam+0xe0>)
  403756:	781b      	ldrb	r3, [r3, #0]
  403758:	b11b      	cbz	r3, 403762 <prvTraceStoreKernelCallWithParam+0x56>
  40375a:	4b25      	ldr	r3, [pc, #148]	; (4037f0 <prvTraceStoreKernelCallWithParam+0xe4>)
  40375c:	f993 3000 	ldrsb.w	r3, [r3]
  403760:	b16b      	cbz	r3, 40377e <prvTraceStoreKernelCallWithParam+0x72>
		if (!uiTraceIsObjectExcluded(objectClass, (traceHandle)objectNumber) &&
  403762:	b2d7      	uxtb	r7, r2
  403764:	4639      	mov	r1, r7
  403766:	4b23      	ldr	r3, [pc, #140]	; (4037f4 <prvTraceStoreKernelCallWithParam+0xe8>)
  403768:	4798      	blx	r3
  40376a:	b940      	cbnz	r0, 40377e <prvTraceStoreKernelCallWithParam+0x72>
			!TRACE_GET_EVENT_CODE_FLAG_ISEXCLUDED(evtcode))
  40376c:	08e3      	lsrs	r3, r4, #3
  40376e:	4a22      	ldr	r2, [pc, #136]	; (4037f8 <prvTraceStoreKernelCallWithParam+0xec>)
  403770:	5cd3      	ldrb	r3, [r2, r3]
  403772:	f004 0207 	and.w	r2, r4, #7
  403776:	4113      	asrs	r3, r2
		if (!uiTraceIsObjectExcluded(objectClass, (traceHandle)objectNumber) &&
  403778:	f013 0f01 	tst.w	r3, #1
  40377c:	d01b      	beq.n	4037b6 <prvTraceStoreKernelCallWithParam+0xaa>
	trcCRITICAL_SECTION_END();
  40377e:	4a19      	ldr	r2, [pc, #100]	; (4037e4 <prvTraceStoreKernelCallWithParam+0xd8>)
  403780:	6813      	ldr	r3, [r2, #0]
  403782:	3b01      	subs	r3, #1
  403784:	6013      	str	r3, [r2, #0]
  403786:	f386 8810 	msr	PRIMASK, r6
  40378a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	TRACE_ASSERT(evtcode < 0xFF, "prvTraceStoreKernelCallWithParam: evtcode >= 0xFF", TRC_UNUSED);
  40378e:	481b      	ldr	r0, [pc, #108]	; (4037fc <prvTraceStoreKernelCallWithParam+0xf0>)
  403790:	4b1b      	ldr	r3, [pc, #108]	; (403800 <prvTraceStoreKernelCallWithParam+0xf4>)
  403792:	4798      	blx	r3
  403794:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	TRACE_ASSERT(objectClass < TRACE_NCLASSES, "prvTraceStoreKernelCallWithParam: objectClass >= TRACE_NCLASSES", TRC_UNUSED);
  403798:	481a      	ldr	r0, [pc, #104]	; (403804 <prvTraceStoreKernelCallWithParam+0xf8>)
  40379a:	4b19      	ldr	r3, [pc, #100]	; (403800 <prvTraceStoreKernelCallWithParam+0xf4>)
  40379c:	4798      	blx	r3
  40379e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	TRACE_ASSERT(objectNumber <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectClass], "prvTraceStoreKernelCallWithParam: Invalid value for objectNumber", TRC_UNUSED);
  4037a2:	4819      	ldr	r0, [pc, #100]	; (403808 <prvTraceStoreKernelCallWithParam+0xfc>)
  4037a4:	4b16      	ldr	r3, [pc, #88]	; (403800 <prvTraceStoreKernelCallWithParam+0xf4>)
  4037a6:	4798      	blx	r3
  4037a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		prvTraceError("Recorder busy - high priority ISR using syscall? (3)");
  4037ac:	4817      	ldr	r0, [pc, #92]	; (40380c <prvTraceStoreKernelCallWithParam+0x100>)
  4037ae:	4b14      	ldr	r3, [pc, #80]	; (403800 <prvTraceStoreKernelCallWithParam+0xf4>)
  4037b0:	4798      	blx	r3
		return;
  4037b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			dts2 = (uint8_t)prvTraceGetDTS(0xFF);
  4037b6:	20ff      	movs	r0, #255	; 0xff
  4037b8:	4b15      	ldr	r3, [pc, #84]	; (403810 <prvTraceStoreKernelCallWithParam+0x104>)
  4037ba:	4798      	blx	r3
  4037bc:	4680      	mov	r8, r0
			p8 = (uint8_t) prvTraceGetParam(0xFF, param);
  4037be:	4629      	mov	r1, r5
  4037c0:	20ff      	movs	r0, #255	; 0xff
  4037c2:	4b14      	ldr	r3, [pc, #80]	; (403814 <prvTraceStoreKernelCallWithParam+0x108>)
  4037c4:	4798      	blx	r3
  4037c6:	4605      	mov	r5, r0
			kse = (KernelCallWithParamAndHandle*) prvTraceNextFreeEventBufferSlot();
  4037c8:	4b13      	ldr	r3, [pc, #76]	; (403818 <prvTraceStoreKernelCallWithParam+0x10c>)
  4037ca:	4798      	blx	r3
			if (kse != NULL)
  4037cc:	2800      	cmp	r0, #0
  4037ce:	d0d6      	beq.n	40377e <prvTraceStoreKernelCallWithParam+0x72>
			dts2 = (uint8_t)prvTraceGetDTS(0xFF);
  4037d0:	f880 8003 	strb.w	r8, [r0, #3]
				kse->type = (uint8_t)evtcode;
  4037d4:	7004      	strb	r4, [r0, #0]
				kse->objHandle = hnd8;
  4037d6:	7047      	strb	r7, [r0, #1]
			p8 = (uint8_t) prvTraceGetParam(0xFF, param);
  4037d8:	7085      	strb	r5, [r0, #2]
				prvTraceUpdateCounters();
  4037da:	4b10      	ldr	r3, [pc, #64]	; (40381c <prvTraceStoreKernelCallWithParam+0x110>)
  4037dc:	4798      	blx	r3
  4037de:	e7ce      	b.n	40377e <prvTraceStoreKernelCallWithParam+0x72>
  4037e0:	2000a5bc 	.word	0x2000a5bc
  4037e4:	2000a654 	.word	0x2000a654
  4037e8:	2000a5c0 	.word	0x2000a5c0
  4037ec:	2000a5c8 	.word	0x2000a5c8
  4037f0:	2000a5dc 	.word	0x2000a5dc
  4037f4:	0040297d 	.word	0x0040297d
  4037f8:	2000a664 	.word	0x2000a664
  4037fc:	00404b5c 	.word	0x00404b5c
  403800:	00402a91 	.word	0x00402a91
  403804:	00404b9c 	.word	0x00404b9c
  403808:	00404bec 	.word	0x00404bec
  40380c:	00404c3c 	.word	0x00404c3c
  403810:	0040336d 	.word	0x0040336d
  403814:	00402d61 	.word	0x00402d61
  403818:	00402ad5 	.word	0x00402ad5
  40381c:	00402bad 	.word	0x00402bad

00403820 <prvTraceStoreKernelCallWithNumericParamOnly>:
{
  403820:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	TRACE_ASSERT(evtcode < 0xFF, "prvTraceStoreKernelCallWithNumericParamOnly: Invalid value for evtcode", TRC_UNUSED);
  403822:	28fe      	cmp	r0, #254	; 0xfe
  403824:	d82b      	bhi.n	40387e <prvTraceStoreKernelCallWithNumericParamOnly+0x5e>
  403826:	4604      	mov	r4, r0
  403828:	460e      	mov	r6, r1
	if (recorder_busy)
  40382a:	4b23      	ldr	r3, [pc, #140]	; (4038b8 <prvTraceStoreKernelCallWithNumericParamOnly+0x98>)
  40382c:	681b      	ldr	r3, [r3, #0]
  40382e:	bb53      	cbnz	r3, 403886 <prvTraceStoreKernelCallWithNumericParamOnly+0x66>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  403830:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  403834:	2301      	movs	r3, #1
  403836:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
  40383a:	4a1f      	ldr	r2, [pc, #124]	; (4038b8 <prvTraceStoreKernelCallWithNumericParamOnly+0x98>)
  40383c:	6813      	ldr	r3, [r2, #0]
  40383e:	3301      	adds	r3, #1
  403840:	6013      	str	r3, [r2, #0]
	if (RecorderDataPtr->recorderActive && handle_of_last_logged_task
  403842:	4b1e      	ldr	r3, [pc, #120]	; (4038bc <prvTraceStoreKernelCallWithNumericParamOnly+0x9c>)
  403844:	681b      	ldr	r3, [r3, #0]
  403846:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  403848:	b193      	cbz	r3, 403870 <prvTraceStoreKernelCallWithNumericParamOnly+0x50>
  40384a:	4b1d      	ldr	r3, [pc, #116]	; (4038c0 <prvTraceStoreKernelCallWithNumericParamOnly+0xa0>)
  40384c:	781b      	ldrb	r3, [r3, #0]
  40384e:	b17b      	cbz	r3, 403870 <prvTraceStoreKernelCallWithNumericParamOnly+0x50>
		&& (! inExcludedTask || nISRactive))
  403850:	4b1c      	ldr	r3, [pc, #112]	; (4038c4 <prvTraceStoreKernelCallWithNumericParamOnly+0xa4>)
  403852:	781b      	ldrb	r3, [r3, #0]
  403854:	b11b      	cbz	r3, 40385e <prvTraceStoreKernelCallWithNumericParamOnly+0x3e>
  403856:	4b1c      	ldr	r3, [pc, #112]	; (4038c8 <prvTraceStoreKernelCallWithNumericParamOnly+0xa8>)
  403858:	f993 3000 	ldrsb.w	r3, [r3]
  40385c:	b143      	cbz	r3, 403870 <prvTraceStoreKernelCallWithNumericParamOnly+0x50>
		if (!TRACE_GET_EVENT_CODE_FLAG_ISEXCLUDED(evtcode))
  40385e:	08e3      	lsrs	r3, r4, #3
  403860:	4a1a      	ldr	r2, [pc, #104]	; (4038cc <prvTraceStoreKernelCallWithNumericParamOnly+0xac>)
  403862:	5cd3      	ldrb	r3, [r2, r3]
  403864:	f004 0207 	and.w	r2, r4, #7
  403868:	4113      	asrs	r3, r2
  40386a:	f013 0f01 	tst.w	r3, #1
  40386e:	d00e      	beq.n	40388e <prvTraceStoreKernelCallWithNumericParamOnly+0x6e>
	trcCRITICAL_SECTION_END();
  403870:	4a11      	ldr	r2, [pc, #68]	; (4038b8 <prvTraceStoreKernelCallWithNumericParamOnly+0x98>)
  403872:	6813      	ldr	r3, [r2, #0]
  403874:	3b01      	subs	r3, #1
  403876:	6013      	str	r3, [r2, #0]
  403878:	f385 8810 	msr	PRIMASK, r5
  40387c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	TRACE_ASSERT(evtcode < 0xFF, "prvTraceStoreKernelCallWithNumericParamOnly: Invalid value for evtcode", TRC_UNUSED);
  40387e:	4814      	ldr	r0, [pc, #80]	; (4038d0 <prvTraceStoreKernelCallWithNumericParamOnly+0xb0>)
  403880:	4b14      	ldr	r3, [pc, #80]	; (4038d4 <prvTraceStoreKernelCallWithNumericParamOnly+0xb4>)
  403882:	4798      	blx	r3
  403884:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		prvTraceError("Recorder busy - high priority ISR using syscall? (4)");
  403886:	4814      	ldr	r0, [pc, #80]	; (4038d8 <prvTraceStoreKernelCallWithNumericParamOnly+0xb8>)
  403888:	4b12      	ldr	r3, [pc, #72]	; (4038d4 <prvTraceStoreKernelCallWithNumericParamOnly+0xb4>)
  40388a:	4798      	blx	r3
		return;
  40388c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			dts6 = (uint8_t)prvTraceGetDTS(0xFF);
  40388e:	20ff      	movs	r0, #255	; 0xff
  403890:	4b12      	ldr	r3, [pc, #72]	; (4038dc <prvTraceStoreKernelCallWithNumericParamOnly+0xbc>)
  403892:	4798      	blx	r3
  403894:	4607      	mov	r7, r0
			restParam = (uint16_t)prvTraceGetParam(0xFFFF, param);
  403896:	4631      	mov	r1, r6
  403898:	f64f 70ff 	movw	r0, #65535	; 0xffff
  40389c:	4b10      	ldr	r3, [pc, #64]	; (4038e0 <prvTraceStoreKernelCallWithNumericParamOnly+0xc0>)
  40389e:	4798      	blx	r3
  4038a0:	4606      	mov	r6, r0
			kse = (KernelCallWithParam16*) prvTraceNextFreeEventBufferSlot();
  4038a2:	4b10      	ldr	r3, [pc, #64]	; (4038e4 <prvTraceStoreKernelCallWithNumericParamOnly+0xc4>)
  4038a4:	4798      	blx	r3
			if (kse != NULL)
  4038a6:	2800      	cmp	r0, #0
  4038a8:	d0e2      	beq.n	403870 <prvTraceStoreKernelCallWithNumericParamOnly+0x50>
			dts6 = (uint8_t)prvTraceGetDTS(0xFF);
  4038aa:	7047      	strb	r7, [r0, #1]
				kse->type = (uint8_t)evtcode;
  4038ac:	7004      	strb	r4, [r0, #0]
			restParam = (uint16_t)prvTraceGetParam(0xFFFF, param);
  4038ae:	8046      	strh	r6, [r0, #2]
				prvTraceUpdateCounters();
  4038b0:	4b0d      	ldr	r3, [pc, #52]	; (4038e8 <prvTraceStoreKernelCallWithNumericParamOnly+0xc8>)
  4038b2:	4798      	blx	r3
  4038b4:	e7dc      	b.n	403870 <prvTraceStoreKernelCallWithNumericParamOnly+0x50>
  4038b6:	bf00      	nop
  4038b8:	2000a654 	.word	0x2000a654
  4038bc:	2000a5bc 	.word	0x2000a5bc
  4038c0:	2000a5c0 	.word	0x2000a5c0
  4038c4:	2000a5c8 	.word	0x2000a5c8
  4038c8:	2000a5dc 	.word	0x2000a5dc
  4038cc:	2000a664 	.word	0x2000a664
  4038d0:	00404acc 	.word	0x00404acc
  4038d4:	00402a91 	.word	0x00402a91
  4038d8:	00404b24 	.word	0x00404b24
  4038dc:	0040336d 	.word	0x0040336d
  4038e0:	00402d61 	.word	0x00402d61
  4038e4:	00402ad5 	.word	0x00402ad5
  4038e8:	00402bad 	.word	0x00402bad

004038ec <prvTraceStoreTaskswitch>:
{
  4038ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	TRACE_ASSERT(task_handle <= TRC_CFG_NTASK,
  4038ee:	280a      	cmp	r0, #10
  4038f0:	d84b      	bhi.n	40398a <prvTraceStoreTaskswitch+0x9e>
  4038f2:	4604      	mov	r4, r0
	if (TRACE_GET_TASK_FLAG_ISEXCLUDED(task_handle))
  4038f4:	f100 0321 	add.w	r3, r0, #33	; 0x21
  4038f8:	10da      	asrs	r2, r3, #3
  4038fa:	4931      	ldr	r1, [pc, #196]	; (4039c0 <prvTraceStoreTaskswitch+0xd4>)
  4038fc:	5c8a      	ldrb	r2, [r1, r2]
  4038fe:	f003 0307 	and.w	r3, r3, #7
  403902:	fa42 f303 	asr.w	r3, r2, r3
  403906:	f013 0f01 	tst.w	r3, #1
		inExcludedTask = 1;
  40390a:	bf14      	ite	ne
  40390c:	2301      	movne	r3, #1
		inExcludedTask = 0;
  40390e:	2300      	moveq	r3, #0
  403910:	4a2c      	ldr	r2, [pc, #176]	; (4039c4 <prvTraceStoreTaskswitch+0xd8>)
  403912:	7013      	strb	r3, [r2, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  403914:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  403918:	2201      	movs	r2, #1
  40391a:	f382 8810 	msr	PRIMASK, r2
	trcCRITICAL_SECTION_BEGIN_ON_CORTEX_M_ONLY();
  40391e:	492a      	ldr	r1, [pc, #168]	; (4039c8 <prvTraceStoreTaskswitch+0xdc>)
  403920:	680a      	ldr	r2, [r1, #0]
  403922:	3201      	adds	r2, #1
  403924:	600a      	str	r2, [r1, #0]
	if (task_handle == handle_of_last_logged_task)
  403926:	4a29      	ldr	r2, [pc, #164]	; (4039cc <prvTraceStoreTaskswitch+0xe0>)
  403928:	7812      	ldrb	r2, [r2, #0]
  40392a:	4282      	cmp	r2, r0
  40392c:	d040      	beq.n	4039b0 <prvTraceStoreTaskswitch+0xc4>
	if (!RecorderDataPtr->recorderActive)
  40392e:	4a28      	ldr	r2, [pc, #160]	; (4039d0 <prvTraceStoreTaskswitch+0xe4>)
  403930:	6812      	ldr	r2, [r2, #0]
  403932:	6b12      	ldr	r2, [r2, #48]	; 0x30
  403934:	2a00      	cmp	r2, #0
  403936:	d03b      	beq.n	4039b0 <prvTraceStoreTaskswitch+0xc4>
	if (skipEvent == 0)
  403938:	2b00      	cmp	r3, #0
  40393a:	d139      	bne.n	4039b0 <prvTraceStoreTaskswitch+0xc4>
		isPendingContextSwitch = 0;
  40393c:	2200      	movs	r2, #0
  40393e:	4b25      	ldr	r3, [pc, #148]	; (4039d4 <prvTraceStoreTaskswitch+0xe8>)
  403940:	601a      	str	r2, [r3, #0]
		dts3 = (uint16_t)prvTraceGetDTS(0xFFFF);
  403942:	f64f 70ff 	movw	r0, #65535	; 0xffff
  403946:	4b24      	ldr	r3, [pc, #144]	; (4039d8 <prvTraceStoreTaskswitch+0xec>)
  403948:	4798      	blx	r3
  40394a:	4607      	mov	r7, r0
		handle_of_last_logged_task = task_handle;
  40394c:	4b1f      	ldr	r3, [pc, #124]	; (4039cc <prvTraceStoreTaskswitch+0xe0>)
  40394e:	701c      	strb	r4, [r3, #0]
		ts = (TSEvent*)prvTraceNextFreeEventBufferSlot();
  403950:	4b22      	ldr	r3, [pc, #136]	; (4039dc <prvTraceStoreTaskswitch+0xf0>)
  403952:	4798      	blx	r3
		if (ts != NULL)
  403954:	4606      	mov	r6, r0
  403956:	2800      	cmp	r0, #0
  403958:	d02a      	beq.n	4039b0 <prvTraceStoreTaskswitch+0xc4>
			if (prvTraceGetObjectState(TRACE_CLASS_TASK,
  40395a:	4b1c      	ldr	r3, [pc, #112]	; (4039cc <prvTraceStoreTaskswitch+0xe0>)
  40395c:	7818      	ldrb	r0, [r3, #0]
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
  40395e:	4b1c      	ldr	r3, [pc, #112]	; (4039d0 <prvTraceStoreTaskswitch+0xe4>)
  403960:	681b      	ldr	r3, [r3, #0]
  403962:	f893 3067 	ldrb.w	r3, [r3, #103]	; 0x67
  403966:	4283      	cmp	r3, r0
  403968:	d313      	bcc.n	403992 <prvTraceStoreTaskswitch+0xa6>
	return TRACE_PROPERTY_OBJECT_STATE(objectclass, id);
  40396a:	2103      	movs	r1, #3
  40396c:	4b1c      	ldr	r3, [pc, #112]	; (4039e0 <prvTraceStoreTaskswitch+0xf4>)
  40396e:	4798      	blx	r3
  403970:	4b17      	ldr	r3, [pc, #92]	; (4039d0 <prvTraceStoreTaskswitch+0xe4>)
  403972:	681b      	ldr	r3, [r3, #0]
  403974:	f893 206f 	ldrb.w	r2, [r3, #111]	; 0x6f
  403978:	4418      	add	r0, r3
  40397a:	4410      	add	r0, r2
			if (prvTraceGetObjectState(TRACE_CLASS_TASK,
  40397c:	f890 308c 	ldrb.w	r3, [r0, #140]	; 0x8c
  403980:	2b01      	cmp	r3, #1
  403982:	d109      	bne.n	403998 <prvTraceStoreTaskswitch+0xac>
				ts->type = TS_TASK_RESUME;
  403984:	2307      	movs	r3, #7
  403986:	7033      	strb	r3, [r6, #0]
  403988:	e008      	b.n	40399c <prvTraceStoreTaskswitch+0xb0>
	TRACE_ASSERT(task_handle <= TRC_CFG_NTASK,
  40398a:	4816      	ldr	r0, [pc, #88]	; (4039e4 <prvTraceStoreTaskswitch+0xf8>)
  40398c:	4b16      	ldr	r3, [pc, #88]	; (4039e8 <prvTraceStoreTaskswitch+0xfc>)
  40398e:	4798      	blx	r3
  403990:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
  403992:	4816      	ldr	r0, [pc, #88]	; (4039ec <prvTraceStoreTaskswitch+0x100>)
  403994:	4b14      	ldr	r3, [pc, #80]	; (4039e8 <prvTraceStoreTaskswitch+0xfc>)
  403996:	4798      	blx	r3
				ts->type = TS_TASK_BEGIN;
  403998:	2306      	movs	r3, #6
  40399a:	7033      	strb	r3, [r6, #0]
			ts->dts = dts3;
  40399c:	8077      	strh	r7, [r6, #2]
			ts->objHandle = hnd8;
  40399e:	7074      	strb	r4, [r6, #1]
			prvTraceSetObjectState(TRACE_CLASS_TASK,
  4039a0:	2201      	movs	r2, #1
  4039a2:	4b0a      	ldr	r3, [pc, #40]	; (4039cc <prvTraceStoreTaskswitch+0xe0>)
  4039a4:	7819      	ldrb	r1, [r3, #0]
  4039a6:	2003      	movs	r0, #3
  4039a8:	4b11      	ldr	r3, [pc, #68]	; (4039f0 <prvTraceStoreTaskswitch+0x104>)
  4039aa:	4798      	blx	r3
			prvTraceUpdateCounters();
  4039ac:	4b11      	ldr	r3, [pc, #68]	; (4039f4 <prvTraceStoreTaskswitch+0x108>)
  4039ae:	4798      	blx	r3
	trcCRITICAL_SECTION_END_ON_CORTEX_M_ONLY();
  4039b0:	4a05      	ldr	r2, [pc, #20]	; (4039c8 <prvTraceStoreTaskswitch+0xdc>)
  4039b2:	6813      	ldr	r3, [r2, #0]
  4039b4:	3b01      	subs	r3, #1
  4039b6:	6013      	str	r3, [r2, #0]
  4039b8:	f385 8810 	msr	PRIMASK, r5
  4039bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4039be:	bf00      	nop
  4039c0:	2000a688 	.word	0x2000a688
  4039c4:	2000a5c8 	.word	0x2000a5c8
  4039c8:	2000a654 	.word	0x2000a654
  4039cc:	2000a5c0 	.word	0x2000a5c0
  4039d0:	2000a5bc 	.word	0x2000a5bc
  4039d4:	2000a5cc 	.word	0x2000a5cc
  4039d8:	0040336d 	.word	0x0040336d
  4039dc:	00402ad5 	.word	0x00402ad5
  4039e0:	00402db1 	.word	0x00402db1
  4039e4:	00404e38 	.word	0x00404e38
  4039e8:	00402a91 	.word	0x00402a91
  4039ec:	00404e80 	.word	0x00404e80
  4039f0:	00402fed 	.word	0x00402fed
  4039f4:	00402bad 	.word	0x00402bad

004039f8 <uiTraceStart>:
{
  4039f8:	b538      	push	{r3, r4, r5, lr}
	if (RecorderDataPtr == NULL)
  4039fa:	4b1e      	ldr	r3, [pc, #120]	; (403a74 <uiTraceStart+0x7c>)
  4039fc:	681b      	ldr	r3, [r3, #0]
  4039fe:	b14b      	cbz	r3, 403a14 <uiTraceStart+0x1c>
	if (RecorderDataPtr->recorderActive == 1)
  403a00:	6b18      	ldr	r0, [r3, #48]	; 0x30
  403a02:	2801      	cmp	r0, #1
  403a04:	d005      	beq.n	403a12 <uiTraceStart+0x1a>
	if (traceErrorMessage == NULL)
  403a06:	4b1c      	ldr	r3, [pc, #112]	; (403a78 <uiTraceStart+0x80>)
  403a08:	681b      	ldr	r3, [r3, #0]
  403a0a:	b143      	cbz	r3, 403a1e <uiTraceStart+0x26>
	return RecorderDataPtr->recorderActive;
  403a0c:	4b19      	ldr	r3, [pc, #100]	; (403a74 <uiTraceStart+0x7c>)
  403a0e:	681b      	ldr	r3, [r3, #0]
  403a10:	6b18      	ldr	r0, [r3, #48]	; 0x30
}
  403a12:	bd38      	pop	{r3, r4, r5, pc}
		prvTraceError("RecorderDataPtr is NULL. Call vTraceInitTraceData() before starting trace.");
  403a14:	4819      	ldr	r0, [pc, #100]	; (403a7c <uiTraceStart+0x84>)
  403a16:	4b1a      	ldr	r3, [pc, #104]	; (403a80 <uiTraceStart+0x88>)
  403a18:	4798      	blx	r3
		return 0;
  403a1a:	2000      	movs	r0, #0
  403a1c:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  403a1e:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  403a22:	2201      	movs	r2, #1
  403a24:	f382 8810 	msr	PRIMASK, r2
		trcCRITICAL_SECTION_BEGIN();
  403a28:	4916      	ldr	r1, [pc, #88]	; (403a84 <uiTraceStart+0x8c>)
  403a2a:	680b      	ldr	r3, [r1, #0]
  403a2c:	4413      	add	r3, r2
  403a2e:	600b      	str	r3, [r1, #0]
		RecorderDataPtr->recorderActive = 1;
  403a30:	4b10      	ldr	r3, [pc, #64]	; (403a74 <uiTraceStart+0x7c>)
  403a32:	681b      	ldr	r3, [r3, #0]
  403a34:	631a      	str	r2, [r3, #48]	; 0x30
		handle = TRACE_GET_TASK_NUMBER(TRACE_GET_CURRENT_TASK());
  403a36:	4b14      	ldr	r3, [pc, #80]	; (403a88 <uiTraceStart+0x90>)
  403a38:	4798      	blx	r3
  403a3a:	4b14      	ldr	r3, [pc, #80]	; (403a8c <uiTraceStart+0x94>)
  403a3c:	4798      	blx	r3
		if (handle == 0)
  403a3e:	4605      	mov	r5, r0
  403a40:	b148      	cbz	r0, 403a56 <uiTraceStart+0x5e>
		prvTraceStoreTaskswitch(handle); /* Register the currently running task */
  403a42:	4628      	mov	r0, r5
  403a44:	4b12      	ldr	r3, [pc, #72]	; (403a90 <uiTraceStart+0x98>)
  403a46:	4798      	blx	r3
		trcCRITICAL_SECTION_END();
  403a48:	4a0e      	ldr	r2, [pc, #56]	; (403a84 <uiTraceStart+0x8c>)
  403a4a:	6813      	ldr	r3, [r2, #0]
  403a4c:	3b01      	subs	r3, #1
  403a4e:	6013      	str	r3, [r2, #0]
  403a50:	f384 8810 	msr	PRIMASK, r4
  403a54:	e7da      	b.n	403a0c <uiTraceStart+0x14>
			handle = prvTraceGetObjectHandle(TRACE_CLASS_TASK);
  403a56:	2003      	movs	r0, #3
  403a58:	4b0e      	ldr	r3, [pc, #56]	; (403a94 <uiTraceStart+0x9c>)
  403a5a:	4798      	blx	r3
  403a5c:	4605      	mov	r5, r0
			prvTraceSetObjectName(TRACE_CLASS_TASK, handle, "(startup)");
  403a5e:	4a0e      	ldr	r2, [pc, #56]	; (403a98 <uiTraceStart+0xa0>)
  403a60:	4601      	mov	r1, r0
  403a62:	2003      	movs	r0, #3
  403a64:	4b0d      	ldr	r3, [pc, #52]	; (403a9c <uiTraceStart+0xa4>)
  403a66:	4798      	blx	r3
			prvTraceSetPriorityProperty(TRACE_CLASS_TASK, handle, 0);
  403a68:	2200      	movs	r2, #0
  403a6a:	4629      	mov	r1, r5
  403a6c:	2003      	movs	r0, #3
  403a6e:	4b0c      	ldr	r3, [pc, #48]	; (403aa0 <uiTraceStart+0xa8>)
  403a70:	4798      	blx	r3
  403a72:	e7e6      	b.n	403a42 <uiTraceStart+0x4a>
  403a74:	2000a5bc 	.word	0x2000a5bc
  403a78:	2000a65c 	.word	0x2000a65c
  403a7c:	00404f3c 	.word	0x00404f3c
  403a80:	00402a91 	.word	0x00402a91
  403a84:	2000a654 	.word	0x2000a654
  403a88:	004027fd 	.word	0x004027fd
  403a8c:	00402825 	.word	0x00402825
  403a90:	004038ed 	.word	0x004038ed
  403a94:	00403085 	.word	0x00403085
  403a98:	00404f88 	.word	0x00404f88
  403a9c:	00403225 	.word	0x00403225
  403aa0:	00402f39 	.word	0x00402f39

00403aa4 <vTraceEnable>:
{
  403aa4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403aa8:	4605      	mov	r5, r0
	if (RecorderDataPtr == NULL)
  403aaa:	4b5b      	ldr	r3, [pc, #364]	; (403c18 <vTraceEnable+0x174>)
  403aac:	681b      	ldr	r3, [r3, #0]
  403aae:	2b00      	cmp	r3, #0
  403ab0:	f000 80a1 	beq.w	403bf6 <vTraceEnable+0x152>
		if (RecorderDataPtr->startmarker0 == 1)
  403ab4:	781b      	ldrb	r3, [r3, #0]
  403ab6:	b2db      	uxtb	r3, r3
  403ab8:	2b01      	cmp	r3, #1
  403aba:	f000 8095 	beq.w	403be8 <vTraceEnable+0x144>
	init_hwtc_count = TRC_HWTC_COUNT;
  403abe:	4b57      	ldr	r3, [pc, #348]	; (403c1c <vTraceEnable+0x178>)
  403ac0:	681a      	ldr	r2, [r3, #0]
  403ac2:	4b57      	ldr	r3, [pc, #348]	; (403c20 <vTraceEnable+0x17c>)
  403ac4:	601a      	str	r2, [r3, #0]
	(void)memset(RecorderDataPtr, 0, sizeof(RecorderDataType));
  403ac6:	4c54      	ldr	r4, [pc, #336]	; (403c18 <vTraceEnable+0x174>)
  403ac8:	f241 76ec 	movw	r6, #6124	; 0x17ec
  403acc:	4632      	mov	r2, r6
  403ace:	2100      	movs	r1, #0
  403ad0:	6820      	ldr	r0, [r4, #0]
  403ad2:	4b54      	ldr	r3, [pc, #336]	; (403c24 <vTraceEnable+0x180>)
  403ad4:	4798      	blx	r3
	RecorderDataPtr->version = TRACE_KERNEL_VERSION;
  403ad6:	6823      	ldr	r3, [r4, #0]
  403ad8:	f641 22a1 	movw	r2, #6817	; 0x1aa1
  403adc:	819a      	strh	r2, [r3, #12]
	RecorderDataPtr->minor_version = TRACE_MINOR_VERSION;
  403ade:	2205      	movs	r2, #5
  403ae0:	739a      	strb	r2, [r3, #14]
	RecorderDataPtr->irq_priority_order = TRC_IRQ_PRIORITY_ORDER;
  403ae2:	2200      	movs	r2, #0
  403ae4:	73da      	strb	r2, [r3, #15]
	RecorderDataPtr->filesize = sizeof(RecorderDataType);
  403ae6:	611e      	str	r6, [r3, #16]
	RecorderDataPtr->maxEvents = TRC_CFG_EVENT_BUFFER_SIZE;
  403ae8:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  403aec:	6199      	str	r1, [r3, #24]
	RecorderDataPtr->debugMarker0 = (int32_t) 0xF0F0F0F0;
  403aee:	f04f 31f0 	mov.w	r1, #4042322160	; 0xf0f0f0f0
  403af2:	6559      	str	r1, [r3, #84]	; 0x54
	RecorderDataPtr->isUsing16bitHandles = TRC_CFG_USE_16BIT_OBJECT_HANDLES;
  403af4:	659a      	str	r2, [r3, #88]	; 0x58
	RecorderDataPtr->isrTailchainingThreshold = TRC_CFG_ISR_TAILCHAINING_THRESHOLD;
  403af6:	635a      	str	r2, [r3, #52]	; 0x34
	vTraceInitObjectPropertyTable();
  403af8:	4b4b      	ldr	r3, [pc, #300]	; (403c28 <vTraceEnable+0x184>)
  403afa:	4798      	blx	r3
	RecorderDataPtr->debugMarker1 = (int32_t)0xF1F1F1F1;
  403afc:	6820      	ldr	r0, [r4, #0]
  403afe:	f04f 33f1 	mov.w	r3, #4059165169	; 0xf1f1f1f1
  403b02:	f8c0 3430 	str.w	r3, [r0, #1072]	; 0x430
	RecorderDataPtr->SymbolTable.symTableSize = TRC_CFG_SYMBOL_TABLE_SIZE;
  403b06:	f44f 7348 	mov.w	r3, #800	; 0x320
  403b0a:	f8c0 3434 	str.w	r3, [r0, #1076]	; 0x434
	RecorderDataPtr->SymbolTable.nextFreeSymbolIndex = 1;
  403b0e:	2301      	movs	r3, #1
  403b10:	f8c0 3438 	str.w	r3, [r0, #1080]	; 0x438
	RecorderDataPtr->debugMarker2 = (int32_t)0xF2F2F2F2;
  403b14:	f04f 33f2 	mov.w	r3, #4076008178	; 0xf2f2f2f2
  403b18:	f8c0 37e4 	str.w	r3, [r0, #2020]	; 0x7e4
	prvStrncpy(RecorderDataPtr->systemInfo, "Trace Recorder Demo", 80);
  403b1c:	2250      	movs	r2, #80	; 0x50
  403b1e:	4943      	ldr	r1, [pc, #268]	; (403c2c <vTraceEnable+0x188>)
  403b20:	f500 60fd 	add.w	r0, r0, #2024	; 0x7e8
  403b24:	4b42      	ldr	r3, [pc, #264]	; (403c30 <vTraceEnable+0x18c>)
  403b26:	4798      	blx	r3
	RecorderDataPtr->debugMarker3 = (int32_t)0xF3F3F3F3;
  403b28:	6823      	ldr	r3, [r4, #0]
  403b2a:	f04f 32f3 	mov.w	r2, #4092851187	; 0xf3f3f3f3
  403b2e:	f8c3 2838 	str.w	r2, [r3, #2104]	; 0x838
	RecorderDataPtr->endmarker0 = 0x0A;
  403b32:	f503 52bf 	add.w	r2, r3, #6112	; 0x17e0
  403b36:	210a      	movs	r1, #10
  403b38:	7011      	strb	r1, [r2, #0]
	RecorderDataPtr->endmarker1 = 0x0B;
  403b3a:	210b      	movs	r1, #11
  403b3c:	f241 72e1 	movw	r2, #6113	; 0x17e1
  403b40:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker2 = 0x0C;
  403b42:	210c      	movs	r1, #12
  403b44:	f241 72e2 	movw	r2, #6114	; 0x17e2
  403b48:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker3 = 0x0D;
  403b4a:	210d      	movs	r1, #13
  403b4c:	f241 72e3 	movw	r2, #6115	; 0x17e3
  403b50:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker4 = 0x71;
  403b52:	f241 72e4 	movw	r2, #6116	; 0x17e4
  403b56:	f04f 0171 	mov.w	r1, #113	; 0x71
  403b5a:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker5 = 0x72;
  403b5c:	f241 72e5 	movw	r2, #6117	; 0x17e5
  403b60:	f04f 0172 	mov.w	r1, #114	; 0x72
  403b64:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker6 = 0x73;
  403b66:	2673      	movs	r6, #115	; 0x73
  403b68:	f241 72e6 	movw	r2, #6118	; 0x17e6
  403b6c:	549e      	strb	r6, [r3, r2]
	RecorderDataPtr->endmarker7 = 0x74;
  403b6e:	2774      	movs	r7, #116	; 0x74
  403b70:	f241 72e7 	movw	r2, #6119	; 0x17e7
  403b74:	549f      	strb	r7, [r3, r2]
	RecorderDataPtr->endmarker8 = 0xF1;
  403b76:	f04f 08f1 	mov.w	r8, #241	; 0xf1
  403b7a:	f241 72e8 	movw	r2, #6120	; 0x17e8
  403b7e:	f803 8002 	strb.w	r8, [r3, r2]
	RecorderDataPtr->endmarker9 = 0xF2;
  403b82:	f04f 09f2 	mov.w	r9, #242	; 0xf2
  403b86:	f241 72e9 	movw	r2, #6121	; 0x17e9
  403b8a:	f803 9002 	strb.w	r9, [r3, r2]
	RecorderDataPtr->endmarker10 = 0xF3;
  403b8e:	f04f 0af3 	mov.w	sl, #243	; 0xf3
  403b92:	f241 72ea 	movw	r2, #6122	; 0x17ea
  403b96:	f803 a002 	strb.w	sl, [r3, r2]
	RecorderDataPtr->endmarker11 = 0xF4;
  403b9a:	f04f 0bf4 	mov.w	fp, #244	; 0xf4
  403b9e:	f241 72eb 	movw	r2, #6123	; 0x17eb
  403ba2:	f803 b002 	strb.w	fp, [r3, r2]
	vTraceInitObjectHandleStack();
  403ba6:	4b23      	ldr	r3, [pc, #140]	; (403c34 <vTraceEnable+0x190>)
  403ba8:	4798      	blx	r3
	RecorderDataPtr->startmarker11 = 0xF4;
  403baa:	6823      	ldr	r3, [r4, #0]
  403bac:	f883 b00b 	strb.w	fp, [r3, #11]
	RecorderDataPtr->startmarker10 = 0xF3;
  403bb0:	f883 a00a 	strb.w	sl, [r3, #10]
	RecorderDataPtr->startmarker9 = 0xF2;
  403bb4:	f883 9009 	strb.w	r9, [r3, #9]
	RecorderDataPtr->startmarker8 = 0xF1;
  403bb8:	f883 8008 	strb.w	r8, [r3, #8]
	RecorderDataPtr->startmarker7 = 0x74;
  403bbc:	71df      	strb	r7, [r3, #7]
	RecorderDataPtr->startmarker6 = 0x73;
  403bbe:	719e      	strb	r6, [r3, #6]
	RecorderDataPtr->startmarker5 = 0x72;
  403bc0:	f04f 0272 	mov.w	r2, #114	; 0x72
  403bc4:	715a      	strb	r2, [r3, #5]
	RecorderDataPtr->startmarker4 = 0x71;
  403bc6:	f04f 0271 	mov.w	r2, #113	; 0x71
  403bca:	711a      	strb	r2, [r3, #4]
	RecorderDataPtr->startmarker3 = 0x04;
  403bcc:	2204      	movs	r2, #4
  403bce:	70da      	strb	r2, [r3, #3]
	RecorderDataPtr->startmarker2 = 0x03;
  403bd0:	6823      	ldr	r3, [r4, #0]
  403bd2:	2203      	movs	r2, #3
  403bd4:	709a      	strb	r2, [r3, #2]
	RecorderDataPtr->startmarker1 = 0x02;	
  403bd6:	6823      	ldr	r3, [r4, #0]
  403bd8:	2202      	movs	r2, #2
  403bda:	705a      	strb	r2, [r3, #1]
	RecorderDataPtr->startmarker0 = 0x01; 
  403bdc:	6823      	ldr	r3, [r4, #0]
  403bde:	f04f 0201 	mov.w	r2, #1
  403be2:	701a      	strb	r2, [r3, #0]
	TRC_PORT_SPECIFIC_INIT();
  403be4:	4b14      	ldr	r3, [pc, #80]	; (403c38 <vTraceEnable+0x194>)
  403be6:	4798      	blx	r3
	if (startOption == TRC_START)
  403be8:	2d01      	cmp	r5, #1
  403bea:	d008      	beq.n	403bfe <vTraceEnable+0x15a>
	else if (startOption == TRC_START_AWAIT_HOST)
  403bec:	2d02      	cmp	r5, #2
  403bee:	d00a      	beq.n	403c06 <vTraceEnable+0x162>
	else if (startOption != TRC_INIT)
  403bf0:	b975      	cbnz	r5, 403c10 <vTraceEnable+0x16c>
  403bf2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	RecorderDataPtr = &RecorderData;
  403bf6:	4a11      	ldr	r2, [pc, #68]	; (403c3c <vTraceEnable+0x198>)
  403bf8:	4b07      	ldr	r3, [pc, #28]	; (403c18 <vTraceEnable+0x174>)
  403bfa:	601a      	str	r2, [r3, #0]
  403bfc:	e75f      	b.n	403abe <vTraceEnable+0x1a>
	(void)uiTraceStart();
  403bfe:	4b10      	ldr	r3, [pc, #64]	; (403c40 <vTraceEnable+0x19c>)
  403c00:	4798      	blx	r3
  403c02:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		prvTraceError("vTraceEnable(TRC_START_AWAIT_HOST) not allowed in Snapshot mode");
  403c06:	480f      	ldr	r0, [pc, #60]	; (403c44 <vTraceEnable+0x1a0>)
  403c08:	4b0f      	ldr	r3, [pc, #60]	; (403c48 <vTraceEnable+0x1a4>)
  403c0a:	4798      	blx	r3
  403c0c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		prvTraceError("Unexpected argument to vTraceEnable (snapshot mode)");
  403c10:	480e      	ldr	r0, [pc, #56]	; (403c4c <vTraceEnable+0x1a8>)
  403c12:	4b0d      	ldr	r3, [pc, #52]	; (403c48 <vTraceEnable+0x1a4>)
  403c14:	4798      	blx	r3
}
  403c16:	e7ec      	b.n	403bf2 <vTraceEnable+0x14e>
  403c18:	2000a5bc 	.word	0x2000a5bc
  403c1c:	e0001004 	.word	0xe0001004
  403c20:	2000be84 	.word	0x2000be84
  403c24:	00403eb1 	.word	0x00403eb1
  403c28:	00402835 	.word	0x00402835
  403c2c:	00404f94 	.word	0x00404f94
  403c30:	00402a4d 	.word	0x00402a4d
  403c34:	004028dd 	.word	0x004028dd
  403c38:	004032b1 	.word	0x004032b1
  403c3c:	2000a698 	.word	0x2000a698
  403c40:	004039f9 	.word	0x004039f9
  403c44:	00404fa8 	.word	0x00404fa8
  403c48:	00402a91 	.word	0x00402a91
  403c4c:	00404fe8 	.word	0x00404fe8

00403c50 <vTask1>:

}
/*-----------------------------------------------------------*/


void vTask1(void* pvParam){
  403c50:	b580      	push	{r7, lr}
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  403c52:	4d07      	ldr	r5, [pc, #28]	; (403c70 <vTask1+0x20>)
  403c54:	f44f 5680 	mov.w	r6, #4096	; 0x1000
  403c58:	4637      	mov	r7, r6
  403c5a:	636f      	str	r7, [r5, #52]	; 0x34
	
	while (1){
		
		//ioport_toggle_pin_level(MY_LED);
		ioport_set_pin_level(MY_LED,0);
		vTaskDelay(500);
  403c5c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  403c60:	4c04      	ldr	r4, [pc, #16]	; (403c74 <vTask1+0x24>)
  403c62:	47a0      	blx	r4
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  403c64:	632e      	str	r6, [r5, #48]	; 0x30
		ioport_set_pin_level(MY_LED,1);
		vTaskDelay(500);
  403c66:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  403c6a:	47a0      	blx	r4
  403c6c:	e7f5      	b.n	403c5a <vTask1+0xa>
  403c6e:	bf00      	nop
  403c70:	400e1200 	.word	0x400e1200
  403c74:	00401cb5 	.word	0x00401cb5

00403c78 <vTask2>:
	}
	/* we dont need  to delete the task as we are never going to exit the loop */
}

void vTask2(void* pvParam){
  403c78:	b508      	push	{r3, lr}
	
	while (1){
		/* just sping the loop */
		vTaskDelay(1000);
  403c7a:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  403c7e:	4c02      	ldr	r4, [pc, #8]	; (403c88 <vTask2+0x10>)
  403c80:	4628      	mov	r0, r5
  403c82:	47a0      	blx	r4
  403c84:	e7fc      	b.n	403c80 <vTask2+0x8>
  403c86:	bf00      	nop
  403c88:	00401cb5 	.word	0x00401cb5

00403c8c <main>:
{
  403c8c:	b570      	push	{r4, r5, r6, lr}
  403c8e:	b082      	sub	sp, #8
	sysclk_init();
  403c90:	4b12      	ldr	r3, [pc, #72]	; (403cdc <main+0x50>)
  403c92:	4798      	blx	r3
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  403c94:	4a12      	ldr	r2, [pc, #72]	; (403ce0 <main+0x54>)
  403c96:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  403c98:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  403c9c:	041b      	lsls	r3, r3, #16
  403c9e:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                 |
  403ca0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  403ca4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
  403ca8:	60d3      	str	r3, [r2, #12]
	board_init();
  403caa:	4b0e      	ldr	r3, [pc, #56]	; (403ce4 <main+0x58>)
  403cac:	4798      	blx	r3
		vTraceEnable(TRC_START);
  403cae:	2001      	movs	r0, #1
  403cb0:	4b0d      	ldr	r3, [pc, #52]	; (403ce8 <main+0x5c>)
  403cb2:	4798      	blx	r3
	xReturned = xTaskCreate (vTask1, "Task1",240,NULL,1,NULL);
  403cb4:	2400      	movs	r4, #0
  403cb6:	9401      	str	r4, [sp, #4]
  403cb8:	2601      	movs	r6, #1
  403cba:	9600      	str	r6, [sp, #0]
  403cbc:	4623      	mov	r3, r4
  403cbe:	22f0      	movs	r2, #240	; 0xf0
  403cc0:	490a      	ldr	r1, [pc, #40]	; (403cec <main+0x60>)
  403cc2:	480b      	ldr	r0, [pc, #44]	; (403cf0 <main+0x64>)
  403cc4:	4d0b      	ldr	r5, [pc, #44]	; (403cf4 <main+0x68>)
  403cc6:	47a8      	blx	r5
	xReturned = xTaskCreate (vTask2, "Task2",240,NULL,1,NULL);
  403cc8:	9401      	str	r4, [sp, #4]
  403cca:	9600      	str	r6, [sp, #0]
  403ccc:	4623      	mov	r3, r4
  403cce:	22f0      	movs	r2, #240	; 0xf0
  403cd0:	4909      	ldr	r1, [pc, #36]	; (403cf8 <main+0x6c>)
  403cd2:	480a      	ldr	r0, [pc, #40]	; (403cfc <main+0x70>)
  403cd4:	47a8      	blx	r5
	vTaskStartScheduler();
  403cd6:	4b0a      	ldr	r3, [pc, #40]	; (403d00 <main+0x74>)
  403cd8:	4798      	blx	r3
  403cda:	e7fe      	b.n	403cda <main+0x4e>
  403cdc:	0040015d 	.word	0x0040015d
  403ce0:	e000ed00 	.word	0xe000ed00
  403ce4:	00400139 	.word	0x00400139
  403ce8:	00403aa5 	.word	0x00403aa5
  403cec:	0040501c 	.word	0x0040501c
  403cf0:	00403c51 	.word	0x00403c51
  403cf4:	0040171d 	.word	0x0040171d
  403cf8:	00405024 	.word	0x00405024
  403cfc:	00403c79 	.word	0x00403c79
  403d00:	00401969 	.word	0x00401969

00403d04 <vApplicationMallocFailedHook>:
  403d04:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  403d08:	f383 8811 	msr	BASEPRI, r3
  403d0c:	f3bf 8f6f 	isb	sy
  403d10:	f3bf 8f4f 	dsb	sy
  403d14:	e7fe      	b.n	403d14 <vApplicationMallocFailedHook+0x10>

00403d16 <vApplicationIdleHook>:
	for( ;; );
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
  403d16:	4770      	bx	lr

00403d18 <vApplicationStackOverflowHook>:
  403d18:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  403d1c:	f383 8811 	msr	BASEPRI, r3
  403d20:	f3bf 8f6f 	isb	sy
  403d24:	f3bf 8f4f 	dsb	sy
  403d28:	e7fe      	b.n	403d28 <vApplicationStackOverflowHook+0x10>

00403d2a <vApplicationTickHook>:
	for( ;; );
}
/*-----------------------------------------------------------*/

void vApplicationTickHook( void )
{
  403d2a:	4770      	bx	lr

00403d2c <__libc_init_array>:
  403d2c:	b570      	push	{r4, r5, r6, lr}
  403d2e:	4e0f      	ldr	r6, [pc, #60]	; (403d6c <__libc_init_array+0x40>)
  403d30:	4d0f      	ldr	r5, [pc, #60]	; (403d70 <__libc_init_array+0x44>)
  403d32:	1b76      	subs	r6, r6, r5
  403d34:	10b6      	asrs	r6, r6, #2
  403d36:	bf18      	it	ne
  403d38:	2400      	movne	r4, #0
  403d3a:	d005      	beq.n	403d48 <__libc_init_array+0x1c>
  403d3c:	3401      	adds	r4, #1
  403d3e:	f855 3b04 	ldr.w	r3, [r5], #4
  403d42:	4798      	blx	r3
  403d44:	42a6      	cmp	r6, r4
  403d46:	d1f9      	bne.n	403d3c <__libc_init_array+0x10>
  403d48:	4e0a      	ldr	r6, [pc, #40]	; (403d74 <__libc_init_array+0x48>)
  403d4a:	4d0b      	ldr	r5, [pc, #44]	; (403d78 <__libc_init_array+0x4c>)
  403d4c:	1b76      	subs	r6, r6, r5
  403d4e:	f001 f96f 	bl	405030 <_init>
  403d52:	10b6      	asrs	r6, r6, #2
  403d54:	bf18      	it	ne
  403d56:	2400      	movne	r4, #0
  403d58:	d006      	beq.n	403d68 <__libc_init_array+0x3c>
  403d5a:	3401      	adds	r4, #1
  403d5c:	f855 3b04 	ldr.w	r3, [r5], #4
  403d60:	4798      	blx	r3
  403d62:	42a6      	cmp	r6, r4
  403d64:	d1f9      	bne.n	403d5a <__libc_init_array+0x2e>
  403d66:	bd70      	pop	{r4, r5, r6, pc}
  403d68:	bd70      	pop	{r4, r5, r6, pc}
  403d6a:	bf00      	nop
  403d6c:	0040503c 	.word	0x0040503c
  403d70:	0040503c 	.word	0x0040503c
  403d74:	00405044 	.word	0x00405044
  403d78:	0040503c 	.word	0x0040503c

00403d7c <memcpy>:
  403d7c:	4684      	mov	ip, r0
  403d7e:	ea41 0300 	orr.w	r3, r1, r0
  403d82:	f013 0303 	ands.w	r3, r3, #3
  403d86:	d16d      	bne.n	403e64 <memcpy+0xe8>
  403d88:	3a40      	subs	r2, #64	; 0x40
  403d8a:	d341      	bcc.n	403e10 <memcpy+0x94>
  403d8c:	f851 3b04 	ldr.w	r3, [r1], #4
  403d90:	f840 3b04 	str.w	r3, [r0], #4
  403d94:	f851 3b04 	ldr.w	r3, [r1], #4
  403d98:	f840 3b04 	str.w	r3, [r0], #4
  403d9c:	f851 3b04 	ldr.w	r3, [r1], #4
  403da0:	f840 3b04 	str.w	r3, [r0], #4
  403da4:	f851 3b04 	ldr.w	r3, [r1], #4
  403da8:	f840 3b04 	str.w	r3, [r0], #4
  403dac:	f851 3b04 	ldr.w	r3, [r1], #4
  403db0:	f840 3b04 	str.w	r3, [r0], #4
  403db4:	f851 3b04 	ldr.w	r3, [r1], #4
  403db8:	f840 3b04 	str.w	r3, [r0], #4
  403dbc:	f851 3b04 	ldr.w	r3, [r1], #4
  403dc0:	f840 3b04 	str.w	r3, [r0], #4
  403dc4:	f851 3b04 	ldr.w	r3, [r1], #4
  403dc8:	f840 3b04 	str.w	r3, [r0], #4
  403dcc:	f851 3b04 	ldr.w	r3, [r1], #4
  403dd0:	f840 3b04 	str.w	r3, [r0], #4
  403dd4:	f851 3b04 	ldr.w	r3, [r1], #4
  403dd8:	f840 3b04 	str.w	r3, [r0], #4
  403ddc:	f851 3b04 	ldr.w	r3, [r1], #4
  403de0:	f840 3b04 	str.w	r3, [r0], #4
  403de4:	f851 3b04 	ldr.w	r3, [r1], #4
  403de8:	f840 3b04 	str.w	r3, [r0], #4
  403dec:	f851 3b04 	ldr.w	r3, [r1], #4
  403df0:	f840 3b04 	str.w	r3, [r0], #4
  403df4:	f851 3b04 	ldr.w	r3, [r1], #4
  403df8:	f840 3b04 	str.w	r3, [r0], #4
  403dfc:	f851 3b04 	ldr.w	r3, [r1], #4
  403e00:	f840 3b04 	str.w	r3, [r0], #4
  403e04:	f851 3b04 	ldr.w	r3, [r1], #4
  403e08:	f840 3b04 	str.w	r3, [r0], #4
  403e0c:	3a40      	subs	r2, #64	; 0x40
  403e0e:	d2bd      	bcs.n	403d8c <memcpy+0x10>
  403e10:	3230      	adds	r2, #48	; 0x30
  403e12:	d311      	bcc.n	403e38 <memcpy+0xbc>
  403e14:	f851 3b04 	ldr.w	r3, [r1], #4
  403e18:	f840 3b04 	str.w	r3, [r0], #4
  403e1c:	f851 3b04 	ldr.w	r3, [r1], #4
  403e20:	f840 3b04 	str.w	r3, [r0], #4
  403e24:	f851 3b04 	ldr.w	r3, [r1], #4
  403e28:	f840 3b04 	str.w	r3, [r0], #4
  403e2c:	f851 3b04 	ldr.w	r3, [r1], #4
  403e30:	f840 3b04 	str.w	r3, [r0], #4
  403e34:	3a10      	subs	r2, #16
  403e36:	d2ed      	bcs.n	403e14 <memcpy+0x98>
  403e38:	320c      	adds	r2, #12
  403e3a:	d305      	bcc.n	403e48 <memcpy+0xcc>
  403e3c:	f851 3b04 	ldr.w	r3, [r1], #4
  403e40:	f840 3b04 	str.w	r3, [r0], #4
  403e44:	3a04      	subs	r2, #4
  403e46:	d2f9      	bcs.n	403e3c <memcpy+0xc0>
  403e48:	3204      	adds	r2, #4
  403e4a:	d008      	beq.n	403e5e <memcpy+0xe2>
  403e4c:	07d2      	lsls	r2, r2, #31
  403e4e:	bf1c      	itt	ne
  403e50:	f811 3b01 	ldrbne.w	r3, [r1], #1
  403e54:	f800 3b01 	strbne.w	r3, [r0], #1
  403e58:	d301      	bcc.n	403e5e <memcpy+0xe2>
  403e5a:	880b      	ldrh	r3, [r1, #0]
  403e5c:	8003      	strh	r3, [r0, #0]
  403e5e:	4660      	mov	r0, ip
  403e60:	4770      	bx	lr
  403e62:	bf00      	nop
  403e64:	2a08      	cmp	r2, #8
  403e66:	d313      	bcc.n	403e90 <memcpy+0x114>
  403e68:	078b      	lsls	r3, r1, #30
  403e6a:	d08d      	beq.n	403d88 <memcpy+0xc>
  403e6c:	f010 0303 	ands.w	r3, r0, #3
  403e70:	d08a      	beq.n	403d88 <memcpy+0xc>
  403e72:	f1c3 0304 	rsb	r3, r3, #4
  403e76:	1ad2      	subs	r2, r2, r3
  403e78:	07db      	lsls	r3, r3, #31
  403e7a:	bf1c      	itt	ne
  403e7c:	f811 3b01 	ldrbne.w	r3, [r1], #1
  403e80:	f800 3b01 	strbne.w	r3, [r0], #1
  403e84:	d380      	bcc.n	403d88 <memcpy+0xc>
  403e86:	f831 3b02 	ldrh.w	r3, [r1], #2
  403e8a:	f820 3b02 	strh.w	r3, [r0], #2
  403e8e:	e77b      	b.n	403d88 <memcpy+0xc>
  403e90:	3a04      	subs	r2, #4
  403e92:	d3d9      	bcc.n	403e48 <memcpy+0xcc>
  403e94:	3a01      	subs	r2, #1
  403e96:	f811 3b01 	ldrb.w	r3, [r1], #1
  403e9a:	f800 3b01 	strb.w	r3, [r0], #1
  403e9e:	d2f9      	bcs.n	403e94 <memcpy+0x118>
  403ea0:	780b      	ldrb	r3, [r1, #0]
  403ea2:	7003      	strb	r3, [r0, #0]
  403ea4:	784b      	ldrb	r3, [r1, #1]
  403ea6:	7043      	strb	r3, [r0, #1]
  403ea8:	788b      	ldrb	r3, [r1, #2]
  403eaa:	7083      	strb	r3, [r0, #2]
  403eac:	4660      	mov	r0, ip
  403eae:	4770      	bx	lr

00403eb0 <memset>:
  403eb0:	b470      	push	{r4, r5, r6}
  403eb2:	0786      	lsls	r6, r0, #30
  403eb4:	d046      	beq.n	403f44 <memset+0x94>
  403eb6:	1e54      	subs	r4, r2, #1
  403eb8:	2a00      	cmp	r2, #0
  403eba:	d041      	beq.n	403f40 <memset+0x90>
  403ebc:	b2ca      	uxtb	r2, r1
  403ebe:	4603      	mov	r3, r0
  403ec0:	e002      	b.n	403ec8 <memset+0x18>
  403ec2:	f114 34ff 	adds.w	r4, r4, #4294967295
  403ec6:	d33b      	bcc.n	403f40 <memset+0x90>
  403ec8:	f803 2b01 	strb.w	r2, [r3], #1
  403ecc:	079d      	lsls	r5, r3, #30
  403ece:	d1f8      	bne.n	403ec2 <memset+0x12>
  403ed0:	2c03      	cmp	r4, #3
  403ed2:	d92e      	bls.n	403f32 <memset+0x82>
  403ed4:	b2cd      	uxtb	r5, r1
  403ed6:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  403eda:	2c0f      	cmp	r4, #15
  403edc:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  403ee0:	d919      	bls.n	403f16 <memset+0x66>
  403ee2:	f103 0210 	add.w	r2, r3, #16
  403ee6:	4626      	mov	r6, r4
  403ee8:	3e10      	subs	r6, #16
  403eea:	2e0f      	cmp	r6, #15
  403eec:	f842 5c10 	str.w	r5, [r2, #-16]
  403ef0:	f842 5c0c 	str.w	r5, [r2, #-12]
  403ef4:	f842 5c08 	str.w	r5, [r2, #-8]
  403ef8:	f842 5c04 	str.w	r5, [r2, #-4]
  403efc:	f102 0210 	add.w	r2, r2, #16
  403f00:	d8f2      	bhi.n	403ee8 <memset+0x38>
  403f02:	f1a4 0210 	sub.w	r2, r4, #16
  403f06:	f022 020f 	bic.w	r2, r2, #15
  403f0a:	f004 040f 	and.w	r4, r4, #15
  403f0e:	3210      	adds	r2, #16
  403f10:	2c03      	cmp	r4, #3
  403f12:	4413      	add	r3, r2
  403f14:	d90d      	bls.n	403f32 <memset+0x82>
  403f16:	461e      	mov	r6, r3
  403f18:	4622      	mov	r2, r4
  403f1a:	3a04      	subs	r2, #4
  403f1c:	2a03      	cmp	r2, #3
  403f1e:	f846 5b04 	str.w	r5, [r6], #4
  403f22:	d8fa      	bhi.n	403f1a <memset+0x6a>
  403f24:	1f22      	subs	r2, r4, #4
  403f26:	f022 0203 	bic.w	r2, r2, #3
  403f2a:	3204      	adds	r2, #4
  403f2c:	4413      	add	r3, r2
  403f2e:	f004 0403 	and.w	r4, r4, #3
  403f32:	b12c      	cbz	r4, 403f40 <memset+0x90>
  403f34:	b2c9      	uxtb	r1, r1
  403f36:	441c      	add	r4, r3
  403f38:	f803 1b01 	strb.w	r1, [r3], #1
  403f3c:	429c      	cmp	r4, r3
  403f3e:	d1fb      	bne.n	403f38 <memset+0x88>
  403f40:	bc70      	pop	{r4, r5, r6}
  403f42:	4770      	bx	lr
  403f44:	4614      	mov	r4, r2
  403f46:	4603      	mov	r3, r0
  403f48:	e7c2      	b.n	403ed0 <memset+0x20>
  403f4a:	bf00      	nop

00403f4c <strncmp>:
  403f4c:	2a00      	cmp	r2, #0
  403f4e:	d041      	beq.n	403fd4 <strncmp+0x88>
  403f50:	ea40 0301 	orr.w	r3, r0, r1
  403f54:	f013 0303 	ands.w	r3, r3, #3
  403f58:	b4f0      	push	{r4, r5, r6, r7}
  403f5a:	d125      	bne.n	403fa8 <strncmp+0x5c>
  403f5c:	2a03      	cmp	r2, #3
  403f5e:	d923      	bls.n	403fa8 <strncmp+0x5c>
  403f60:	6804      	ldr	r4, [r0, #0]
  403f62:	680d      	ldr	r5, [r1, #0]
  403f64:	42ac      	cmp	r4, r5
  403f66:	d11f      	bne.n	403fa8 <strncmp+0x5c>
  403f68:	3a04      	subs	r2, #4
  403f6a:	d038      	beq.n	403fde <strncmp+0x92>
  403f6c:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
  403f70:	ea25 0404 	bic.w	r4, r5, r4
  403f74:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
  403f78:	d12e      	bne.n	403fd8 <strncmp+0x8c>
  403f7a:	3004      	adds	r0, #4
  403f7c:	3104      	adds	r1, #4
  403f7e:	e00f      	b.n	403fa0 <strncmp+0x54>
  403f80:	f850 3b04 	ldr.w	r3, [r0], #4
  403f84:	680e      	ldr	r6, [r1, #0]
  403f86:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
  403f8a:	42b3      	cmp	r3, r6
  403f8c:	ea24 0403 	bic.w	r4, r4, r3
  403f90:	f101 0104 	add.w	r1, r1, #4
  403f94:	d126      	bne.n	403fe4 <strncmp+0x98>
  403f96:	3a04      	subs	r2, #4
  403f98:	d021      	beq.n	403fde <strncmp+0x92>
  403f9a:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
  403f9e:	d11b      	bne.n	403fd8 <strncmp+0x8c>
  403fa0:	2a03      	cmp	r2, #3
  403fa2:	4607      	mov	r7, r0
  403fa4:	460d      	mov	r5, r1
  403fa6:	d8eb      	bhi.n	403f80 <strncmp+0x34>
  403fa8:	7805      	ldrb	r5, [r0, #0]
  403faa:	780c      	ldrb	r4, [r1, #0]
  403fac:	42ac      	cmp	r4, r5
  403fae:	f102 33ff 	add.w	r3, r2, #4294967295
  403fb2:	d11a      	bne.n	403fea <strncmp+0x9e>
  403fb4:	b183      	cbz	r3, 403fd8 <strncmp+0x8c>
  403fb6:	b914      	cbnz	r4, 403fbe <strncmp+0x72>
  403fb8:	e00e      	b.n	403fd8 <strncmp+0x8c>
  403fba:	b16b      	cbz	r3, 403fd8 <strncmp+0x8c>
  403fbc:	b17a      	cbz	r2, 403fde <strncmp+0x92>
  403fbe:	f810 2f01 	ldrb.w	r2, [r0, #1]!
  403fc2:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  403fc6:	42a2      	cmp	r2, r4
  403fc8:	f103 33ff 	add.w	r3, r3, #4294967295
  403fcc:	d0f5      	beq.n	403fba <strncmp+0x6e>
  403fce:	1b10      	subs	r0, r2, r4
  403fd0:	bcf0      	pop	{r4, r5, r6, r7}
  403fd2:	4770      	bx	lr
  403fd4:	4610      	mov	r0, r2
  403fd6:	4770      	bx	lr
  403fd8:	2000      	movs	r0, #0
  403fda:	bcf0      	pop	{r4, r5, r6, r7}
  403fdc:	4770      	bx	lr
  403fde:	4610      	mov	r0, r2
  403fe0:	bcf0      	pop	{r4, r5, r6, r7}
  403fe2:	4770      	bx	lr
  403fe4:	4629      	mov	r1, r5
  403fe6:	4638      	mov	r0, r7
  403fe8:	e7de      	b.n	403fa8 <strncmp+0x5c>
  403fea:	462a      	mov	r2, r5
  403fec:	e7ef      	b.n	403fce <strncmp+0x82>
  403fee:	bf00      	nop

00403ff0 <register_fini>:
  403ff0:	4b02      	ldr	r3, [pc, #8]	; (403ffc <register_fini+0xc>)
  403ff2:	b113      	cbz	r3, 403ffa <register_fini+0xa>
  403ff4:	4802      	ldr	r0, [pc, #8]	; (404000 <register_fini+0x10>)
  403ff6:	f000 b805 	b.w	404004 <atexit>
  403ffa:	4770      	bx	lr
  403ffc:	00000000 	.word	0x00000000
  404000:	00404011 	.word	0x00404011

00404004 <atexit>:
  404004:	2300      	movs	r3, #0
  404006:	4601      	mov	r1, r0
  404008:	461a      	mov	r2, r3
  40400a:	4618      	mov	r0, r3
  40400c:	f000 b81a 	b.w	404044 <__register_exitproc>

00404010 <__libc_fini_array>:
  404010:	b538      	push	{r3, r4, r5, lr}
  404012:	4c0a      	ldr	r4, [pc, #40]	; (40403c <__libc_fini_array+0x2c>)
  404014:	4d0a      	ldr	r5, [pc, #40]	; (404040 <__libc_fini_array+0x30>)
  404016:	1b64      	subs	r4, r4, r5
  404018:	10a4      	asrs	r4, r4, #2
  40401a:	d00a      	beq.n	404032 <__libc_fini_array+0x22>
  40401c:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
  404020:	3b01      	subs	r3, #1
  404022:	eb05 0583 	add.w	r5, r5, r3, lsl #2
  404026:	3c01      	subs	r4, #1
  404028:	f855 3904 	ldr.w	r3, [r5], #-4
  40402c:	4798      	blx	r3
  40402e:	2c00      	cmp	r4, #0
  404030:	d1f9      	bne.n	404026 <__libc_fini_array+0x16>
  404032:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  404036:	f001 b805 	b.w	405044 <_fini>
  40403a:	bf00      	nop
  40403c:	00405054 	.word	0x00405054
  404040:	00405050 	.word	0x00405050

00404044 <__register_exitproc>:
  404044:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  404048:	4c25      	ldr	r4, [pc, #148]	; (4040e0 <__register_exitproc+0x9c>)
  40404a:	6825      	ldr	r5, [r4, #0]
  40404c:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
  404050:	4606      	mov	r6, r0
  404052:	4688      	mov	r8, r1
  404054:	4692      	mov	sl, r2
  404056:	4699      	mov	r9, r3
  404058:	b3c4      	cbz	r4, 4040cc <__register_exitproc+0x88>
  40405a:	6860      	ldr	r0, [r4, #4]
  40405c:	281f      	cmp	r0, #31
  40405e:	dc17      	bgt.n	404090 <__register_exitproc+0x4c>
  404060:	1c43      	adds	r3, r0, #1
  404062:	b176      	cbz	r6, 404082 <__register_exitproc+0x3e>
  404064:	eb04 0580 	add.w	r5, r4, r0, lsl #2
  404068:	2201      	movs	r2, #1
  40406a:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
  40406e:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
  404072:	4082      	lsls	r2, r0
  404074:	4311      	orrs	r1, r2
  404076:	2e02      	cmp	r6, #2
  404078:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
  40407c:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
  404080:	d01e      	beq.n	4040c0 <__register_exitproc+0x7c>
  404082:	3002      	adds	r0, #2
  404084:	6063      	str	r3, [r4, #4]
  404086:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
  40408a:	2000      	movs	r0, #0
  40408c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  404090:	4b14      	ldr	r3, [pc, #80]	; (4040e4 <__register_exitproc+0xa0>)
  404092:	b303      	cbz	r3, 4040d6 <__register_exitproc+0x92>
  404094:	f44f 70c8 	mov.w	r0, #400	; 0x190
  404098:	f3af 8000 	nop.w
  40409c:	4604      	mov	r4, r0
  40409e:	b1d0      	cbz	r0, 4040d6 <__register_exitproc+0x92>
  4040a0:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
  4040a4:	2700      	movs	r7, #0
  4040a6:	e880 0088 	stmia.w	r0, {r3, r7}
  4040aa:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
  4040ae:	4638      	mov	r0, r7
  4040b0:	2301      	movs	r3, #1
  4040b2:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
  4040b6:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
  4040ba:	2e00      	cmp	r6, #0
  4040bc:	d0e1      	beq.n	404082 <__register_exitproc+0x3e>
  4040be:	e7d1      	b.n	404064 <__register_exitproc+0x20>
  4040c0:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
  4040c4:	430a      	orrs	r2, r1
  4040c6:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
  4040ca:	e7da      	b.n	404082 <__register_exitproc+0x3e>
  4040cc:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
  4040d0:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
  4040d4:	e7c1      	b.n	40405a <__register_exitproc+0x16>
  4040d6:	f04f 30ff 	mov.w	r0, #4294967295
  4040da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4040de:	bf00      	nop
  4040e0:	0040502c 	.word	0x0040502c
  4040e4:	00000000 	.word	0x00000000
  4040e8:	454c4449 	.word	0x454c4449
  4040ec:	00000000 	.word	0x00000000
  4040f0:	20726d54 	.word	0x20726d54
  4040f4:	00637653 	.word	0x00637653
  4040f8:	20746f4e 	.word	0x20746f4e
  4040fc:	756f6e65 	.word	0x756f6e65
  404100:	54206867 	.word	0x54206867
  404104:	204b5341 	.word	0x204b5341
  404108:	646e6168 	.word	0x646e6168
  40410c:	2073656c 	.word	0x2073656c
  404110:	6e69202d 	.word	0x6e69202d
  404114:	61657263 	.word	0x61657263
  404118:	54206573 	.word	0x54206573
  40411c:	435f4352 	.word	0x435f4352
  404120:	4e5f4746 	.word	0x4e5f4746
  404124:	4b534154 	.word	0x4b534154
  404128:	206e6920 	.word	0x206e6920
  40412c:	53637274 	.word	0x53637274
  404130:	7370616e 	.word	0x7370616e
  404134:	43746f68 	.word	0x43746f68
  404138:	69666e6f 	.word	0x69666e6f
  40413c:	00682e67 	.word	0x00682e67
  404140:	20746f4e 	.word	0x20746f4e
  404144:	756f6e65 	.word	0x756f6e65
  404148:	49206867 	.word	0x49206867
  40414c:	68205253 	.word	0x68205253
  404150:	6c646e61 	.word	0x6c646e61
  404154:	2d207365 	.word	0x2d207365
  404158:	636e6920 	.word	0x636e6920
  40415c:	73616572 	.word	0x73616572
  404160:	52542065 	.word	0x52542065
  404164:	46435f43 	.word	0x46435f43
  404168:	494e5f47 	.word	0x494e5f47
  40416c:	69205253 	.word	0x69205253
  404170:	7274206e 	.word	0x7274206e
  404174:	616e5363 	.word	0x616e5363
  404178:	6f687370 	.word	0x6f687370
  40417c:	6e6f4374 	.word	0x6e6f4374
  404180:	2e676966 	.word	0x2e676966
  404184:	00000068 	.word	0x00000068
  404188:	20746f4e 	.word	0x20746f4e
  40418c:	756f6e65 	.word	0x756f6e65
  404190:	53206867 	.word	0x53206867
  404194:	50414d45 	.word	0x50414d45
  404198:	45524f48 	.word	0x45524f48
  40419c:	6e616820 	.word	0x6e616820
  4041a0:	73656c64 	.word	0x73656c64
  4041a4:	69202d20 	.word	0x69202d20
  4041a8:	6572636e 	.word	0x6572636e
  4041ac:	20657361 	.word	0x20657361
  4041b0:	5f435254 	.word	0x5f435254
  4041b4:	5f474643 	.word	0x5f474643
  4041b8:	4d45534e 	.word	0x4d45534e
  4041bc:	4f485041 	.word	0x4f485041
  4041c0:	69204552 	.word	0x69204552
  4041c4:	7274206e 	.word	0x7274206e
  4041c8:	616e5363 	.word	0x616e5363
  4041cc:	6f687370 	.word	0x6f687370
  4041d0:	6e6f4374 	.word	0x6e6f4374
  4041d4:	2e676966 	.word	0x2e676966
  4041d8:	00000068 	.word	0x00000068
  4041dc:	20746f4e 	.word	0x20746f4e
  4041e0:	756f6e65 	.word	0x756f6e65
  4041e4:	4d206867 	.word	0x4d206867
  4041e8:	58455455 	.word	0x58455455
  4041ec:	6e616820 	.word	0x6e616820
  4041f0:	73656c64 	.word	0x73656c64
  4041f4:	69202d20 	.word	0x69202d20
  4041f8:	6572636e 	.word	0x6572636e
  4041fc:	20657361 	.word	0x20657361
  404200:	5f435254 	.word	0x5f435254
  404204:	5f474643 	.word	0x5f474643
  404208:	54554d4e 	.word	0x54554d4e
  40420c:	69205845 	.word	0x69205845
  404210:	7274206e 	.word	0x7274206e
  404214:	616e5363 	.word	0x616e5363
  404218:	6f687370 	.word	0x6f687370
  40421c:	6e6f4374 	.word	0x6e6f4374
  404220:	2e676966 	.word	0x2e676966
  404224:	00000068 	.word	0x00000068
  404228:	20746f4e 	.word	0x20746f4e
  40422c:	756f6e65 	.word	0x756f6e65
  404230:	51206867 	.word	0x51206867
  404234:	45554555 	.word	0x45554555
  404238:	6e616820 	.word	0x6e616820
  40423c:	73656c64 	.word	0x73656c64
  404240:	69202d20 	.word	0x69202d20
  404244:	6572636e 	.word	0x6572636e
  404248:	20657361 	.word	0x20657361
  40424c:	5f435254 	.word	0x5f435254
  404250:	5f474643 	.word	0x5f474643
  404254:	4555514e 	.word	0x4555514e
  404258:	69204555 	.word	0x69204555
  40425c:	7274206e 	.word	0x7274206e
  404260:	616e5363 	.word	0x616e5363
  404264:	6f687370 	.word	0x6f687370
  404268:	6e6f4374 	.word	0x6e6f4374
  40426c:	2e676966 	.word	0x2e676966
  404270:	00000068 	.word	0x00000068
  404274:	20746f4e 	.word	0x20746f4e
  404278:	756f6e65 	.word	0x756f6e65
  40427c:	54206867 	.word	0x54206867
  404280:	52454d49 	.word	0x52454d49
  404284:	6e616820 	.word	0x6e616820
  404288:	73656c64 	.word	0x73656c64
  40428c:	69202d20 	.word	0x69202d20
  404290:	6572636e 	.word	0x6572636e
  404294:	20657361 	.word	0x20657361
  404298:	5f435254 	.word	0x5f435254
  40429c:	5f474643 	.word	0x5f474643
  4042a0:	4d49544e 	.word	0x4d49544e
  4042a4:	69205245 	.word	0x69205245
  4042a8:	7274206e 	.word	0x7274206e
  4042ac:	616e5363 	.word	0x616e5363
  4042b0:	6f687370 	.word	0x6f687370
  4042b4:	6e6f4374 	.word	0x6e6f4374
  4042b8:	2e676966 	.word	0x2e676966
  4042bc:	00000068 	.word	0x00000068
  4042c0:	20746f4e 	.word	0x20746f4e
  4042c4:	756f6e65 	.word	0x756f6e65
  4042c8:	45206867 	.word	0x45206867
  4042cc:	544e4556 	.word	0x544e4556
  4042d0:	554f5247 	.word	0x554f5247
  4042d4:	61682050 	.word	0x61682050
  4042d8:	656c646e 	.word	0x656c646e
  4042dc:	202d2073 	.word	0x202d2073
  4042e0:	72636e69 	.word	0x72636e69
  4042e4:	65736165 	.word	0x65736165
  4042e8:	43525420 	.word	0x43525420
  4042ec:	4746435f 	.word	0x4746435f
  4042f0:	56454e5f 	.word	0x56454e5f
  4042f4:	47544e45 	.word	0x47544e45
  4042f8:	50554f52 	.word	0x50554f52
  4042fc:	206e6920 	.word	0x206e6920
  404300:	53637274 	.word	0x53637274
  404304:	7370616e 	.word	0x7370616e
  404308:	43746f68 	.word	0x43746f68
  40430c:	69666e6f 	.word	0x69666e6f
  404310:	00682e67 	.word	0x00682e67
  404314:	547a7370 	.word	0x547a7370
  404318:	65636172 	.word	0x65636172
  40431c:	45746547 	.word	0x45746547
  404320:	726f7272 	.word	0x726f7272
  404324:	646e6148 	.word	0x646e6148
  404328:	3a73656c 	.word	0x3a73656c
  40432c:	766e4920 	.word	0x766e4920
  404330:	64696c61 	.word	0x64696c61
  404334:	6a626f20 	.word	0x6a626f20
  404338:	63746365 	.word	0x63746365
  40433c:	7373616c 	.word	0x7373616c
  404340:	00000021 	.word	0x00000021
  404344:	43415254 	.word	0x43415254
  404348:	53415f45 	.word	0x53415f45
  40434c:	54524553 	.word	0x54524553
  404350:	7270203a 	.word	0x7270203a
  404354:	4f734976 	.word	0x4f734976
  404358:	63656a62 	.word	0x63656a62
  40435c:	63784574 	.word	0x63784574
  404360:	6564756c 	.word	0x6564756c
  404364:	6f203a64 	.word	0x6f203a64
  404368:	63656a62 	.word	0x63656a62
  40436c:	616c6374 	.word	0x616c6374
  404370:	3e207373 	.word	0x3e207373
  404374:	5254203d 	.word	0x5254203d
  404378:	5f454341 	.word	0x5f454341
  40437c:	414c434e 	.word	0x414c434e
  404380:	53455353 	.word	0x53455353
  404384:	00000000 	.word	0x00000000
  404388:	43415254 	.word	0x43415254
  40438c:	53415f45 	.word	0x53415f45
  404390:	54524553 	.word	0x54524553
  404394:	7270203a 	.word	0x7270203a
  404398:	4f734976 	.word	0x4f734976
  40439c:	63656a62 	.word	0x63656a62
  4043a0:	63784574 	.word	0x63784574
  4043a4:	6564756c 	.word	0x6564756c
  4043a8:	49203a64 	.word	0x49203a64
  4043ac:	6c61766e 	.word	0x6c61766e
  4043b0:	76206469 	.word	0x76206469
  4043b4:	65756c61 	.word	0x65756c61
  4043b8:	726f6620 	.word	0x726f6620
  4043bc:	6e616820 	.word	0x6e616820
  4043c0:	00656c64 	.word	0x00656c64
  4043c4:	61766e49 	.word	0x61766e49
  4043c8:	2064696c 	.word	0x2064696c
  4043cc:	656a626f 	.word	0x656a626f
  4043d0:	63207463 	.word	0x63207463
  4043d4:	7373616c 	.word	0x7373616c
  4043d8:	20444920 	.word	0x20444920
  4043dc:	70206e69 	.word	0x70206e69
  4043e0:	73497672 	.word	0x73497672
  4043e4:	656a624f 	.word	0x656a624f
  4043e8:	78457463 	.word	0x78457463
  4043ec:	64756c63 	.word	0x64756c63
  4043f0:	00216465 	.word	0x00216465
  4043f4:	43415254 	.word	0x43415254
  4043f8:	53415f45 	.word	0x53415f45
  4043fc:	54524553 	.word	0x54524553
  404400:	7270203a 	.word	0x7270203a
  404404:	65684376 	.word	0x65684376
  404408:	61446b63 	.word	0x61446b63
  40440c:	6f546174 	.word	0x6f546174
  404410:	764f6542 	.word	0x764f6542
  404414:	72777265 	.word	0x72777265
  404418:	65747469 	.word	0x65747469
  40441c:	726f466e 	.word	0x726f466e
  404420:	746c754d 	.word	0x746c754d
  404424:	746e4569 	.word	0x746e4569
  404428:	76457972 	.word	0x76457972
  40442c:	73746e65 	.word	0x73746e65
  404430:	6f6e203a 	.word	0x6f6e203a
  404434:	746e4566 	.word	0x746e4566
  404438:	73656972 	.word	0x73656972
  40443c:	68436f54 	.word	0x68436f54
  404440:	206b6365 	.word	0x206b6365
  404444:	30203d3d 	.word	0x30203d3d
  404448:	00000000 	.word	0x00000000
  40444c:	43415254 	.word	0x43415254
  404450:	53415f45 	.word	0x53415f45
  404454:	54524553 	.word	0x54524553
  404458:	7270203a 	.word	0x7270203a
  40445c:	61725476 	.word	0x61725476
  404460:	72466563 	.word	0x72466563
  404464:	624f6565 	.word	0x624f6565
  404468:	7463656a 	.word	0x7463656a
  40446c:	646e6148 	.word	0x646e6148
  404470:	203a656c 	.word	0x203a656c
  404474:	61766e49 	.word	0x61766e49
  404478:	2064696c 	.word	0x2064696c
  40447c:	756c6176 	.word	0x756c6176
  404480:	6f662065 	.word	0x6f662065
  404484:	626f2072 	.word	0x626f2072
  404488:	7463656a 	.word	0x7463656a
  40448c:	73616c63 	.word	0x73616c63
  404490:	00000073 	.word	0x00000073
  404494:	43415254 	.word	0x43415254
  404498:	53415f45 	.word	0x53415f45
  40449c:	54524553 	.word	0x54524553
  4044a0:	7270203a 	.word	0x7270203a
  4044a4:	61725476 	.word	0x61725476
  4044a8:	72466563 	.word	0x72466563
  4044ac:	624f6565 	.word	0x624f6565
  4044b0:	7463656a 	.word	0x7463656a
  4044b4:	646e6148 	.word	0x646e6148
  4044b8:	203a656c 	.word	0x203a656c
  4044bc:	61766e49 	.word	0x61766e49
  4044c0:	2064696c 	.word	0x2064696c
  4044c4:	756c6176 	.word	0x756c6176
  4044c8:	6f662065 	.word	0x6f662065
  4044cc:	61682072 	.word	0x61682072
  4044d0:	656c646e 	.word	0x656c646e
  4044d4:	00000000 	.word	0x00000000
  4044d8:	65747441 	.word	0x65747441
  4044dc:	2074706d 	.word	0x2074706d
  4044e0:	66206f74 	.word	0x66206f74
  4044e4:	20656572 	.word	0x20656572
  4044e8:	65726f6d 	.word	0x65726f6d
  4044ec:	6e616820 	.word	0x6e616820
  4044f0:	73656c64 	.word	0x73656c64
  4044f4:	61687420 	.word	0x61687420
  4044f8:	6c61206e 	.word	0x6c61206e
  4044fc:	61636f6c 	.word	0x61636f6c
  404500:	21646574 	.word	0x21646574
  404504:	00000000 	.word	0x00000000
  404508:	43415254 	.word	0x43415254
  40450c:	53415f45 	.word	0x53415f45
  404510:	54524553 	.word	0x54524553
  404514:	7270203a 	.word	0x7270203a
  404518:	61725476 	.word	0x61725476
  40451c:	65476563 	.word	0x65476563
  404520:	53544474 	.word	0x53544474
  404524:	6e49203a 	.word	0x6e49203a
  404528:	696c6176 	.word	0x696c6176
  40452c:	61762064 	.word	0x61762064
  404530:	2065756c 	.word	0x2065756c
  404534:	20726f66 	.word	0x20726f66
  404538:	61726170 	.word	0x61726170
  40453c:	616d5f6d 	.word	0x616d5f6d
  404540:	53544478 	.word	0x53544478
  404544:	00000000 	.word	0x00000000
  404548:	20646142 	.word	0x20646142
  40454c:	61726170 	.word	0x61726170
  404550:	616d5f6d 	.word	0x616d5f6d
  404554:	53544478 	.word	0x53544478
  404558:	206e6920 	.word	0x206e6920
  40455c:	54767270 	.word	0x54767270
  404560:	65636172 	.word	0x65636172
  404564:	44746547 	.word	0x44746547
  404568:	00005354 	.word	0x00005354
  40456c:	43415254 	.word	0x43415254
  404570:	53415f45 	.word	0x53415f45
  404574:	54524553 	.word	0x54524553
  404578:	7270203a 	.word	0x7270203a
  40457c:	61725476 	.word	0x61725476
  404580:	65476563 	.word	0x65476563
  404584:	6a624f74 	.word	0x6a624f74
  404588:	48746365 	.word	0x48746365
  40458c:	6c646e61 	.word	0x6c646e61
  404590:	49203a65 	.word	0x49203a65
  404594:	6c61766e 	.word	0x6c61766e
  404598:	76206469 	.word	0x76206469
  40459c:	65756c61 	.word	0x65756c61
  4045a0:	726f6620 	.word	0x726f6620
  4045a4:	6a626f20 	.word	0x6a626f20
  4045a8:	63746365 	.word	0x63746365
  4045ac:	7373616c 	.word	0x7373616c
  4045b0:	00000000 	.word	0x00000000
  4045b4:	43415254 	.word	0x43415254
  4045b8:	53415f45 	.word	0x53415f45
  4045bc:	54524553 	.word	0x54524553
  4045c0:	7270203a 	.word	0x7270203a
  4045c4:	61725476 	.word	0x61725476
  4045c8:	65476563 	.word	0x65476563
  4045cc:	72615074 	.word	0x72615074
  4045d0:	203a6d61 	.word	0x203a6d61
  4045d4:	61766e49 	.word	0x61766e49
  4045d8:	2064696c 	.word	0x2064696c
  4045dc:	756c6176 	.word	0x756c6176
  4045e0:	6f662065 	.word	0x6f662065
  4045e4:	61702072 	.word	0x61702072
  4045e8:	5f6d6172 	.word	0x5f6d6172
  4045ec:	0078616d 	.word	0x0078616d
  4045f0:	43415254 	.word	0x43415254
  4045f4:	53415f45 	.word	0x53415f45
  4045f8:	54524553 	.word	0x54524553
  4045fc:	7270203a 	.word	0x7270203a
  404600:	61725476 	.word	0x61725476
  404604:	65476563 	.word	0x65476563
  404608:	69725074 	.word	0x69725074
  40460c:	7469726f 	.word	0x7469726f
  404610:	6f725079 	.word	0x6f725079
  404614:	74726570 	.word	0x74726570
  404618:	6f203a79 	.word	0x6f203a79
  40461c:	63656a62 	.word	0x63656a62
  404620:	616c6374 	.word	0x616c6374
  404624:	3e207373 	.word	0x3e207373
  404628:	5254203d 	.word	0x5254203d
  40462c:	5f454341 	.word	0x5f454341
  404630:	414c434e 	.word	0x414c434e
  404634:	53455353 	.word	0x53455353
  404638:	00000000 	.word	0x00000000
  40463c:	43415254 	.word	0x43415254
  404640:	53415f45 	.word	0x53415f45
  404644:	54524553 	.word	0x54524553
  404648:	7270203a 	.word	0x7270203a
  40464c:	61725476 	.word	0x61725476
  404650:	65476563 	.word	0x65476563
  404654:	69725074 	.word	0x69725074
  404658:	7469726f 	.word	0x7469726f
  40465c:	6f725079 	.word	0x6f725079
  404660:	74726570 	.word	0x74726570
  404664:	49203a79 	.word	0x49203a79
  404668:	6c61766e 	.word	0x6c61766e
  40466c:	76206469 	.word	0x76206469
  404670:	65756c61 	.word	0x65756c61
  404674:	726f6620 	.word	0x726f6620
  404678:	00646920 	.word	0x00646920
  40467c:	20545744 	.word	0x20545744
  404680:	74696e75 	.word	0x74696e75
  404684:	746f6e20 	.word	0x746f6e20
  404688:	61766120 	.word	0x61766120
  40468c:	62616c69 	.word	0x62616c69
  404690:	202c656c 	.word	0x202c656c
  404694:	20656573 	.word	0x20656573
  404698:	65646f63 	.word	0x65646f63
  40469c:	6d6f6320 	.word	0x6d6f6320
  4046a0:	746e656d 	.word	0x746e656d
  4046a4:	0000002e 	.word	0x0000002e
  4046a8:	5f545744 	.word	0x5f545744
  4046ac:	43435943 	.word	0x43435943
  4046b0:	6e20544e 	.word	0x6e20544e
  4046b4:	6120746f 	.word	0x6120746f
  4046b8:	6c696176 	.word	0x6c696176
  4046bc:	656c6261 	.word	0x656c6261
  4046c0:	6573202c 	.word	0x6573202c
  4046c4:	6f632065 	.word	0x6f632065
  4046c8:	63206564 	.word	0x63206564
  4046cc:	656d6d6f 	.word	0x656d6d6f
  4046d0:	002e746e 	.word	0x002e746e
  4046d4:	65747441 	.word	0x65747441
  4046d8:	2074706d 	.word	0x2074706d
  4046dc:	69206f74 	.word	0x69206f74
  4046e0:	7865646e 	.word	0x7865646e
  4046e4:	74756f20 	.word	0x74756f20
  4046e8:	65646973 	.word	0x65646973
  4046ec:	65766520 	.word	0x65766520
  4046f0:	6220746e 	.word	0x6220746e
  4046f4:	65666675 	.word	0x65666675
  4046f8:	00002172 	.word	0x00002172
  4046fc:	43415254 	.word	0x43415254
  404700:	53415f45 	.word	0x53415f45
  404704:	54524553 	.word	0x54524553
  404708:	7270203a 	.word	0x7270203a
  40470c:	61725476 	.word	0x61725476
  404710:	704f6563 	.word	0x704f6563
  404714:	79536e65 	.word	0x79536e65
  404718:	6c6f626d 	.word	0x6c6f626d
  40471c:	616e203a 	.word	0x616e203a
  404720:	3d20656d 	.word	0x3d20656d
  404724:	554e203d 	.word	0x554e203d
  404728:	00004c4c 	.word	0x00004c4c
  40472c:	43415254 	.word	0x43415254
  404730:	53415f45 	.word	0x53415f45
  404734:	54524553 	.word	0x54524553
  404738:	7270203a 	.word	0x7270203a
  40473c:	61725476 	.word	0x61725476
  404740:	6f4c6563 	.word	0x6f4c6563
  404744:	70756b6f 	.word	0x70756b6f
  404748:	626d7953 	.word	0x626d7953
  40474c:	61546c6f 	.word	0x61546c6f
  404750:	45656c62 	.word	0x45656c62
  404754:	7972746e 	.word	0x7972746e
  404758:	656c203a 	.word	0x656c203a
  40475c:	3d3d206e 	.word	0x3d3d206e
  404760:	00003020 	.word	0x00003020
  404764:	43415254 	.word	0x43415254
  404768:	53415f45 	.word	0x53415f45
  40476c:	54524553 	.word	0x54524553
  404770:	7270203a 	.word	0x7270203a
  404774:	61725476 	.word	0x61725476
  404778:	72436563 	.word	0x72436563
  40477c:	65746165 	.word	0x65746165
  404780:	626d7953 	.word	0x626d7953
  404784:	61546c6f 	.word	0x61546c6f
  404788:	45656c62 	.word	0x45656c62
  40478c:	7972746e 	.word	0x7972746e
  404790:	656c203a 	.word	0x656c203a
  404794:	3d3d206e 	.word	0x3d3d206e
  404798:	00003020 	.word	0x00003020
  40479c:	626d7953 	.word	0x626d7953
  4047a0:	74206c6f 	.word	0x74206c6f
  4047a4:	656c6261 	.word	0x656c6261
  4047a8:	6c756620 	.word	0x6c756620
  4047ac:	49202e6c 	.word	0x49202e6c
  4047b0:	6572636e 	.word	0x6572636e
  4047b4:	20657361 	.word	0x20657361
  4047b8:	5f435254 	.word	0x5f435254
  4047bc:	5f474643 	.word	0x5f474643
  4047c0:	424d5953 	.word	0x424d5953
  4047c4:	545f4c4f 	.word	0x545f4c4f
  4047c8:	454c4241 	.word	0x454c4241
  4047cc:	5a49535f 	.word	0x5a49535f
  4047d0:	6e692045 	.word	0x6e692045
  4047d4:	63727420 	.word	0x63727420
  4047d8:	666e6f43 	.word	0x666e6f43
  4047dc:	682e6769 	.word	0x682e6769
  4047e0:	00000000 	.word	0x00000000
  4047e4:	43415254 	.word	0x43415254
  4047e8:	53415f45 	.word	0x53415f45
  4047ec:	54524553 	.word	0x54524553
  4047f0:	7270203a 	.word	0x7270203a
  4047f4:	61725476 	.word	0x61725476
  4047f8:	65536563 	.word	0x65536563
  4047fc:	6a624f74 	.word	0x6a624f74
  404800:	4e746365 	.word	0x4e746365
  404804:	3a656d61 	.word	0x3a656d61
  404808:	6d616e20 	.word	0x6d616e20
  40480c:	3d3d2065 	.word	0x3d3d2065
  404810:	4c554e20 	.word	0x4c554e20
  404814:	0000004c 	.word	0x0000004c
  404818:	656c6c49 	.word	0x656c6c49
  40481c:	206c6167 	.word	0x206c6167
  404820:	656a626f 	.word	0x656a626f
  404824:	63207463 	.word	0x63207463
  404828:	7373616c 	.word	0x7373616c
  40482c:	206e6920 	.word	0x206e6920
  404830:	54767270 	.word	0x54767270
  404834:	65636172 	.word	0x65636172
  404838:	4f746553 	.word	0x4f746553
  40483c:	63656a62 	.word	0x63656a62
  404840:	6d614e74 	.word	0x6d614e74
  404844:	00000065 	.word	0x00000065
  404848:	656c6c49 	.word	0x656c6c49
  40484c:	206c6167 	.word	0x206c6167
  404850:	646e6168 	.word	0x646e6168
  404854:	2820656c 	.word	0x2820656c
  404858:	69202930 	.word	0x69202930
  40485c:	7270206e 	.word	0x7270206e
  404860:	61725476 	.word	0x61725476
  404864:	65536563 	.word	0x65536563
  404868:	6a624f74 	.word	0x6a624f74
  40486c:	4e746365 	.word	0x4e746365
  404870:	2e656d61 	.word	0x2e656d61
  404874:	00000000 	.word	0x00000000
  404878:	43415254 	.word	0x43415254
  40487c:	53415f45 	.word	0x53415f45
  404880:	54524553 	.word	0x54524553
  404884:	7270203a 	.word	0x7270203a
  404888:	61725476 	.word	0x61725476
  40488c:	65536563 	.word	0x65536563
  404890:	6a624f74 	.word	0x6a624f74
  404894:	53746365 	.word	0x53746365
  404898:	65746174 	.word	0x65746174
  40489c:	626f203a 	.word	0x626f203a
  4048a0:	7463656a 	.word	0x7463656a
  4048a4:	73616c63 	.word	0x73616c63
  4048a8:	3d3e2073 	.word	0x3d3e2073
  4048ac:	41525420 	.word	0x41525420
  4048b0:	4e5f4543 	.word	0x4e5f4543
  4048b4:	53414c43 	.word	0x53414c43
  4048b8:	00534553 	.word	0x00534553
  4048bc:	43415254 	.word	0x43415254
  4048c0:	53415f45 	.word	0x53415f45
  4048c4:	54524553 	.word	0x54524553
  4048c8:	7270203a 	.word	0x7270203a
  4048cc:	61725476 	.word	0x61725476
  4048d0:	65536563 	.word	0x65536563
  4048d4:	6a624f74 	.word	0x6a624f74
  4048d8:	53746365 	.word	0x53746365
  4048dc:	65746174 	.word	0x65746174
  4048e0:	6e49203a 	.word	0x6e49203a
  4048e4:	696c6176 	.word	0x696c6176
  4048e8:	61762064 	.word	0x61762064
  4048ec:	2065756c 	.word	0x2065756c
  4048f0:	20726f66 	.word	0x20726f66
  4048f4:	00006469 	.word	0x00006469
  4048f8:	43415254 	.word	0x43415254
  4048fc:	53415f45 	.word	0x53415f45
  404900:	54524553 	.word	0x54524553
  404904:	7270203a 	.word	0x7270203a
  404908:	61725476 	.word	0x61725476
  40490c:	65536563 	.word	0x65536563
  404910:	69725074 	.word	0x69725074
  404914:	7469726f 	.word	0x7469726f
  404918:	6f725079 	.word	0x6f725079
  40491c:	74726570 	.word	0x74726570
  404920:	6f203a79 	.word	0x6f203a79
  404924:	63656a62 	.word	0x63656a62
  404928:	616c6374 	.word	0x616c6374
  40492c:	3e207373 	.word	0x3e207373
  404930:	5254203d 	.word	0x5254203d
  404934:	5f454341 	.word	0x5f454341
  404938:	414c434e 	.word	0x414c434e
  40493c:	53455353 	.word	0x53455353
  404940:	00000000 	.word	0x00000000
  404944:	43415254 	.word	0x43415254
  404948:	53415f45 	.word	0x53415f45
  40494c:	54524553 	.word	0x54524553
  404950:	7270203a 	.word	0x7270203a
  404954:	61725476 	.word	0x61725476
  404958:	65536563 	.word	0x65536563
  40495c:	69725074 	.word	0x69725074
  404960:	7469726f 	.word	0x7469726f
  404964:	6f725079 	.word	0x6f725079
  404968:	74726570 	.word	0x74726570
  40496c:	49203a79 	.word	0x49203a79
  404970:	6c61766e 	.word	0x6c61766e
  404974:	76206469 	.word	0x76206469
  404978:	65756c61 	.word	0x65756c61
  40497c:	726f6620 	.word	0x726f6620
  404980:	00646920 	.word	0x00646920
  404984:	43415254 	.word	0x43415254
  404988:	53415f45 	.word	0x53415f45
  40498c:	54524553 	.word	0x54524553
  404990:	7270203a 	.word	0x7270203a
  404994:	61725476 	.word	0x61725476
  404998:	65536563 	.word	0x65536563
  40499c:	73615474 	.word	0x73615474
  4049a0:	736e496b 	.word	0x736e496b
  4049a4:	636e6174 	.word	0x636e6174
  4049a8:	6e694665 	.word	0x6e694665
  4049ac:	65687369 	.word	0x65687369
  4049b0:	49203a64 	.word	0x49203a64
  4049b4:	6c61766e 	.word	0x6c61766e
  4049b8:	76206469 	.word	0x76206469
  4049bc:	65756c61 	.word	0x65756c61
  4049c0:	726f6620 	.word	0x726f6620
  4049c4:	6e616820 	.word	0x6e616820
  4049c8:	00656c64 	.word	0x00656c64
  4049cc:	43415254 	.word	0x43415254
  4049d0:	53415f45 	.word	0x53415f45
  4049d4:	54524553 	.word	0x54524553
  4049d8:	7270203a 	.word	0x7270203a
  4049dc:	61725476 	.word	0x61725476
  4049e0:	74536563 	.word	0x74536563
  4049e4:	4b65726f 	.word	0x4b65726f
  4049e8:	656e7265 	.word	0x656e7265
  4049ec:	6c61436c 	.word	0x6c61436c
  4049f0:	65203a6c 	.word	0x65203a6c
  4049f4:	65646f63 	.word	0x65646f63
  4049f8:	203d3e20 	.word	0x203d3e20
  4049fc:	46467830 	.word	0x46467830
  404a00:	00000000 	.word	0x00000000
  404a04:	43415254 	.word	0x43415254
  404a08:	53415f45 	.word	0x53415f45
  404a0c:	54524553 	.word	0x54524553
  404a10:	7270203a 	.word	0x7270203a
  404a14:	61725476 	.word	0x61725476
  404a18:	74536563 	.word	0x74536563
  404a1c:	4b65726f 	.word	0x4b65726f
  404a20:	656e7265 	.word	0x656e7265
  404a24:	6c61436c 	.word	0x6c61436c
  404a28:	6f203a6c 	.word	0x6f203a6c
  404a2c:	63656a62 	.word	0x63656a62
  404a30:	616c4374 	.word	0x616c4374
  404a34:	3e207373 	.word	0x3e207373
  404a38:	5254203d 	.word	0x5254203d
  404a3c:	5f454341 	.word	0x5f454341
  404a40:	414c434e 	.word	0x414c434e
  404a44:	53455353 	.word	0x53455353
  404a48:	00000000 	.word	0x00000000
  404a4c:	43415254 	.word	0x43415254
  404a50:	53415f45 	.word	0x53415f45
  404a54:	54524553 	.word	0x54524553
  404a58:	7270203a 	.word	0x7270203a
  404a5c:	61725476 	.word	0x61725476
  404a60:	74536563 	.word	0x74536563
  404a64:	4b65726f 	.word	0x4b65726f
  404a68:	656e7265 	.word	0x656e7265
  404a6c:	6c61436c 	.word	0x6c61436c
  404a70:	49203a6c 	.word	0x49203a6c
  404a74:	6c61766e 	.word	0x6c61766e
  404a78:	76206469 	.word	0x76206469
  404a7c:	65756c61 	.word	0x65756c61
  404a80:	726f6620 	.word	0x726f6620
  404a84:	6a626f20 	.word	0x6a626f20
  404a88:	4e746365 	.word	0x4e746365
  404a8c:	65626d75 	.word	0x65626d75
  404a90:	00000072 	.word	0x00000072
  404a94:	6f636552 	.word	0x6f636552
  404a98:	72656472 	.word	0x72656472
  404a9c:	73756220 	.word	0x73756220
  404aa0:	202d2079 	.word	0x202d2079
  404aa4:	68676968 	.word	0x68676968
  404aa8:	69727020 	.word	0x69727020
  404aac:	7469726f 	.word	0x7469726f
  404ab0:	53492079 	.word	0x53492079
  404ab4:	73752052 	.word	0x73752052
  404ab8:	20676e69 	.word	0x20676e69
  404abc:	63737973 	.word	0x63737973
  404ac0:	3f6c6c61 	.word	0x3f6c6c61
  404ac4:	29322820 	.word	0x29322820
  404ac8:	00000000 	.word	0x00000000
  404acc:	43415254 	.word	0x43415254
  404ad0:	53415f45 	.word	0x53415f45
  404ad4:	54524553 	.word	0x54524553
  404ad8:	7270203a 	.word	0x7270203a
  404adc:	61725476 	.word	0x61725476
  404ae0:	74536563 	.word	0x74536563
  404ae4:	4b65726f 	.word	0x4b65726f
  404ae8:	656e7265 	.word	0x656e7265
  404aec:	6c61436c 	.word	0x6c61436c
  404af0:	7469576c 	.word	0x7469576c
  404af4:	6d754e68 	.word	0x6d754e68
  404af8:	63697265 	.word	0x63697265
  404afc:	61726150 	.word	0x61726150
  404b00:	6c6e4f6d 	.word	0x6c6e4f6d
  404b04:	49203a79 	.word	0x49203a79
  404b08:	6c61766e 	.word	0x6c61766e
  404b0c:	76206469 	.word	0x76206469
  404b10:	65756c61 	.word	0x65756c61
  404b14:	726f6620 	.word	0x726f6620
  404b18:	74766520 	.word	0x74766520
  404b1c:	65646f63 	.word	0x65646f63
  404b20:	00000000 	.word	0x00000000
  404b24:	6f636552 	.word	0x6f636552
  404b28:	72656472 	.word	0x72656472
  404b2c:	73756220 	.word	0x73756220
  404b30:	202d2079 	.word	0x202d2079
  404b34:	68676968 	.word	0x68676968
  404b38:	69727020 	.word	0x69727020
  404b3c:	7469726f 	.word	0x7469726f
  404b40:	53492079 	.word	0x53492079
  404b44:	73752052 	.word	0x73752052
  404b48:	20676e69 	.word	0x20676e69
  404b4c:	63737973 	.word	0x63737973
  404b50:	3f6c6c61 	.word	0x3f6c6c61
  404b54:	29342820 	.word	0x29342820
  404b58:	00000000 	.word	0x00000000
  404b5c:	43415254 	.word	0x43415254
  404b60:	53415f45 	.word	0x53415f45
  404b64:	54524553 	.word	0x54524553
  404b68:	7270203a 	.word	0x7270203a
  404b6c:	61725476 	.word	0x61725476
  404b70:	74536563 	.word	0x74536563
  404b74:	4b65726f 	.word	0x4b65726f
  404b78:	656e7265 	.word	0x656e7265
  404b7c:	6c61436c 	.word	0x6c61436c
  404b80:	7469576c 	.word	0x7469576c
  404b84:	72615068 	.word	0x72615068
  404b88:	203a6d61 	.word	0x203a6d61
  404b8c:	63747665 	.word	0x63747665
  404b90:	2065646f 	.word	0x2065646f
  404b94:	30203d3e 	.word	0x30203d3e
  404b98:	00464678 	.word	0x00464678
  404b9c:	43415254 	.word	0x43415254
  404ba0:	53415f45 	.word	0x53415f45
  404ba4:	54524553 	.word	0x54524553
  404ba8:	7270203a 	.word	0x7270203a
  404bac:	61725476 	.word	0x61725476
  404bb0:	74536563 	.word	0x74536563
  404bb4:	4b65726f 	.word	0x4b65726f
  404bb8:	656e7265 	.word	0x656e7265
  404bbc:	6c61436c 	.word	0x6c61436c
  404bc0:	7469576c 	.word	0x7469576c
  404bc4:	72615068 	.word	0x72615068
  404bc8:	203a6d61 	.word	0x203a6d61
  404bcc:	656a626f 	.word	0x656a626f
  404bd0:	6c437463 	.word	0x6c437463
  404bd4:	20737361 	.word	0x20737361
  404bd8:	54203d3e 	.word	0x54203d3e
  404bdc:	45434152 	.word	0x45434152
  404be0:	4c434e5f 	.word	0x4c434e5f
  404be4:	45535341 	.word	0x45535341
  404be8:	00000053 	.word	0x00000053
  404bec:	43415254 	.word	0x43415254
  404bf0:	53415f45 	.word	0x53415f45
  404bf4:	54524553 	.word	0x54524553
  404bf8:	7270203a 	.word	0x7270203a
  404bfc:	61725476 	.word	0x61725476
  404c00:	74536563 	.word	0x74536563
  404c04:	4b65726f 	.word	0x4b65726f
  404c08:	656e7265 	.word	0x656e7265
  404c0c:	6c61436c 	.word	0x6c61436c
  404c10:	7469576c 	.word	0x7469576c
  404c14:	72615068 	.word	0x72615068
  404c18:	203a6d61 	.word	0x203a6d61
  404c1c:	61766e49 	.word	0x61766e49
  404c20:	2064696c 	.word	0x2064696c
  404c24:	756c6176 	.word	0x756c6176
  404c28:	6f662065 	.word	0x6f662065
  404c2c:	626f2072 	.word	0x626f2072
  404c30:	7463656a 	.word	0x7463656a
  404c34:	626d754e 	.word	0x626d754e
  404c38:	00007265 	.word	0x00007265
  404c3c:	6f636552 	.word	0x6f636552
  404c40:	72656472 	.word	0x72656472
  404c44:	73756220 	.word	0x73756220
  404c48:	202d2079 	.word	0x202d2079
  404c4c:	68676968 	.word	0x68676968
  404c50:	69727020 	.word	0x69727020
  404c54:	7469726f 	.word	0x7469726f
  404c58:	53492079 	.word	0x53492079
  404c5c:	73752052 	.word	0x73752052
  404c60:	20676e69 	.word	0x20676e69
  404c64:	63737973 	.word	0x63737973
  404c68:	3f6c6c61 	.word	0x3f6c6c61
  404c6c:	29332820 	.word	0x29332820
  404c70:	00000000 	.word	0x00000000
  404c74:	43415254 	.word	0x43415254
  404c78:	53415f45 	.word	0x53415f45
  404c7c:	54524553 	.word	0x54524553
  404c80:	7270203a 	.word	0x7270203a
  404c84:	61725476 	.word	0x61725476
  404c88:	74536563 	.word	0x74536563
  404c8c:	4f65726f 	.word	0x4f65726f
  404c90:	63656a62 	.word	0x63656a62
  404c94:	6d614e74 	.word	0x6d614e74
  404c98:	436e4f65 	.word	0x436e4f65
  404c9c:	65736f6c 	.word	0x65736f6c
  404ca0:	6e657645 	.word	0x6e657645
  404ca4:	6f203a74 	.word	0x6f203a74
  404ca8:	63656a62 	.word	0x63656a62
  404cac:	616c6374 	.word	0x616c6374
  404cb0:	3e207373 	.word	0x3e207373
  404cb4:	5254203d 	.word	0x5254203d
  404cb8:	5f454341 	.word	0x5f454341
  404cbc:	414c434e 	.word	0x414c434e
  404cc0:	53455353 	.word	0x53455353
  404cc4:	00000000 	.word	0x00000000
  404cc8:	43415254 	.word	0x43415254
  404ccc:	53415f45 	.word	0x53415f45
  404cd0:	54524553 	.word	0x54524553
  404cd4:	7270203a 	.word	0x7270203a
  404cd8:	61725476 	.word	0x61725476
  404cdc:	74536563 	.word	0x74536563
  404ce0:	4f65726f 	.word	0x4f65726f
  404ce4:	63656a62 	.word	0x63656a62
  404ce8:	6d614e74 	.word	0x6d614e74
  404cec:	436e4f65 	.word	0x436e4f65
  404cf0:	65736f6c 	.word	0x65736f6c
  404cf4:	6e657645 	.word	0x6e657645
  404cf8:	49203a74 	.word	0x49203a74
  404cfc:	6c61766e 	.word	0x6c61766e
  404d00:	76206469 	.word	0x76206469
  404d04:	65756c61 	.word	0x65756c61
  404d08:	726f6620 	.word	0x726f6620
  404d0c:	6e616820 	.word	0x6e616820
  404d10:	00656c64 	.word	0x00656c64
  404d14:	43415254 	.word	0x43415254
  404d18:	53415f45 	.word	0x53415f45
  404d1c:	54524553 	.word	0x54524553
  404d20:	7270203a 	.word	0x7270203a
  404d24:	61725476 	.word	0x61725476
  404d28:	74536563 	.word	0x74536563
  404d2c:	4f65726f 	.word	0x4f65726f
  404d30:	63656a62 	.word	0x63656a62
  404d34:	6f725074 	.word	0x6f725074
  404d38:	74726570 	.word	0x74726570
  404d3c:	4f736569 	.word	0x4f736569
  404d40:	6f6c436e 	.word	0x6f6c436e
  404d44:	76456573 	.word	0x76456573
  404d48:	3a746e65 	.word	0x3a746e65
  404d4c:	6a626f20 	.word	0x6a626f20
  404d50:	63746365 	.word	0x63746365
  404d54:	7373616c 	.word	0x7373616c
  404d58:	203d3e20 	.word	0x203d3e20
  404d5c:	43415254 	.word	0x43415254
  404d60:	434e5f45 	.word	0x434e5f45
  404d64:	5353414c 	.word	0x5353414c
  404d68:	00005345 	.word	0x00005345
  404d6c:	43415254 	.word	0x43415254
  404d70:	53415f45 	.word	0x53415f45
  404d74:	54524553 	.word	0x54524553
  404d78:	7270203a 	.word	0x7270203a
  404d7c:	61725476 	.word	0x61725476
  404d80:	74536563 	.word	0x74536563
  404d84:	4f65726f 	.word	0x4f65726f
  404d88:	63656a62 	.word	0x63656a62
  404d8c:	6f725074 	.word	0x6f725074
  404d90:	74726570 	.word	0x74726570
  404d94:	4f736569 	.word	0x4f736569
  404d98:	6f6c436e 	.word	0x6f6c436e
  404d9c:	76456573 	.word	0x76456573
  404da0:	3a746e65 	.word	0x3a746e65
  404da4:	766e4920 	.word	0x766e4920
  404da8:	64696c61 	.word	0x64696c61
  404dac:	6c617620 	.word	0x6c617620
  404db0:	66206575 	.word	0x66206575
  404db4:	6820726f 	.word	0x6820726f
  404db8:	6c646e61 	.word	0x6c646e61
  404dbc:	00000065 	.word	0x00000065
  404dc0:	43415254 	.word	0x43415254
  404dc4:	53415f45 	.word	0x53415f45
  404dc8:	54524553 	.word	0x54524553
  404dcc:	7270203a 	.word	0x7270203a
  404dd0:	61725476 	.word	0x61725476
  404dd4:	74536563 	.word	0x74536563
  404dd8:	5465726f 	.word	0x5465726f
  404ddc:	526b7361 	.word	0x526b7361
  404de0:	79646165 	.word	0x79646165
  404de4:	6e49203a 	.word	0x6e49203a
  404de8:	696c6176 	.word	0x696c6176
  404dec:	61762064 	.word	0x61762064
  404df0:	2065756c 	.word	0x2065756c
  404df4:	20726f66 	.word	0x20726f66
  404df8:	646e6168 	.word	0x646e6168
  404dfc:	0000656c 	.word	0x0000656c
  404e00:	6f636552 	.word	0x6f636552
  404e04:	72656472 	.word	0x72656472
  404e08:	73756220 	.word	0x73756220
  404e0c:	202d2079 	.word	0x202d2079
  404e10:	68676968 	.word	0x68676968
  404e14:	69727020 	.word	0x69727020
  404e18:	7469726f 	.word	0x7469726f
  404e1c:	53492079 	.word	0x53492079
  404e20:	73752052 	.word	0x73752052
  404e24:	20676e69 	.word	0x20676e69
  404e28:	63737973 	.word	0x63737973
  404e2c:	3f6c6c61 	.word	0x3f6c6c61
  404e30:	29312820 	.word	0x29312820
  404e34:	00000000 	.word	0x00000000
  404e38:	43415254 	.word	0x43415254
  404e3c:	53415f45 	.word	0x53415f45
  404e40:	54524553 	.word	0x54524553
  404e44:	7270203a 	.word	0x7270203a
  404e48:	61725476 	.word	0x61725476
  404e4c:	74536563 	.word	0x74536563
  404e50:	5465726f 	.word	0x5465726f
  404e54:	736b7361 	.word	0x736b7361
  404e58:	63746977 	.word	0x63746977
  404e5c:	49203a68 	.word	0x49203a68
  404e60:	6c61766e 	.word	0x6c61766e
  404e64:	76206469 	.word	0x76206469
  404e68:	65756c61 	.word	0x65756c61
  404e6c:	726f6620 	.word	0x726f6620
  404e70:	73617420 	.word	0x73617420
  404e74:	61685f6b 	.word	0x61685f6b
  404e78:	656c646e 	.word	0x656c646e
  404e7c:	00000000 	.word	0x00000000
  404e80:	43415254 	.word	0x43415254
  404e84:	53415f45 	.word	0x53415f45
  404e88:	54524553 	.word	0x54524553
  404e8c:	7270203a 	.word	0x7270203a
  404e90:	61725476 	.word	0x61725476
  404e94:	65476563 	.word	0x65476563
  404e98:	6a624f74 	.word	0x6a624f74
  404e9c:	53746365 	.word	0x53746365
  404ea0:	65746174 	.word	0x65746174
  404ea4:	6e49203a 	.word	0x6e49203a
  404ea8:	696c6176 	.word	0x696c6176
  404eac:	61762064 	.word	0x61762064
  404eb0:	2065756c 	.word	0x2065756c
  404eb4:	20726f66 	.word	0x20726f66
  404eb8:	00006469 	.word	0x00006469
  404ebc:	43415254 	.word	0x43415254
  404ec0:	53415f45 	.word	0x53415f45
  404ec4:	54524553 	.word	0x54524553
  404ec8:	6975203a 	.word	0x6975203a
  404ecc:	65646e49 	.word	0x65646e49
  404ed0:	4f664f78 	.word	0x4f664f78
  404ed4:	63656a62 	.word	0x63656a62
  404ed8:	49203a74 	.word	0x49203a74
  404edc:	6c61766e 	.word	0x6c61766e
  404ee0:	76206469 	.word	0x76206469
  404ee4:	65756c61 	.word	0x65756c61
  404ee8:	726f6620 	.word	0x726f6620
  404eec:	6a626f20 	.word	0x6a626f20
  404ef0:	63746365 	.word	0x63746365
  404ef4:	7373616c 	.word	0x7373616c
  404ef8:	00000000 	.word	0x00000000
  404efc:	43415254 	.word	0x43415254
  404f00:	53415f45 	.word	0x53415f45
  404f04:	54524553 	.word	0x54524553
  404f08:	6975203a 	.word	0x6975203a
  404f0c:	65646e49 	.word	0x65646e49
  404f10:	4f664f78 	.word	0x4f664f78
  404f14:	63656a62 	.word	0x63656a62
  404f18:	49203a74 	.word	0x49203a74
  404f1c:	6c61766e 	.word	0x6c61766e
  404f20:	76206469 	.word	0x76206469
  404f24:	65756c61 	.word	0x65756c61
  404f28:	726f6620 	.word	0x726f6620
  404f2c:	6a626f20 	.word	0x6a626f20
  404f30:	68746365 	.word	0x68746365
  404f34:	6c646e61 	.word	0x6c646e61
  404f38:	00000065 	.word	0x00000065
  404f3c:	6f636552 	.word	0x6f636552
  404f40:	72656472 	.word	0x72656472
  404f44:	61746144 	.word	0x61746144
  404f48:	20727450 	.word	0x20727450
  404f4c:	4e207369 	.word	0x4e207369
  404f50:	2e4c4c55 	.word	0x2e4c4c55
  404f54:	6c614320 	.word	0x6c614320
  404f58:	5476206c 	.word	0x5476206c
  404f5c:	65636172 	.word	0x65636172
  404f60:	74696e49 	.word	0x74696e49
  404f64:	63617254 	.word	0x63617254
  404f68:	74614465 	.word	0x74614465
  404f6c:	20292861 	.word	0x20292861
  404f70:	6f666562 	.word	0x6f666562
  404f74:	73206572 	.word	0x73206572
  404f78:	74726174 	.word	0x74726174
  404f7c:	20676e69 	.word	0x20676e69
  404f80:	63617274 	.word	0x63617274
  404f84:	00002e65 	.word	0x00002e65
  404f88:	61747328 	.word	0x61747328
  404f8c:	70757472 	.word	0x70757472
  404f90:	00000029 	.word	0x00000029
  404f94:	63617254 	.word	0x63617254
  404f98:	65522065 	.word	0x65522065
  404f9c:	64726f63 	.word	0x64726f63
  404fa0:	44207265 	.word	0x44207265
  404fa4:	006f6d65 	.word	0x006f6d65
  404fa8:	61725476 	.word	0x61725476
  404fac:	6e456563 	.word	0x6e456563
  404fb0:	656c6261 	.word	0x656c6261
  404fb4:	43525428 	.word	0x43525428
  404fb8:	4154535f 	.word	0x4154535f
  404fbc:	415f5452 	.word	0x415f5452
  404fc0:	54494157 	.word	0x54494157
  404fc4:	534f485f 	.word	0x534f485f
  404fc8:	6e202954 	.word	0x6e202954
  404fcc:	6120746f 	.word	0x6120746f
  404fd0:	776f6c6c 	.word	0x776f6c6c
  404fd4:	69206465 	.word	0x69206465
  404fd8:	6e53206e 	.word	0x6e53206e
  404fdc:	68737061 	.word	0x68737061
  404fe0:	6d20746f 	.word	0x6d20746f
  404fe4:	0065646f 	.word	0x0065646f
  404fe8:	78656e55 	.word	0x78656e55
  404fec:	74636570 	.word	0x74636570
  404ff0:	61206465 	.word	0x61206465
  404ff4:	6d756772 	.word	0x6d756772
  404ff8:	20746e65 	.word	0x20746e65
  404ffc:	76206f74 	.word	0x76206f74
  405000:	63617254 	.word	0x63617254
  405004:	616e4565 	.word	0x616e4565
  405008:	20656c62 	.word	0x20656c62
  40500c:	616e7328 	.word	0x616e7328
  405010:	6f687370 	.word	0x6f687370
  405014:	6f6d2074 	.word	0x6f6d2074
  405018:	00296564 	.word	0x00296564
  40501c:	6b736154 	.word	0x6b736154
  405020:	00000031 	.word	0x00000031
  405024:	6b736154 	.word	0x6b736154
  405028:	00000032 	.word	0x00000032

0040502c <_global_impure_ptr>:
  40502c:	20000018                                ... 

00405030 <_init>:
  405030:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  405032:	bf00      	nop
  405034:	bcf8      	pop	{r3, r4, r5, r6, r7}
  405036:	bc08      	pop	{r3}
  405038:	469e      	mov	lr, r3
  40503a:	4770      	bx	lr

0040503c <__init_array_start>:
  40503c:	00403ff1 	.word	0x00403ff1

00405040 <__frame_dummy_init_array_entry>:
  405040:	004000f1                                ..@.

00405044 <_fini>:
  405044:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  405046:	bf00      	nop
  405048:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40504a:	bc08      	pop	{r3}
  40504c:	469e      	mov	lr, r3
  40504e:	4770      	bx	lr

00405050 <__fini_array_start>:
  405050:	004000cd 	.word	0x004000cd
